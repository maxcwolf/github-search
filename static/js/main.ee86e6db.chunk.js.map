{"version":3,"sources":["__generated__/graphql.ts","theme/theme-default.ts","hooks/useObservable.ts","observables/index.ts","components/SearchField.tsx","components/SearchResult.tsx","pages/Search.tsx","hooks/useDebounce.ts","components/LayoutHeader.tsx","components/Layout.tsx","pages/Detail.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["AuditLogOrderField","CheckAnnotationLevel","CheckConclusionState","CheckRunType","CheckStatusState","CollaboratorAffiliation","CommentAuthorAssociation","CommentCannotUpdateReason","CommitContributionOrderField","ContributionLevel","DefaultRepositoryPermissionField","DeploymentOrderField","DeploymentProtectionRuleType","DeploymentReviewState","DeploymentState","DeploymentStatusState","DiffSide","DiscussionOrderField","DismissReason","EnterpriseAdministratorInvitationOrderField","EnterpriseAdministratorRole","EnterpriseDefaultRepositoryPermissionSettingValue","EnterpriseEnabledDisabledSettingValue","EnterpriseEnabledSettingValue","EnterpriseMemberOrderField","EnterpriseMembersCanCreateRepositoriesSettingValue","EnterpriseMembersCanMakePurchasesSettingValue","EnterpriseServerInstallationOrderField","EnterpriseServerUserAccountEmailOrderField","EnterpriseServerUserAccountOrderField","EnterpriseServerUserAccountsUploadOrderField","EnterpriseServerUserAccountsUploadSyncState","EnterpriseUserAccountMembershipRole","EnterpriseUserDeployment","FileViewedState","FundingPlatform","GistOrderField","GistPrivacy","GitSignatureState","IdentityProviderConfigurationState","IpAllowListEnabledSettingValue","IpAllowListEntryOrderField","IpAllowListForInstalledAppsEnabledSettingValue","IssueCommentOrderField","IssueOrderField","IssueState","IssueTimelineItemsItemType","LabelOrderField","LanguageOrderField","LockReason","MergeStateStatus","MergeableState","MilestoneOrderField","MilestoneState","NotificationRestrictionSettingValue","OidcProviderType","OauthApplicationCreateAuditEntryState","OperationType","OrderDirection","OrgAddMemberAuditEntryPermission","OrgCreateAuditEntryBillingPlan","OrgRemoveBillingManagerAuditEntryReason","OrgRemoveMemberAuditEntryMembershipType","OrgRemoveMemberAuditEntryReason","OrgRemoveOutsideCollaboratorAuditEntryMembershipType","OrgRemoveOutsideCollaboratorAuditEntryReason","OrgUpdateDefaultRepositoryPermissionAuditEntryPermission","OrgUpdateMemberAuditEntryPermission","OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility","OrganizationInvitationRole","OrganizationInvitationType","OrganizationMemberRole","OrganizationMembersCanCreateRepositoriesSettingValue","OrganizationOrderField","PackageFileOrderField","PackageOrderField","PackageType","PackageVersionOrderField","PinnableItemType","PinnedDiscussionGradient","PinnedDiscussionPattern","ProjectCardArchivedState","ProjectCardState","ProjectColumnPurpose","ProjectOrderField","ProjectState","ProjectTemplate","PullRequestMergeMethod","PullRequestOrderField","PullRequestReviewCommentState","PullRequestReviewDecision","PullRequestReviewEvent","PullRequestReviewState","PullRequestState","PullRequestTimelineItemsItemType","PullRequestUpdateState","ReactionContent","ReactionOrderField","RefOrderField","ReleaseOrderField","RepoAccessAuditEntryVisibility","RepoAddMemberAuditEntryVisibility","RepoArchivedAuditEntryVisibility","RepoChangeMergeSettingAuditEntryMergeType","RepoCreateAuditEntryVisibility","RepoDestroyAuditEntryVisibility","RepoRemoveMemberAuditEntryVisibility","ReportedContentClassifiers","RepositoryAffiliation","RepositoryContributionType","RepositoryInteractionLimit","RepositoryInteractionLimitExpiry","RepositoryInteractionLimitOrigin","RepositoryInvitationOrderField","RepositoryLockReason","RepositoryOrderField","RepositoryPermission","RepositoryPrivacy","RepositoryVisibility","RequestableCheckStatusState","SamlDigestAlgorithm","SamlSignatureAlgorithm","SavedReplyOrderField","SearchType","SecurityAdvisoryEcosystem","SecurityAdvisoryIdentifierType","SecurityAdvisoryOrderField","SecurityAdvisorySeverity","SecurityVulnerabilityOrderField","SponsorOrderField","SponsorableOrderField","SponsorsActivityAction","SponsorsActivityOrderField","SponsorsActivityPeriod","SponsorsGoalKind","SponsorsTierOrderField","SponsorshipNewsletterOrderField","SponsorshipOrderField","SponsorshipPrivacy","StarOrderField","StatusState","SubscriptionState","TeamDiscussionCommentOrderField","TeamDiscussionOrderField","TeamMemberOrderField","TeamMemberRole","TeamMembershipType","TeamOrderField","TeamPrivacy","TeamRepositoryOrderField","TeamReviewAssignmentAlgorithm","TeamRole","TopicSuggestionDeclineReason","UserBlockDuration","UserStatusOrderField","VerifiableDomainOrderField","baseColors","transparent","black","white","gray","red","orange","yellow","green","teal","blue","indigo","purple","pink","commonButtonStyles","py","px","cursor","fontSize","lineHeight","buttons","simple","backgroundColor","border","color","fontWeight","borderRadius","pill","outline","borderWidth","borderStyle","borderColor","bordered","disabled","opacity","borderBottomWidth","borderBottomStyle","borderBottomColor","transition","transform","elevated","boxShadow","colors","grayDark","text","background","primary","primaryHover","secondary","muted","success","info","warning","danger","light","dark","textMuted","baseFonts","sans","serif","mono","fonts","body","heading","monospace","baseFontWeights","hairline","thin","normal","medium","semibold","bold","extrabold","fontWeights","label","commonInputStyles","appearance","inputs","shadow","inline","underline","baseLineHeights","none","tight","snug","relaxed","loose","tailwindSpacing","fontFamily","m","mb","theme","borderWidths","breakpoints","fontSizes","letterSpacings","tighter","wide","wider","widest","lineHeights","sizes","xs","sm","md","lg","xl","full","screenHeight","screenWidth","shadows","default","inner","space","radii","zIndices","auto","styles","root","a","textDecoration","h1","mt","h2","h3","h4","h5","h6","code","pre","hr","bg","height","cards","padding","compact","forms","transforms","transformOrigin","center","top","right","bottom","left","translate","scale","rotate","skew","transitions","property","all","timingFunction","linear","in","out","duration","useGetReposQuery","variables","options","useQuery","query","fetch","method","headers","Authorization","process","REACT_APP_GITHUB_KEY","JSON","stringify","res","json","errors","message","Error","data","fetcher","createUseObservable","effectVariant","observable","initialValue","value","useState","val","setValue","subscription","subscribe","unsubscribe","bind","useObservable","useEffect","useLayoutEffect","repo$","BehaviorSubject","undefined","toRepo","next","page$","toPage","input$","toInput","sort$","toSort","onInputChange","event","target","onRadioChange","currentTarget","SearchField","input","sort","inputRef","useRef","current","focus","sx","flexDirection","htmlFor","id","name","variant","onChange","ref","justifyContent","pr","mx","checked","SearchResult","ownerName","starCount","onClick","p","display","flex","getSearchInput","onPageNavigate","page","repo","Search","debouncedInput","delay","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout","useDebounce","search_term","isLoading","alignContent","pb","fontStyle","search","repositoryCount","edges","map","result","isEmpty","node","isNil","owner","login","stargazers","totalCount","LayoutHeader","width","src","font","pl","Layout","children","DetailField","title","mr","Detail","href","url","avatarUrl","primaryLanguage","description","queryClient","QueryClient","queryCache","QueryCache","onError","error","state","toast","App","client","initialIsOpen","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","document","getElementById"],"mappings":"gIAknBYA,EAohBAC,EAsCAC,EAgKAC,EAQAC,EA4SAC,EAmDAC,EAoBAC,EAiYAC,EAmMAC,EA8mCAC,EAwjBAC,EA8CAC,EA6FAC,EA+BAC,EAmEAC,EAoBAC,EA8WAC,EA0BAC,EAkOAC,EAMAC,EAoDAC,EAcAC,EAUAC,EA0EAC,EAQAC,EAcAC,EAykBAC,EAyGAC,EAcAC,EAqDAC,EAMAC,EAwEAC,EAQAC,EA2PAC,EA0DAC,EAgPAC,EAUAC,EAqGAC,EAsHAC,EAwDAC,EAqDAC,EAQAC,EAuUAC,EAiFAC,EAUAC,EAyHAC,EAkKAC,EA2EAC,EAyFAC,EAohBAC,EAoBAC,GA+HAC,GAYAC,GAi1CAC,GA8BAC,GAwEAC,GAUAC,GAkBAC,GA8FAC,GAsLAC,GA4iBAC,GAuDAC,GA0BAC,GA2DAC,GAiBAC,GAuMAC,GAyDAC,GAqDAC,GAqpBAC,GAYAC,GAgCAC,GAQAC,GAoBAC,GA0JAC,GAcAC,GAwCAC,GA8EAC,GA4EAC,GAgEAC,GAcAC,GA2VAC,GAuCAC,GAwEAC,GAqQAC,GA2DAC,GAQAC,GAyiBAC,GAkBAC,GAmPAC,GAqCAC,GAkBAC,GAYAC,GA4FAC,GAgKAC,GAkHAC,GA4WAC,GAuEAC,GA2GAC,GAsRAC,GAkUAC,GA8DAC,GAqHAC,GAgEAC,GAsjBAC,GA8DAC,GA8DAC,GAiEAC,GA+jBAC,GAwEAC,GAoIAC,GAYAC,GAcAC,GAuDAC,GAQAC,GA0BAC,GAuDAC,GAiBAC,GAwCAC,GAkLAC,GAqNAC,GAYAC,GAuDAC,GAiDAC,GAiFAC,GA4CAC,GAgBAC,GA4BAC,GAgEAC,GAgJAC,GA+IAC,GAuBAC,GA4CAC,GAMAC,GA6BAC,GA4HAC,GAqHAC,GAcAC,GAMAC,GAgBAC,GA+KAC,GA0FAC,GAynBAC,GAkCAC,GA+CAC,GAQAC,GAQAC,GAkBAC,GAMAC,GAsJAC,GAgBAC,GAQAC,GAqFAC,GAo5DAC,GAmJAC,GAmEAC,G,wEC3zrBNC,GAA6B,CACjCC,YAAa,cACbC,MAAO,OACPC,MAAO,OACPC,KAAM,CACJ,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,IAAK,CACH,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,OAAQ,CACN,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,OAAQ,CACN,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,MAAO,CACL,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,KAAM,CACJ,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,KAAM,CACJ,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,OAAQ,CACN,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,OAAQ,CACN,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEFC,KAAM,CACJ,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,YAIEC,GAAqB,CACzBC,GAAI,EACJC,GAAI,EACJC,OAAO,UACPC,SAAS,OACTC,WAAW,WAGPC,GAAU,CACdC,OAAO,6BACFP,IADC,IAEJQ,gBAAgB,UAChBC,OAAO,OACPC,MAAM,QACNC,WAAW,OACXC,aAAa,UACb,UAAW,CACTJ,gBAAgB,kBAGpBK,KAAK,6BACAb,IADD,IAEFQ,gBAAgB,UAChBC,OAAO,OACPC,MAAM,QACNC,WAAW,OACXC,aAAa,OACb,UAAW,CACTJ,gBAAgB,kBAGpBM,QAAQ,6BACHd,IADE,IAELQ,gBAAgB,cAChBO,YAAY,MACZC,YAAY,QACZC,YAAY,UACZP,MAAM,UACNC,WAAW,WACXC,aAAa,UACb,UAAW,CACTJ,gBAAgB,UAChBE,MAAM,QACNO,YAAY,iBAGhBC,SAAS,6BACJlB,IADG,IAENQ,gBAAgB,UAChBO,YAAY,MACZC,YAAY,QACZC,YAAY,eACZP,MAAM,QACNC,WAAW,OACXC,aAAa,UACb,UAAW,CACTJ,gBAAgB,kBAGpBW,SAAS,6BACJnB,IADG,IAENQ,gBAAgB,UAChBC,OAAO,OACPW,QAAS,GACTjB,OAAO,cACPO,MAAM,QACNC,WAAW,OACXC,aAAa,YAEf,KAAK,6BACAZ,IADL,IAEEQ,gBAAgB,UAChBC,OAAO,OACPY,kBAAkB,MAClBC,kBAAkB,QAClBC,kBAAkB,eAClBb,MAAM,QACNC,WAAW,OACXC,aAAa,UACbY,WAAW,6BACX,UAAW,CACTC,UAAU,sBAGdC,SAAS,6BACJ1B,IADG,IAENQ,gBAAgB,QAChBO,YAAY,MACZC,YAAY,QACZC,YAAY,SACZP,MAAM,OACNC,WAAW,OACXC,aAAa,UACbe,UAAU,UACV,UAAW,CACTnB,gBAAgB,aAKhBoB,GAAyB,6BAC1B1C,IADyB,IAE5B2C,SAAU3C,GAAWI,KAAK,GAC1BwC,KAAM5C,GAAWI,KAAK,GACtByC,WAAY7C,GAAWG,MACvB2C,QAAS9C,GAAWU,KAAK,GACzBqC,aAAc/C,GAAWU,KAAK,GAC9BsC,UAAWhD,GAAWI,KAAK,GAC3B6C,MAAOjD,GAAWI,KAAK,GACvB8C,QAASlD,GAAWQ,MAAM,GAC1B2C,KAAMnD,GAAWU,KAAK,GACtB0C,QAASpD,GAAWO,OAAO,GAC3B8C,OAAQrD,GAAWK,IAAI,GACvBiD,MAAOtD,GAAWI,KAAK,GACvBmD,KAAMvD,GAAWI,KAAK,GACtBoD,UAAWxD,GAAWI,KAAK,KAGvBqD,GAAY,CAChBC,KAAM,uLACNC,MAAO,gDACPC,KAAM,mEAGFC,GAAK,6BACNJ,IADM,IAETK,KAAML,GAAUC,KAChBK,QAAS,UACTC,UAAWP,GAAUG,OAejBK,GAAkB,CACtBC,SAAU,IACVC,KAAM,IACNb,MAAO,IACPc,OAAQ,IACRC,OAAQ,IACRC,SAAU,IACVC,KAAM,IACNC,UAAW,IACXtE,MAAO,KAGHuE,GAAW,6BACZR,IADY,IAEfH,KAAMG,GAAgBG,OACtBL,QAASE,GAAgBM,KACzBG,MAAOT,GAAgBE,OAGnBQ,GAAoB,CACxB5D,GAAI,EACJC,GAAI,EACJE,SAAS,OACTQ,aAAa,UACbkD,WAAW,OACXzD,WAAW,SAGP0D,GAAS,CACbC,OAAO,6BACFH,IADC,IAEJpD,OAAO,OACPC,MAAM,SACNiB,UAAU,UACV,UAAW,CACTb,QAAQ,OACRa,UAAU,aAGdsC,OAAO,6BACFJ,IADC,IAEJrD,gBAAgB,SAChBO,YAAY,MACZC,YAAY,QACZC,YAAY,SACZP,MAAM,SACN,UAAW,CACTI,QAAQ,OACRG,YAAY,UACZT,gBAAgB,WAGpB0D,UAAU,6BACLL,IADI,IAEPrD,gBAAgB,cAChBC,OAAO,OACPY,kBAAkB,MAClBC,kBAAkB,QAClBC,kBAAkB,UAClBX,aAAa,MACbF,MAAM,SACN,UAAW,CACTI,QAAQ,OACRG,YAAY,UACZT,gBAAgB,YAoBhB2D,GAAkB,CACtBC,KAAM,IACNC,MAAO,OACPC,KAAM,QACNhB,OAAQ,MACRiB,QAAS,QACTC,MAAO,KAkBHC,GAAkB,CACtBvE,GAAI,MACJ,EAAK,IACL,EAAK,UACL,EAAK,SACL,EAAK,UACL,EAAK,OACL,EAAK,UACL,EAAK,SACL,EAAK,OACL,GAAM,SACN,GAAM,OACN,GAAM,OACN,GAAM,OACN,GAAM,OACN,GAAM,OACN,GAAM,QACN,GAAM,QACN,GAAM,QACN,GAAM,SA+EF+C,GAAU,CACdyB,WAAY,UACZ/D,WAAY,UACZN,WAAY,UACZsE,EAAG,EACHC,GAAI,GAmJOC,GAAkB,CAC7BC,aA9nBmB,CACnB5E,GAAI,MACJ,EAAK,IACL,EAAK,MACL,EAAK,MACL,EAAK,OA0nBL6E,YAvnBkB,CAAC,QAAS,QAAS,SAAU,UAwnB/CnD,UACAmB,SACAiC,UAvXgB,CAChB,WACA,OACA,UACA,SACA,WACA,UACA,OACA,OACA,UA+WArB,eACAsB,eAlSqB,CACrBC,QAAS,UACTb,MAAO,WACPf,OAAQ,IACR6B,KAAM,UACNC,MAAO,SACPC,OAAQ,SA6RRC,YAjRe,6BACZnB,IADY,IAEfnB,KAAMmB,GAAgBI,QACtBtB,QAASkB,GAAgBE,QA+QzBkB,MAnMS,uDACNd,IA3CoB,CACvBe,GAAI,QACJC,GAAI,QACJC,GAAI,QACJC,GAAI,QACJC,GAAI,QACJ,MAAO,QACP,MAAO,QACP,MAAO,QACP,MAAO,QACP,MAAO,UAGa,CACpB,MAAO,MACP,MAAO,aACP,MAAO,aACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,MACP,MAAO,aACP,MAAO,aACP,MAAO,MACP,MAAO,aACP,MAAO,aACP,OAAQ,YACR,OAAQ,aACR,OAAQ,MACR,OAAQ,aACR,OAAQ,aACR,OAAQ,MACR,OAAQ,aACR,OAAQ,aACR,OAAQ,MACR,QAAS,aACT,QAAS,eAGA,IAITC,KAAM,OACNC,aAAc,QACdC,YAAa,UA8LbC,QA3Lc,CACdR,GAAI,gCACJC,GAAI,kCACJQ,QAAS,kEACTP,GAAI,wEACJC,GAAI,0EACJC,GAAI,4EACJ,MAAO,wCACPM,MAAO,wCACPpF,QAAS,oCACTsD,KAAM,QAkLN+B,MA/KY,CAAC,IAAK,UAAW,SAAU,OAAQ,OAAQ,OAAQ,OAAQ,QAAS,SAgLhFC,MA/QY,CACZhC,KAAM,IACNqB,GAAI,WACJQ,QAAS,UACTP,GAAI,WACJC,GAAI,SACJE,KAAM,UA0QNQ,SA/Ke,CACfC,KAAM,OACN,EAAK,EACL,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,IAyKNC,OAhJa,CACbC,KAAM,CACJ9B,WAAY,OACZrE,WAAY,OACZM,WAAY,QAEd8F,EAAG,CACD/F,MAAO,UACPgG,eAAgB,OAChB,SAAU,CACRA,eAAgB,cAGpBC,GAAG,6BACE1D,IADH,IAEA7C,SAAU,EACVwG,GAAI,IAENC,GAAG,6BACE5D,IADH,IAEA7C,SAAU,EACVwG,GAAI,IAENE,GAAG,6BACE7D,IADH,IAEA7C,SAAU,EACVwG,GAAI,IAENG,GAAG,6BACE9D,IADH,IAEA7C,SAAU,IAEZ4G,GAAG,6BACE/D,IADH,IAEA7C,SAAU,IAEZ6G,GAAG,6BACEhE,IADH,IAEA7C,SAAU,EACVwE,GAAI,IAENsC,KAAM,GACNC,IAAK,GACLC,GAAI,CACFC,GAAI,QACJ5G,OAAQ,EACR6G,OAAQ,MACR3C,EAAG,IAkGLrE,WACAyD,UACAwD,MAjKY,CACZvF,QAAS,CACPwF,QAAS,EACT5G,aAAc,EACde,UAAW,gCAEb8F,QAAS,CACPD,QAAS,EACT5G,aAAc,EACdH,OAAQ,YACRQ,YAAa,UAwJfyG,MAnTY,CACZ9D,MAAO,CACLxD,SAAU,EACVO,WAAY,MAiTdgH,WAlGiB,CACjBC,gBAAiB,CACfC,OAAQ,SACRC,IAAK,MACL,YAAa,YACbC,MAAO,QACP,eAAgB,eAChBC,OAAQ,SACR,cAAe,cACfC,KAAM,OACN,WAAY,YAEdC,UAAU,6BACLzD,IADI,IAEP,QAAS,QACT,OAAQ,OACR,MAAO,MACPoB,KAAM,SAERsC,MAAO,CACL,EAAK,IACL,GAAM,KACN,GAAM,MACN,GAAM,KACN,GAAM,MACN,IAAO,IACP,IAAO,OACP,IAAO,MACP,IAAO,OACP,IAAO,OAETC,OAAQ,CACN,OAAQ,UACR,MAAO,SACP,MAAO,SACP,EAAK,IACL,GAAM,QACN,GAAM,QACN,IAAO,UAETC,KAAM,CACJ,MAAO,SACP,KAAM,QACN,KAAM,QACN,EAAK,IACL,EAAK,OACL,EAAK,OACL,GAAM,UAoDRC,YAhDkB,CAClBC,SAAU,CACRnE,KAAM,OACNoE,IAAK,MACLvC,QAAS,sFACTrE,OAAQ,sDACRR,QAAS,UACT4C,OAAQ,aACRvC,UAAW,aAEbgH,eAAgB,CACdC,OAAQ,SACRC,GAAI,6BACJC,IAAK,6BACL,SAAU,gCAEZC,SAAU,CACR,GAAM,OACN,IAAO,QACP,IAAO,QACP,IAAO,QACP,IAAO,QACP,IAAO,QACP,IAAO,QACP,IAAQ,Y,kEDTAvT,K,wBAAAA,M,cAohBAC,K,kBAAAA,E,gBAAAA,E,mBAAAA,M,cAsCAC,K,iCAAAA,E,sBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,cAAAA,E,iCAAAA,E,kBAAAA,E,sBAAAA,M,cAgKAC,K,UAAAA,E,iBAAAA,M,cAQAC,K,sBAAAA,E,yBAAAA,E,kBAAAA,E,gBAAAA,E,sBAAAA,E,mBAAAA,M,cA4SAC,K,UAAAA,E,gBAAAA,E,mBAAAA,M,cAmDAC,K,4BAAAA,E,0BAAAA,E,yBAAAA,E,8CAAAA,E,sBAAAA,E,gBAAAA,E,YAAAA,E,eAAAA,M,cAoBAC,K,oBAAAA,E,gBAAAA,E,yCAAAA,E,gBAAAA,E,+BAAAA,E,0BAAAA,E,iDAAAA,M,cAiYAC,K,2BAAAA,E,0BAAAA,M,cAmMAC,K,+BAAAA,E,iCAAAA,E,YAAAA,E,iCAAAA,E,gCAAAA,M,cA8mCAC,K,cAAAA,E,YAAAA,E,YAAAA,E,eAAAA,M,cAwjBAC,K,wBAAAA,M,cA8CAC,K,uCAAAA,E,wBAAAA,M,cA6FAC,K,oBAAAA,E,qBAAAA,M,cA+BAC,K,sBAAAA,E,gBAAAA,E,sBAAAA,E,cAAAA,E,kBAAAA,E,oBAAAA,E,yBAAAA,E,kBAAAA,E,gBAAAA,E,mBAAAA,M,cAmEAC,K,cAAAA,E,kBAAAA,E,oBAAAA,E,yBAAAA,E,kBAAAA,E,gBAAAA,E,kBAAAA,E,mBAAAA,M,cAoBAC,K,YAAAA,E,eAAAA,M,cA8WAC,K,uBAAAA,E,wBAAAA,M,cA0BAC,K,yBAAAA,E,wBAAAA,E,mBAAAA,E,2BAAAA,E,gCAAAA,M,cAkOAC,K,wBAAAA,M,cAMAC,K,iCAAAA,E,eAAAA,M,cAoDAC,K,cAAAA,E,YAAAA,E,qBAAAA,E,YAAAA,E,eAAAA,M,cAcAC,K,oBAAAA,E,kBAAAA,E,sBAAAA,M,cAUAC,K,kBAAAA,E,sBAAAA,M,cA0EAC,K,uBAAAA,E,eAAAA,M,cAQAC,K,UAAAA,E,oBAAAA,E,qBAAAA,E,kBAAAA,E,iBAAAA,M,cAcAC,K,oBAAAA,E,mBAAAA,M,cAykBAC,K,uBAAAA,E,6BAAAA,E,sBAAAA,M,cAyGAC,K,eAAAA,M,cAcAC,K,cAAAA,E,qCAAAA,M,cAqDAC,K,wBAAAA,M,cAMAC,K,kBAAAA,E,kBAAAA,E,mBAAAA,M,cAwEAC,K,gBAAAA,E,eAAAA,M,cAQAC,K,cAAAA,E,iBAAAA,M,cA2PAC,K,sBAAAA,E,oBAAAA,E,iBAAAA,M,cA0DAC,K,mCAAAA,E,gBAAAA,E,gBAAAA,E,sBAAAA,E,aAAAA,E,sBAAAA,E,iCAAAA,E,kBAAAA,E,kBAAAA,E,qBAAAA,M,cAgPAC,K,uBAAAA,E,qBAAAA,E,wBAAAA,M,cAUAC,K,UAAAA,E,gBAAAA,E,iBAAAA,M,cAqGAC,K,mBAAAA,E,qBAAAA,E,yBAAAA,E,iCAAAA,E,6CAAAA,E,kBAAAA,E,6BAAAA,E,gCAAAA,E,iBAAAA,E,uBAAAA,E,2BAAAA,E,2BAAAA,E,yBAAAA,E,kCAAAA,E,oBAAAA,E,mCAAAA,E,eAAAA,M,cAsHAC,K,wBAAAA,E,oBAAAA,E,6BAAAA,M,cAwDAC,K,oBAAAA,E,mBAAAA,M,cAqDAC,K,kCAAAA,E,wBAAAA,M,cAQAC,K,oBAAAA,E,mBAAAA,M,cAuUAC,K,wBAAAA,M,cAiFAC,K,oBAAAA,E,uBAAAA,E,wBAAAA,M,cAUAC,K,gBAAAA,E,aAAAA,M,cAyHAC,K,6CAAAA,E,+BAAAA,E,2BAAAA,E,4CAAAA,E,iCAAAA,E,0DAAAA,E,8CAAAA,E,uCAAAA,E,uCAAAA,E,6BAAAA,E,6BAAAA,E,2BAAAA,E,mDAAAA,E,iCAAAA,E,mCAAAA,E,4DAAAA,E,2BAAAA,E,mCAAAA,E,qDAAAA,E,wCAAAA,E,+BAAAA,E,mCAAAA,E,qCAAAA,E,mCAAAA,E,iCAAAA,E,+BAAAA,E,uDAAAA,E,+BAAAA,E,uCAAAA,E,uCAAAA,M,cAkKAC,K,uBAAAA,E,aAAAA,M,cA2EAC,K,aAAAA,M,cAyFAC,K,qBAAAA,E,oBAAAA,E,YAAAA,E,wBAAAA,M,cAohBAC,K,gBAAAA,E,kBAAAA,E,cAAAA,E,cAAAA,E,cAAAA,E,qBAAAA,E,kBAAAA,E,qBAAAA,M,cAoBAC,K,0BAAAA,E,sBAAAA,E,mBAAAA,Q,cA+HAC,K,uBAAAA,E,mBAAAA,E,gBAAAA,E,wBAAAA,Q,cAYAC,K,gBAAAA,E,aAAAA,Q,cAi1CAC,K,oBAAAA,E,mBAAAA,Q,cA8BAC,K,WAAAA,Q,cAwEAC,K,gBAAAA,E,mCAAAA,E,uBAAAA,Q,cAUAC,K,gBAAAA,E,gCAAAA,E,gBAAAA,E,gBAAAA,E,gBAAAA,E,kBAAAA,E,qBAAAA,Q,cAkBAC,K,UAAAA,E,aAAAA,Q,cA8FAC,K,cAAAA,E,aAAAA,Q,cAsLAC,K,oBAAAA,E,6BAAAA,E,YAAAA,E,gCAAAA,E,uBAAAA,Q,cA4iBAC,K,6DAAAA,E,6FAAAA,E,2EAAAA,Q,cAuDAC,K,cAAAA,E,iCAAAA,E,6BAAAA,E,2CAAAA,E,6BAAAA,Q,cA0BAC,K,6DAAAA,E,6FAAAA,E,uDAAAA,E,0EAAAA,E,2CAAAA,Q,cA2DAC,K,iCAAAA,E,2CAAAA,E,6BAAAA,Q,cAiBAC,K,6DAAAA,E,2EAAAA,Q,cAuMAC,K,cAAAA,E,YAAAA,E,YAAAA,E,eAAAA,Q,cAyDAC,K,cAAAA,E,aAAAA,Q,cAqDAC,K,UAAAA,E,oBAAAA,E,YAAAA,E,kBAAAA,E,mCAAAA,E,gBAAAA,E,iCAAAA,E,gCAAAA,Q,cAqpBAC,K,cAAAA,E,iCAAAA,E,6BAAAA,E,uBAAAA,Q,cAYAC,K,cAAAA,E,aAAAA,Q,cAgCAC,K,cAAAA,E,iBAAAA,Q,cAQAC,K,UAAAA,E,oBAAAA,E,oBAAAA,E,mBAAAA,Q,cAoBAC,K,uBAAAA,E,eAAAA,Q,cA0JAC,K,wBAAAA,Q,cAcAC,K,wBAAAA,Q,cAwCAC,K,gBAAAA,E,gBAAAA,E,cAAAA,E,UAAAA,E,cAAAA,E,YAAAA,E,qBAAAA,Q,cA8EAC,K,wBAAAA,Q,cA4EAC,K,YAAAA,E,cAAAA,E,4BAAAA,E,kBAAAA,E,2BAAAA,E,wBAAAA,E,YAAAA,E,aAAAA,Q,cAgEAC,K,qBAAAA,E,yBAAAA,E,qBAAAA,E,2BAAAA,E,wBAAAA,Q,cAcAC,K,uBAAAA,E,UAAAA,E,mBAAAA,E,uBAAAA,E,YAAAA,E,WAAAA,Q,cA2VAC,K,oBAAAA,E,4BAAAA,Q,cAuCAC,K,2BAAAA,E,qBAAAA,E,qBAAAA,Q,cAwEAC,K,YAAAA,E,yBAAAA,E,aAAAA,Q,cAqQAC,K,uBAAAA,E,YAAAA,E,wBAAAA,Q,cA2DAC,K,gBAAAA,E,aAAAA,Q,cAQAC,K,wCAAAA,E,kDAAAA,E,2BAAAA,E,wBAAAA,Q,cAyiBAC,K,cAAAA,E,gBAAAA,E,iBAAAA,Q,cAkBAC,K,uBAAAA,E,wBAAAA,Q,cAmPAC,K,kBAAAA,E,uBAAAA,Q,cAqCAC,K,oBAAAA,E,qCAAAA,E,kCAAAA,Q,cAkBAC,K,kBAAAA,E,kBAAAA,E,kBAAAA,E,kCAAAA,Q,cAYAC,K,oBAAAA,E,qCAAAA,E,sBAAAA,E,sBAAAA,E,mBAAAA,Q,cA4FAC,K,gBAAAA,E,gBAAAA,E,aAAAA,Q,cAgKAC,K,6CAAAA,E,+BAAAA,E,oEAAAA,E,0EAAAA,E,mDAAAA,E,iDAAAA,E,mDAAAA,E,mDAAAA,E,6CAAAA,E,6CAAAA,E,sDAAAA,E,2BAAAA,E,4CAAAA,E,iCAAAA,E,0DAAAA,E,6CAAAA,E,8CAAAA,E,uCAAAA,E,+BAAAA,E,yEAAAA,E,uCAAAA,E,6CAAAA,E,sDAAAA,E,+CAAAA,E,6BAAAA,E,6BAAAA,E,2BAAAA,E,mDAAAA,E,iCAAAA,E,2BAAAA,E,mCAAAA,E,4DAAAA,E,2BAAAA,E,wCAAAA,E,oEAAAA,E,wCAAAA,E,qDAAAA,E,yDAAAA,E,6CAAAA,E,mCAAAA,E,qDAAAA,E,wCAAAA,E,+BAAAA,E,8CAAAA,E,8CAAAA,E,yDAAAA,E,mCAAAA,E,qCAAAA,E,mCAAAA,E,iCAAAA,E,+BAAAA,E,uDAAAA,E,+BAAAA,E,uCAAAA,E,uCAAAA,Q,cAkHAC,K,gBAAAA,E,aAAAA,Q,cA4WAC,K,oBAAAA,E,YAAAA,E,cAAAA,E,gBAAAA,E,cAAAA,E,gBAAAA,E,yBAAAA,E,sBAAAA,Q,cAuEAC,K,wBAAAA,Q,cA2GAC,K,4BAAAA,E,iCAAAA,Q,cAsRAC,K,uBAAAA,E,aAAAA,Q,cAkUAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cA8DAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cAqHAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cAgEAC,K,cAAAA,E,gBAAAA,E,iBAAAA,Q,cAsjBAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cA8DAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cA8DAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cAiEAC,K,cAAAA,E,sBAAAA,E,qBAAAA,E,oBAAAA,E,oBAAAA,E,aAAAA,Q,cA+jBAC,K,4BAAAA,E,yCAAAA,E,eAAAA,Q,cAwEAC,K,gBAAAA,E,cAAAA,E,2BAAAA,E,wCAAAA,E,yBAAAA,Q,cAoIAC,K,uCAAAA,E,qCAAAA,E,+BAAAA,E,oBAAAA,Q,cAYAC,K,iBAAAA,E,qBAAAA,E,mBAAAA,E,uBAAAA,E,wBAAAA,Q,cAcAC,K,4BAAAA,E,wBAAAA,E,aAAAA,Q,cAuDAC,K,uBAAAA,E,8BAAAA,Q,cAQAC,K,kBAAAA,E,sBAAAA,E,gBAAAA,E,iBAAAA,Q,cA0BAC,K,uBAAAA,E,YAAAA,E,qBAAAA,E,wBAAAA,E,wBAAAA,Q,cAuDAC,K,cAAAA,E,oBAAAA,E,YAAAA,E,gBAAAA,E,eAAAA,Q,cAiBAC,K,kBAAAA,E,iBAAAA,Q,cAwCAC,K,oBAAAA,E,kBAAAA,E,iBAAAA,Q,cAkLAC,K,sBAAAA,E,yBAAAA,E,kBAAAA,E,gBAAAA,E,mBAAAA,Q,cAqNAC,K,YAAAA,E,gBAAAA,E,gBAAAA,E,iBAAAA,Q,cAYAC,K,mBAAAA,E,uBAAAA,E,uBAAAA,E,wBAAAA,Q,cAuDAC,K,wBAAAA,Q,cAiDAC,K,wBAAAA,E,cAAAA,E,wBAAAA,E,aAAAA,Q,cAiFAC,K,oBAAAA,E,QAAAA,E,cAAAA,E,UAAAA,E,cAAAA,E,UAAAA,E,oBAAAA,E,aAAAA,Q,cA4CAC,K,UAAAA,E,aAAAA,Q,cAgBAC,K,2BAAAA,E,wBAAAA,Q,cA4BAC,K,oBAAAA,E,YAAAA,E,UAAAA,E,qBAAAA,Q,cAgEAC,K,wBAAAA,Q,cAgJAC,K,cAAAA,E,uBAAAA,Q,cA+IAC,K,eAAAA,Q,cAuBAC,K,6CAAAA,E,iCAAAA,E,+BAAAA,E,gBAAAA,E,8CAAAA,E,0BAAAA,Q,cA4CAC,K,uBAAAA,Q,cAMAC,K,UAAAA,E,UAAAA,E,cAAAA,E,aAAAA,Q,cA6BAC,K,sDAAAA,E,2CAAAA,Q,cA4HAC,K,uBAAAA,E,8CAAAA,Q,cAqHAC,K,wBAAAA,Q,cAcAC,K,wBAAAA,Q,cAMAC,K,kBAAAA,E,iBAAAA,Q,cAgBAC,K,wBAAAA,Q,cA+KAC,K,cAAAA,E,oBAAAA,E,kBAAAA,E,kBAAAA,E,mBAAAA,Q,cA0FAC,K,kBAAAA,E,wBAAAA,E,6BAAAA,Q,cAynBAC,K,iBAAAA,Q,cAkCAC,K,wBAAAA,Q,cA+CAC,K,uBAAAA,E,eAAAA,Q,cAQAC,K,wBAAAA,E,iBAAAA,Q,cAQAC,K,UAAAA,E,uBAAAA,E,uBAAAA,Q,cAkBAC,K,aAAAA,Q,cAMAC,K,gBAAAA,E,mBAAAA,Q,cAsJAC,K,uBAAAA,E,YAAAA,E,wBAAAA,E,qBAAAA,E,wBAAAA,E,wBAAAA,Q,cAgBAC,K,2BAAAA,E,0BAAAA,Q,cAQAC,K,cAAAA,E,iBAAAA,Q,cAqFAC,K,2BAAAA,E,yCAAAA,E,yBAAAA,E,4BAAAA,Q,cAo5DAC,K,iBAAAA,E,qBAAAA,E,mBAAAA,E,sBAAAA,E,wBAAAA,Q,cAmJAC,K,wBAAAA,Q,cAmEAC,K,uBAAAA,E,iBAAAA,Q,KAqIL,IA2BM6J,GAAmB,SAC9BC,EACAC,GAF8B,OAI9BC,oBACE,CAAC,WAAYF,GAt+rBjB,SAAoCG,EAAeH,GACjD,+BAAO,iCAAAtC,EAAA,sEACa0C,MAAM,iCAAD,aAAC,cACtBC,OAAQ,QACL,CACDC,QAAS,CACPC,cAAc,UAAD,OAAYC,iJAAYC,yBAJpB,IAOrBxG,KAAMyG,KAAKC,UAAU,CAAER,QAAOH,iBAR3B,cACCY,EADD,gBAWcA,EAAIC,OAXlB,YAWCA,EAXD,QAaIC,OAbJ,sBAcKC,EAAYF,EAAKC,OAAO,GAAxBC,QAEF,IAAIC,MAAMD,GAhBb,gCAmBEF,EAAKI,MAnBP,4CAs+rBLC,CAjCyB,8eAiCwClB,GACjEC,I,SEh+rBEkB,GACJ,SAAAC,GAAa,OACb,SACEC,GAGI,IADJC,EACG,uDADYD,EAAWE,MAE1B,EAAwBC,oBAASF,GAAjC,oBAAOG,EAAP,KAAYC,EAAZ,KAKA,OAJAN,GAAc,WACZ,IAAMO,EAAeN,EAAWO,UAAUF,GAC1C,OAAOC,EAAaE,YAAYC,KAAKH,KACpC,CAACN,IACGI,IAGEM,GAAgBZ,GAAoBa,c,IACdb,GAAoBc,oB,OCZ1CC,GAAQ,IAAIC,UAAsCC,GAClDC,GAASH,GAAMI,KAAKR,KAAKI,IACzBK,GAAQ,IAAIJ,KAAqC,UACjDK,GAASD,GAAMD,KAAKR,KAAKS,IAGzBE,GAAS,IAAIN,KAAgB,IAC7BO,GAAUD,GAAOH,KAAKR,KAAKW,IAC3BE,GAAQ,IAAIR,KAAqC,WACjDS,GAASH,GAAOH,KAAKR,KAAKa,I,QCrBjCE,GAAgB,SAACC,GAAD,OAA0CJ,GAAQI,EAAMC,OAAOxB,QAE/EyB,GAAgB,SAACF,GAAD,OAA0CF,GAAOE,EAAMG,cAAc1B,QAE9E2B,GAAc,WACzB,IAAMC,EAAQpB,GAAcU,IACtBW,EAAOrB,GAAcY,IAErBU,EAAWC,kBAAgC,MAOjD,OAJAtB,sBAAU,WAAO,IAAD,EACN,OAARqB,QAAQ,IAARA,GAAA,UAAAA,EAAUE,eAAV,SAAmBC,UAClB,IAGD,aAAC,KAAD,CAAMC,GAAI,CAAEC,cAAe,SAAU7H,GAAI,GAAzC,UAEE,aAAC,KAAD,CAAO8H,QAAQ,SAASF,GAAI,CAAEpM,SAAU,EAAGO,WAAY,QAAvD,oBAGA,aAAC,KAAD,CACEgM,GAAG,SACHC,KAAK,SACLC,QAAQ,SACRvC,MAAO4B,EACPY,SAAUlB,GACVmB,IAAKX,EACLxH,GAAI,IAGN,aAAC,KAAD,CAAM4H,GAAI,CAAEtM,GAAI,EAAGuM,cAAe,MAAOO,eAAgB,OAAzD,UACE,aAAC,KAAD,CAAMC,GAAI,EAAV,sBACA,aAAC,KAAD,WACE,aAAC,KAAD,CAAOP,QAAQ,eAAeF,GAAI,CAAEpM,SAAU,EAAGO,WAAY,OAAQuM,GAAI,GAAzE,UACE,aAAC,KAAD,CACEP,GAAG,eACHC,KAAK,UACLtC,MAAM,UACNkC,GAAI,CAAE9L,MAAO,WACbyM,QAAkB,YAAThB,EACTW,SAAUf,KAPd,aAWA,aAAC,KAAD,CAAOW,QAAQ,aAAaF,GAAI,CAAEpM,SAAU,EAAGO,WAAY,OAAQuM,GAAI,GAAvE,UACE,aAAC,KAAD,CACEP,GAAG,aACHC,KAAK,QACLtC,MAAM,QACNkC,GAAI,CAAE9L,MAAO,WACbyM,QAAkB,UAAThB,EACTW,SAAUf,KAPd,qBCrCGqB,GAAe,SAAC,GAAD,QAAGR,YAAH,MAAU,GAAV,MAAcS,iBAAd,MAA0B,GAA1B,EAA8BC,EAA9B,EAA8BA,UAAWC,EAAzC,EAAyCA,QAAzC,OAC1B,aAAC,KAAD,CAEEf,GAAI,CACF5H,GAAI,EACJ4I,EAAG,EACHC,QAAS,OACThB,cAAe,MACf7L,aAAc,EACde,UAAW,+BACX,SAAU,CAAExB,OAAQ,YAEtBoN,QAASA,EAXX,UAaE,aAAC,KAAD,CAAMf,GAAI,CAAEkB,KAAM,MAAOjB,cAAe,UAAxC,UACE,aAAC,KAAD,CAAMD,GAAI,CAAE7L,WAAY,QAAxB,SAAmCiM,IACnC,aAAC,KAAD,UAAOS,OAET,aAAC,KAAD,CAAMb,GAAI,CAAEkB,KAAM,MAAOV,eAAgB,OAAzC,oBAA0DM,OAjB5D,UACUV,EADV,YACkBS,KCPPM,GAAiB,SAACxB,EAA2BD,GAA5B,MACnB,UAATC,EAAA,qBAAiCD,GAAUA,GAEhC0B,GAAiB,SAACC,EAA2BC,GACxD1C,GAAO0C,GACPvC,GAAOsC,IAGIE,GAAS,WAAO,IAAD,EACpB7B,EAAQpB,GAAcU,IACtBW,EAAOrB,GAAcY,IACrBsC,EClBmB,SAAI1D,EAAU2D,GACvC,MAA4C1D,oBAAYD,GAAxD,oBAAO4D,EAAP,KAAuBC,EAAvB,KAYA,OAVApD,sBAAU,WACR,IAAMqD,EAAUC,YAAW,WACzBF,EAAkB7D,KACjB2D,GAEH,OAAO,WACLK,aAAaF,MAEd,CAAC9D,EAAO2D,IAEJC,EDKgBK,CAAYrC,EAAO,KAC1C,EAA4BpD,GAAiB,CAC3C0F,YAAab,GAAexB,EAAM6B,KAD5BhE,EAAR,EAAQA,KAAMyE,EAAd,EAAcA,UAId,OACE,6BACE,aAAC,GAAD,IACA,aAAC,KAAD,IACCA,EACC,aAAC,KAAD,CAAMjC,GAAI,CAAEQ,eAAgB,SAAU0B,aAAc,UAApD,UACE,aAAC,KAAD,IACA,aAAC,KAAD,IACA,aAAC,KAAD,OAGF,aAAC,KAAD,CAAMlC,GAAI,CAAEC,cAAe,UAA3B,UACE,aAAC,KAAD,CAAMkC,GAAI,EAAV,4BACkB,IAChB,aAAC,KAAD,CAAMnC,GAAI,CAAE7L,WAAY,WAAYiO,UAAW,UAA/C,gBACG5E,QADH,IACGA,OADH,EACGA,EAAM6E,OAAOC,qBAGjB9E,GACCA,EAAK6E,SADN,UAEC7E,EAAK6E,OAAOE,aAFb,aAEC,EAAmBC,KACjB,SAAAC,GAAM,iBAEHC,aAAO,OAACD,QAAD,IAACA,OAAD,EAACA,EAAQE,QAEbC,aAAK,OAACH,QAAD,IAACA,OAAD,EAACA,EAAQE,OAAS,aAAC,GAAD,CAAc5B,QAAS,kBAAMK,GAAe,SAAD,OAAWqB,QAAX,IAAWA,OAAX,EAAWA,EAAQE,OAA+DvC,KAAMqC,EAAOE,KAAKvC,KAAMS,WAAW,UAAA4B,EAAOE,KAAKE,aAAZ,eAAmBC,QAAS,GAAIhC,UAAS,UAAE2B,EAAOE,KAAKI,kBAAd,aAAE,EAAwBC,YAAnO,UAA6EP,EAAOE,KAAKvC,KAAzF,sBAAiGqC,EAAOE,KAAKE,aAA7G,aAAiG,EAAmBC,mBE9ClJG,GAAe,kBAC1B,aAAC,KAAD,CAAWjD,GAAI,CAAEgB,EAAG,GAApB,SACE,aAAC,KAAD,WACE,aAAC,KAAD,CACEkC,MAAO,GACPpI,OAAQ,GACRqI,IAAI,cACJpC,QAAS,kBAAMK,GAAe,WAC9BpB,GAAI,CAAE,SAAU,CAAErM,OAAQ,cAE5B,aAAC,KAAD,CACEqM,GAAI,CACFoD,KAAM,UACNjP,WAAY,UACZP,SAAU,EACVyP,GAAI,EACJ,SAAU,CAAE1P,OAAQ,YAEtBoN,QAAS,kBAAMK,GAAe,WARhC,8B,QCNOkC,GAAS,SAAC,GAAD,IAAGC,EAAH,EAAGA,SAAH,OACpB,gBAAC,KAAD,CAAWvD,GAAI,CAAElF,OAAQ,gBAAzB,UACE,eAAC,GAAD,IACA,eAAC,KAAD,CAAWkF,GAAI,CAAEtM,GAAI,GAArB,SAA2B6P,QCDzBC,GAAc,SAAC,GAAD,IAAGD,EAAH,EAAGA,SAAUE,EAAb,EAAaA,MAAb,OAClB,aAAC,KAAD,WACE,aAAC,KAAD,CAAMzD,GAAI,CAAE7L,WAAY,QAASuP,GAAI,GAArC,SAA2CD,IAC3C,aAAC,KAAD,CAAMzD,GAAI,CAAE7L,WAAY,WAAYiO,UAAW,UAA/C,SAA4DmB,QAInDI,GAAS,WAAO,IAAD,EACpBrC,EAAOhD,GAAcG,IAC3B,OACE,aAAC,KAAD,UACE,aAAC,KAAD,CAAMuB,GAAI,CAAEC,cAAe,MAAOO,eAAgB,UAAlD,SACE,aAAC,KAAD,CAAMR,GAAI,CAAEC,cAAe,SAAUO,eAAgB,SAAU0C,MAAO,CAAC,OAAQ,QAA/E,UACE,aAAC,KAAD,CAAMlD,GAAI,CAAEC,cAAe,MAAOO,eAAgB,UAAlD,SACE,aAAC,KAAD,CAAMR,GAAI,CAAEpM,SAAU,GAAtB,4BAEF,aAAC,KAAD,IACA,aAAC,KAAD,CACEoM,GAAI,CACFC,cAAe,MACfO,eAAgB,gBAChBpI,GAAI,GAJR,UAOE,aAAC,KAAD,CAAM4H,GAAI,CAAEpM,SAAU,EAAGM,MAAO,QAAU0P,KAAI,OAAEtC,QAAF,IAAEA,OAAF,EAAEA,EAAMuC,IAAtD,gBACGvC,QADH,IACGA,OADH,EACGA,EAAMlB,OAET,kBAAGwD,KAAI,OAAEtC,QAAF,IAAEA,OAAF,EAAEA,EAAMuB,MAAMgB,IAArB,SACE,aAAC,KAAD,CAAQV,IAAG,OAAE7B,QAAF,IAAEA,OAAF,EAAEA,EAAMuB,MAAMiB,iBAG7B,aAAC,KAAD,CAAM9D,GAAI,CAAEC,cAAe,SAAUO,eAAgB,SAAUpI,GAAI,GAAnE,UACE,aAAC,GAAD,CAAaqL,MAAM,UAAnB,SACG,aAAC,KAAD,CAAMG,KAAI,OAAEtC,QAAF,IAAEA,OAAF,EAAEA,EAAMuB,MAAMgB,IAAxB,iCAEH,aAAC,GAAD,CAAaJ,MAAM,oBAAnB,gBAAwCnC,QAAxC,IAAwCA,GAAxC,UAAwCA,EAAMyC,uBAA9C,aAAwC,EAAuB3D,OAC/D,aAAC,GAAD,CAAaqD,MAAM,UAAnB,gBAA8BnC,QAA9B,IAA8BA,OAA9B,EAA8BA,EAAMyB,WAAWC,gBAEjD,aAAC,KAAD,UACE,aAAC,KAAD,iBAAY1B,QAAZ,IAAYA,OAAZ,EAAYA,EAAM0C,wBCtCxBC,GAAc,IAAIC,eAAY,CAClCC,WAAY,IAAIC,cAAW,CACzBC,QAAS,SAACC,EAAO5H,QACUiC,IAArBjC,EAAM6H,MAAM/G,MACdgH,KAAMF,MAAN,sCAA2CA,SAMtCG,GAAM,WACjB,IAAMpD,EAAO/C,GAAcQ,IAC3B,OACE,gBAAC,uBAAD,CAAqB4F,OAAQT,GAA7B,UACE,eAAC,KAAD,CAAe5L,MAAOA,GAAtB,SACE,eAAC,GAAD,UAAkB,WAATgJ,EAAoB,eAAC,GAAD,IAAa,eAAC,GAAD,QAE5C,eAAC,sBAAD,CAAoBsD,eAAa,QCdxBC,GAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCCdQ,KAASC,OACP,eAAC,cAAD,UACE,eAAC,GAAD,MAEFC,SAASC,eAAe,SAM1BZ,O","file":"static/js/main.ee86e6db.chunk.js","sourcesContent":["import { useQuery, UseQueryOptions } from 'react-query'\nexport type Maybe<T> = T | null\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }\n\nfunction fetcher<TData, TVariables>(query: string, variables?: TVariables) {\n  return async (): Promise<TData> => {\n    const res = await fetch('https://api.github.com/graphql', {\n      method: 'POST',\n      ...{\n        headers: {\n          Authorization: `Bearer ${process.env.REACT_APP_GITHUB_KEY}`,\n        },\n      },\n      body: JSON.stringify({ query, variables }),\n    })\n\n    const json = await res.json()\n\n    if (json.errors) {\n      const { message } = json.errors[0]\n\n      throw new Error(message)\n    }\n\n    return json.data\n  }\n}\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string\n  String: string\n  Boolean: boolean\n  Int: number\n  Float: number\n  /** A (potentially binary) string encoded using base64. */\n  Base64String: any\n  /** An ISO-8601 encoded date string. */\n  Date: any\n  /** An ISO-8601 encoded UTC date string. */\n  DateTime: any\n  /** A Git object ID. */\n  GitObjectID: any\n  /** A fully qualified reference name (e.g. `refs/heads/master`). */\n  GitRefname: any\n  /** Git SSH string */\n  GitSSHRemote: any\n  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */\n  GitTimestamp: any\n  /** A string containing HTML code. */\n  HTML: any\n  /** An ISO-8601 encoded UTC date string with millisecond precision. */\n  PreciseDateTime: any\n  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */\n  URI: any\n  /** A valid x509 certificate string */\n  X509Certificate: any\n}\n\n/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */\nexport type AcceptEnterpriseAdministratorInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The id of the invitation being accepted */\n  invitationId: Scalars['ID']\n}\n\n/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */\nexport type AcceptEnterpriseAdministratorInvitationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The invitation that was accepted. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>\n  /** A message confirming the result of accepting an administrator invitation. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of AcceptTopicSuggestion */\nexport type AcceptTopicSuggestionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The name of the suggested topic. */\n  name: Scalars['String']\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of AcceptTopicSuggestion */\nexport type AcceptTopicSuggestionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The accepted topic. */\n  topic?: Maybe<Topic>\n}\n\n/** Represents an object which can take actions on GitHub. Typically a User or Bot. */\nexport type Actor = {\n  /** A URL pointing to the actor's public avatar. */\n  avatarUrl: Scalars['URI']\n  /** The username of the actor. */\n  login: Scalars['String']\n  /** The HTTP path for this actor. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for this actor. */\n  url: Scalars['URI']\n}\n\n/** Represents an object which can take actions on GitHub. Typically a User or Bot. */\nexport type ActorAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** Location information for an actor */\nexport type ActorLocation = {\n  /** City */\n  city?: Maybe<Scalars['String']>\n  /** Country name */\n  country?: Maybe<Scalars['String']>\n  /** Country code */\n  countryCode?: Maybe<Scalars['String']>\n  /** Region name */\n  region?: Maybe<Scalars['String']>\n  /** Region or state code */\n  regionCode?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of AddAssigneesToAssignable */\nexport type AddAssigneesToAssignableInput = {\n  /** The id of the assignable object to add assignees to. */\n  assignableId: Scalars['ID']\n  /** The id of users to add as assignees. */\n  assigneeIds: Array<Scalars['ID']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of AddAssigneesToAssignable */\nexport type AddAssigneesToAssignablePayload = {\n  /** The item that was assigned. */\n  assignable?: Maybe<Assignable>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of AddComment */\nexport type AddCommentInput = {\n  /** The contents of the comment. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID']\n}\n\n/** Autogenerated return type of AddComment */\nexport type AddCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The edge from the subject's comment connection. */\n  commentEdge?: Maybe<IssueCommentEdge>\n  /** The subject */\n  subject?: Maybe<Node>\n  /** The edge from the subject's timeline connection. */\n  timelineEdge?: Maybe<IssueTimelineItemEdge>\n}\n\n/** Autogenerated input type of AddDiscussionComment */\nexport type AddDiscussionCommentInput = {\n  /** The contents of the comment. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the discussion to comment on. */\n  discussionId: Scalars['ID']\n  /** The Node ID of the discussion comment within this discussion to reply to. */\n  replyToId?: Maybe<Scalars['ID']>\n}\n\n/** Autogenerated return type of AddDiscussionComment */\nexport type AddDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The newly created discussion comment. */\n  comment?: Maybe<DiscussionComment>\n}\n\n/** Autogenerated input type of AddEnterpriseSupportEntitlement */\nexport type AddEnterpriseSupportEntitlementInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID']\n  /** The login of a member who will receive the support entitlement. */\n  login: Scalars['String']\n}\n\n/** Autogenerated return type of AddEnterpriseSupportEntitlement */\nexport type AddEnterpriseSupportEntitlementPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A message confirming the result of adding the support entitlement. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of AddLabelsToLabelable */\nexport type AddLabelsToLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ids of the labels to add. */\n  labelIds: Array<Scalars['ID']>\n  /** The id of the labelable object to add labels to. */\n  labelableId: Scalars['ID']\n}\n\n/** Autogenerated return type of AddLabelsToLabelable */\nexport type AddLabelsToLabelablePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The item that was labeled. */\n  labelable?: Maybe<Labelable>\n}\n\n/** Autogenerated input type of AddProjectCard */\nexport type AddProjectCardInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The content of the card. Must be a member of the ProjectCardItem union */\n  contentId?: Maybe<Scalars['ID']>\n  /** The note on the card. */\n  note?: Maybe<Scalars['String']>\n  /** The Node ID of the ProjectColumn. */\n  projectColumnId: Scalars['ID']\n}\n\n/** Autogenerated return type of AddProjectCard */\nexport type AddProjectCardPayload = {\n  /** The edge from the ProjectColumn's card connection. */\n  cardEdge?: Maybe<ProjectCardEdge>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ProjectColumn */\n  projectColumn?: Maybe<ProjectColumn>\n}\n\n/** Autogenerated input type of AddProjectColumn */\nexport type AddProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The name of the column. */\n  name: Scalars['String']\n  /** The Node ID of the project. */\n  projectId: Scalars['ID']\n}\n\n/** Autogenerated return type of AddProjectColumn */\nexport type AddProjectColumnPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The edge from the project's column connection. */\n  columnEdge?: Maybe<ProjectColumnEdge>\n  /** The project */\n  project?: Maybe<Project>\n}\n\n/** Autogenerated input type of AddProjectNextItem */\nexport type AddProjectNextItemInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The content id of the item (Issue or PullRequest). */\n  contentId: Scalars['ID']\n  /** The ID of the Project to add the item to. */\n  projectId: Scalars['ID']\n}\n\n/** Autogenerated return type of AddProjectNextItem */\nexport type AddProjectNextItemPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The item added to the project. */\n  projectNextItem?: Maybe<ProjectNextItem>\n}\n\n/** Autogenerated input type of AddPullRequestReviewComment */\nexport type AddPullRequestReviewCommentInput = {\n  /** The text of the comment. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The SHA of the commit to comment on. */\n  commitOID?: Maybe<Scalars['GitObjectID']>\n  /** The comment id to reply to. */\n  inReplyTo?: Maybe<Scalars['ID']>\n  /** The relative path of the file to comment on. */\n  path?: Maybe<Scalars['String']>\n  /** The line index in the diff to comment on. */\n  position?: Maybe<Scalars['Int']>\n  /** The node ID of the pull request reviewing */\n  pullRequestId?: Maybe<Scalars['ID']>\n  /** The Node ID of the review to modify. */\n  pullRequestReviewId?: Maybe<Scalars['ID']>\n}\n\n/** Autogenerated return type of AddPullRequestReviewComment */\nexport type AddPullRequestReviewCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The newly created comment. */\n  comment?: Maybe<PullRequestReviewComment>\n  /** The edge from the review's comment connection. */\n  commentEdge?: Maybe<PullRequestReviewCommentEdge>\n}\n\n/** Autogenerated input type of AddPullRequestReview */\nexport type AddPullRequestReviewInput = {\n  /** The contents of the review body comment. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The review line comments. */\n  comments?: Maybe<Array<Maybe<DraftPullRequestReviewComment>>>\n  /** The commit OID the review pertains to. */\n  commitOID?: Maybe<Scalars['GitObjectID']>\n  /** The event to perform on the pull request review. */\n  event?: Maybe<PullRequestReviewEvent>\n  /** The Node ID of the pull request to modify. */\n  pullRequestId: Scalars['ID']\n  /** The review line comment threads. */\n  threads?: Maybe<Array<Maybe<DraftPullRequestReviewThread>>>\n}\n\n/** Autogenerated return type of AddPullRequestReview */\nexport type AddPullRequestReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The newly created pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>\n  /** The edge from the pull request's review connection. */\n  reviewEdge?: Maybe<PullRequestReviewEdge>\n}\n\n/** Autogenerated input type of AddPullRequestReviewThread */\nexport type AddPullRequestReviewThreadInput = {\n  /** Body of the thread's first comment. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */\n  line: Scalars['Int']\n  /** Path to the file being commented on. */\n  path: Scalars['String']\n  /** The node ID of the pull request reviewing */\n  pullRequestId?: Maybe<Scalars['ID']>\n  /** The Node ID of the review to modify. */\n  pullRequestReviewId?: Maybe<Scalars['ID']>\n  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */\n  side?: Maybe<DiffSide>\n  /** The first line of the range to which the comment refers. */\n  startLine?: Maybe<Scalars['Int']>\n  /** The side of the diff on which the start line resides. */\n  startSide?: Maybe<DiffSide>\n}\n\n/** Autogenerated return type of AddPullRequestReviewThread */\nexport type AddPullRequestReviewThreadPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The newly created thread. */\n  thread?: Maybe<PullRequestReviewThread>\n}\n\n/** Autogenerated input type of AddReaction */\nexport type AddReactionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The name of the emoji to react with. */\n  content: ReactionContent\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID']\n}\n\n/** Autogenerated return type of AddReaction */\nexport type AddReactionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The reaction object. */\n  reaction?: Maybe<Reaction>\n  /** The reactable subject. */\n  subject?: Maybe<Reactable>\n}\n\n/** Autogenerated input type of AddStar */\nexport type AddStarInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Starrable ID to star. */\n  starrableId: Scalars['ID']\n}\n\n/** Autogenerated return type of AddStar */\nexport type AddStarPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The starrable. */\n  starrable?: Maybe<Starrable>\n}\n\n/** Autogenerated input type of AddUpvote */\nexport type AddUpvoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the discussion or comment to upvote. */\n  subjectId: Scalars['ID']\n}\n\n/** Autogenerated return type of AddUpvote */\nexport type AddUpvotePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The votable subject. */\n  subject?: Maybe<Votable>\n}\n\n/** Autogenerated input type of AddVerifiableDomain */\nexport type AddVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The URL of the domain */\n  domain: Scalars['URI']\n  /** The ID of the owner to add the domain to */\n  ownerId: Scalars['ID']\n}\n\n/** Autogenerated return type of AddVerifiableDomain */\nexport type AddVerifiableDomainPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The verifiable domain that was added. */\n  domain?: Maybe<VerifiableDomain>\n}\n\n/** Represents a 'added_to_project' event on a given issue or pull request. */\nexport type AddedToProjectEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** Project referenced by event. */\n  project?: Maybe<Project>\n  /** Project card referenced by this project event. */\n  projectCard?: Maybe<ProjectCard>\n  /** Column name referenced by this project event. */\n  projectColumnName: Scalars['String']\n}\n\n/** A GitHub App. */\nexport type App = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** The description of the app. */\n  description?: Maybe<Scalars['String']>\n  id: Scalars['ID']\n  /** The IP addresses of the app. */\n  ipAllowListEntries: IpAllowListEntryConnection\n  /** The hex color code, without the leading '#', for the logo background. */\n  logoBackgroundColor: Scalars['String']\n  /** A URL pointing to the app's logo. */\n  logoUrl: Scalars['URI']\n  /** The name of the app. */\n  name: Scalars['String']\n  /** A slug based on the name of the app for use in URLs. */\n  slug: Scalars['String']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The URL to the app's homepage. */\n  url: Scalars['URI']\n}\n\n/** A GitHub App. */\nexport type AppIpAllowListEntriesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IpAllowListEntryOrder>\n}\n\n/** A GitHub App. */\nexport type AppLogoUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** Autogenerated input type of ApproveDeployments */\nexport type ApproveDeploymentsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Optional comment for approving deployments */\n  comment?: Maybe<Scalars['String']>\n  /** The ids of environments to reject deployments */\n  environmentIds: Array<Scalars['ID']>\n  /** The node ID of the workflow run containing the pending deployments. */\n  workflowRunId: Scalars['ID']\n}\n\n/** Autogenerated return type of ApproveDeployments */\nexport type ApproveDeploymentsPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The affected deployments. */\n  deployments?: Maybe<Array<Deployment>>\n}\n\n/** Autogenerated input type of ApproveVerifiableDomain */\nexport type ApproveVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the verifiable domain to approve. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of ApproveVerifiableDomain */\nexport type ApproveVerifiableDomainPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The verifiable domain that was approved. */\n  domain?: Maybe<VerifiableDomain>\n}\n\n/** Autogenerated input type of ArchiveRepository */\nexport type ArchiveRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the repository to mark as archived. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of ArchiveRepository */\nexport type ArchiveRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The repository that was marked as archived. */\n  repository?: Maybe<Repository>\n}\n\n/** An object that can have users assigned to it. */\nexport type Assignable = {\n  /** A list of Users assigned to this object. */\n  assignees: UserConnection\n}\n\n/** An object that can have users assigned to it. */\nexport type AssignableAssigneesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Represents an 'assigned' event on any assignable object. */\nexport type AssignedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the assignable associated with the event. */\n  assignable: Assignable\n  /** Identifies the user or mannequin that was assigned. */\n  assignee?: Maybe<Assignee>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /**\n   * Identifies the user who was assigned.\n   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.\n   */\n  user?: Maybe<User>\n}\n\n/** Types that can be assigned to issues. */\nexport type Assignee = Bot | Mannequin | Organization | User\n\n/** An entry in the audit log. */\nexport type AuditEntry = {\n  /** The action name */\n  action: Scalars['String']\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime']\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>\n  /** The user affected by the action */\n  user?: Maybe<User>\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>\n}\n\n/** Types that can initiate an audit log event. */\nexport type AuditEntryActor = Bot | Organization | User\n\n/** Ordering options for Audit Log connections. */\nexport type AuditLogOrder = {\n  /** The ordering direction. */\n  direction?: Maybe<OrderDirection>\n  /** The field to order Audit Logs by. */\n  field?: Maybe<AuditLogOrderField>\n}\n\n/** Properties by which Audit Log connections can be ordered. */\nexport enum AuditLogOrderField {\n  /** Order audit log entries by timestamp */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** Represents a 'auto_merge_disabled' event on a given pull request. */\nexport type AutoMergeDisabledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The user who disabled auto-merge for this Pull Request */\n  disabler?: Maybe<User>\n  id: Scalars['ID']\n  /** PullRequest referenced by event */\n  pullRequest?: Maybe<PullRequest>\n  /** The reason auto-merge was disabled */\n  reason?: Maybe<Scalars['String']>\n  /** The reason_code relating to why auto-merge was disabled */\n  reasonCode?: Maybe<Scalars['String']>\n}\n\n/** Represents a 'auto_merge_enabled' event on a given pull request. */\nexport type AutoMergeEnabledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The user who enabled auto-merge for this Pull Request */\n  enabler?: Maybe<User>\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Represents an auto-merge request for a pull request */\nexport type AutoMergeRequest = {\n  /** The email address of the author of this auto-merge request. */\n  authorEmail?: Maybe<Scalars['String']>\n  /** The commit message of the auto-merge request. */\n  commitBody?: Maybe<Scalars['String']>\n  /** The commit title of the auto-merge request. */\n  commitHeadline?: Maybe<Scalars['String']>\n  /** When was this auto-merge request was enabled. */\n  enabledAt?: Maybe<Scalars['DateTime']>\n  /** The actor who created the auto-merge request. */\n  enabledBy?: Maybe<Actor>\n  /** The merge method of the auto-merge request. */\n  mergeMethod: PullRequestMergeMethod\n  /** The pull request that this auto-merge request is set against. */\n  pullRequest: PullRequest\n}\n\n/** Represents a 'auto_rebase_enabled' event on a given pull request. */\nexport type AutoRebaseEnabledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The user who enabled auto-merge (rebase) for this Pull Request */\n  enabler?: Maybe<User>\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Represents a 'auto_squash_enabled' event on a given pull request. */\nexport type AutoSquashEnabledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The user who enabled auto-merge (squash) for this Pull Request */\n  enabler?: Maybe<User>\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Represents a 'automatic_base_change_failed' event on a given pull request. */\nexport type AutomaticBaseChangeFailedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** The new base for this PR */\n  newBase: Scalars['String']\n  /** The old base for this PR */\n  oldBase: Scalars['String']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n}\n\n/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */\nexport type AutomaticBaseChangeSucceededEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** The new base for this PR */\n  newBase: Scalars['String']\n  /** The old base for this PR */\n  oldBase: Scalars['String']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n}\n\n/** Represents a 'base_ref_changed' event on a given issue or pull request. */\nexport type BaseRefChangedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the name of the base ref for the pull request after it was changed. */\n  currentRefName: Scalars['String']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** Identifies the name of the base ref for the pull request before it was changed. */\n  previousRefName: Scalars['String']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n}\n\n/** Represents a 'base_ref_deleted' event on a given pull request. */\nexport type BaseRefDeletedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the name of the Ref associated with the `base_ref_deleted` event. */\n  baseRefName?: Maybe<Scalars['String']>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Represents a 'base_ref_force_pushed' event on a given pull request. */\nexport type BaseRefForcePushedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */\n  afterCommit?: Maybe<Commit>\n  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */\n  beforeCommit?: Maybe<Commit>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */\n  ref?: Maybe<Ref>\n}\n\n/** Represents a Git blame. */\nexport type Blame = {\n  /** The list of ranges from a Git blame. */\n  ranges: Array<BlameRange>\n}\n\n/** Represents a range of information from a Git blame. */\nexport type BlameRange = {\n  /**\n   * Identifies the recency of the change, from 1 (new) to 10 (old). This is\n   * calculated as a 2-quantile and determines the length of distance between the\n   * median age of all the changes in the file and the recency of the current\n   * range's change.\n   */\n  age: Scalars['Int']\n  /** Identifies the line author */\n  commit: Commit\n  /** The ending line for the range */\n  endingLine: Scalars['Int']\n  /** The starting line for the range */\n  startingLine: Scalars['Int']\n}\n\n/** Represents a Git blob. */\nexport type Blob = GitObject &\n  Node & {\n    /** An abbreviated version of the Git object ID */\n    abbreviatedOid: Scalars['String']\n    /** Byte size of Blob object */\n    byteSize: Scalars['Int']\n    /** The HTTP path for this Git object */\n    commitResourcePath: Scalars['URI']\n    /** The HTTP URL for this Git object */\n    commitUrl: Scalars['URI']\n    id: Scalars['ID']\n    /** Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding. */\n    isBinary?: Maybe<Scalars['Boolean']>\n    /** Indicates whether the contents is truncated */\n    isTruncated: Scalars['Boolean']\n    /** The Git object ID */\n    oid: Scalars['GitObjectID']\n    /** The Repository the Git object belongs to */\n    repository: Repository\n    /** UTF8 text data or null if the Blob is binary */\n    text?: Maybe<Scalars['String']>\n  }\n\n/** A special type of user which takes actions on behalf of GitHub Apps. */\nexport type Bot = Actor &\n  Node &\n  UniformResourceLocatable & {\n    /** A URL pointing to the GitHub App's public avatar. */\n    avatarUrl: Scalars['URI']\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    id: Scalars['ID']\n    /** The username of the actor. */\n    login: Scalars['String']\n    /** The HTTP path for this bot */\n    resourcePath: Scalars['URI']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this bot */\n    url: Scalars['URI']\n  }\n\n/** A special type of user which takes actions on behalf of GitHub Apps. */\nexport type BotAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** A branch protection rule. */\nexport type BranchProtectionRule = Node & {\n  /** Can this branch be deleted. */\n  allowsDeletions: Scalars['Boolean']\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes: Scalars['Boolean']\n  /** A list of conflicts matching branches protection rule and other branch protection rules */\n  branchProtectionRuleConflicts: BranchProtectionRuleConflictConnection\n  /** The actor who created this branch protection rule. */\n  creator?: Maybe<Actor>\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews: Scalars['Boolean']\n  id: Scalars['ID']\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced: Scalars['Boolean']\n  /** Repository refs that are protected by this rule */\n  matchingRefs: RefConnection\n  /** Identifies the protection rule pattern. */\n  pattern: Scalars['String']\n  /** A list push allowances for this branch protection rule. */\n  pushAllowances: PushAllowanceConnection\n  /** The repository associated with this branch protection rule. */\n  repository?: Maybe<Repository>\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars['Int']>\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']>>>\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews: Scalars['Boolean']\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews: Scalars['Boolean']\n  /** Are commits required to be signed. */\n  requiresCommitSignatures: Scalars['Boolean']\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution: Scalars['Boolean']\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory: Scalars['Boolean']\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks: Scalars['Boolean']\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks: Scalars['Boolean']\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes: Scalars['Boolean']\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals: Scalars['Boolean']\n  /** A list review dismissal allowances for this branch protection rule. */\n  reviewDismissalAllowances: ReviewDismissalAllowanceConnection\n}\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleBranchProtectionRuleConflictsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleMatchingRefsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  query?: Maybe<Scalars['String']>\n}\n\n/** A branch protection rule. */\nexport type BranchProtectionRulePushAllowancesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleReviewDismissalAllowancesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A conflict between two branch protection rules. */\nexport type BranchProtectionRuleConflict = {\n  /** Identifies the branch protection rule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>\n  /** Identifies the conflicting branch protection rule. */\n  conflictingBranchProtectionRule?: Maybe<BranchProtectionRule>\n  /** Identifies the branch ref that has conflicting rules */\n  ref?: Maybe<Ref>\n}\n\n/** The connection type for BranchProtectionRuleConflict. */\nexport type BranchProtectionRuleConflictConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BranchProtectionRuleConflictEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BranchProtectionRuleConflict>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type BranchProtectionRuleConflictEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<BranchProtectionRuleConflict>\n}\n\n/** The connection type for BranchProtectionRule. */\nexport type BranchProtectionRuleConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BranchProtectionRuleEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BranchProtectionRule>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type BranchProtectionRuleEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<BranchProtectionRule>\n}\n\n/** The Common Vulnerability Scoring System */\nexport type Cvss = {\n  /** The CVSS score associated with this advisory */\n  score: Scalars['Float']\n  /** The CVSS vector string associated with this advisory */\n  vectorString?: Maybe<Scalars['String']>\n}\n\n/** A common weakness enumeration */\nexport type Cwe = Node & {\n  /** The id of the CWE */\n  cweId: Scalars['String']\n  /** A detailed description of this CWE */\n  description: Scalars['String']\n  id: Scalars['ID']\n  /** The name of this CWE */\n  name: Scalars['String']\n}\n\n/** The connection type for CWE. */\nexport type CweConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CweEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Cwe>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type CweEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Cwe>\n}\n\n/** Autogenerated input type of CancelEnterpriseAdminInvitation */\nexport type CancelEnterpriseAdminInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the pending enterprise administrator invitation. */\n  invitationId: Scalars['ID']\n}\n\n/** Autogenerated return type of CancelEnterpriseAdminInvitation */\nexport type CancelEnterpriseAdminInvitationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The invitation that was canceled. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>\n  /** A message confirming the result of canceling an administrator invitation. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of CancelSponsorship */\nexport type CancelSponsorshipInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: Maybe<Scalars['ID']>\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: Maybe<Scalars['String']>\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: Maybe<Scalars['ID']>\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of CancelSponsorship */\nexport type CancelSponsorshipPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The tier that was being used at the time of cancellation. */\n  sponsorsTier?: Maybe<SponsorsTier>\n}\n\n/** Autogenerated input type of ChangeUserStatus */\nexport type ChangeUserStatusInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */\n  emoji?: Maybe<Scalars['String']>\n  /** If set, the user status will not be shown after this date. */\n  expiresAt?: Maybe<Scalars['DateTime']>\n  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */\n  limitedAvailability?: Maybe<Scalars['Boolean']>\n  /** A short description of your current status. */\n  message?: Maybe<Scalars['String']>\n  /**\n   * The ID of the organization whose members will be allowed to see the status. If\n   * omitted, the status will be publicly visible.\n   */\n  organizationId?: Maybe<Scalars['ID']>\n}\n\n/** Autogenerated return type of ChangeUserStatus */\nexport type ChangeUserStatusPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Your updated status. */\n  status?: Maybe<UserStatus>\n}\n\n/** A single check annotation. */\nexport type CheckAnnotation = {\n  /** The annotation's severity level. */\n  annotationLevel?: Maybe<CheckAnnotationLevel>\n  /** The path to the file that this annotation was made on. */\n  blobUrl: Scalars['URI']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** The position of this annotation. */\n  location: CheckAnnotationSpan\n  /** The annotation's message. */\n  message: Scalars['String']\n  /** The path that this annotation was made on. */\n  path: Scalars['String']\n  /** Additional information about the annotation. */\n  rawDetails?: Maybe<Scalars['String']>\n  /** The annotation's title */\n  title?: Maybe<Scalars['String']>\n}\n\n/** The connection type for CheckAnnotation. */\nexport type CheckAnnotationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckAnnotationEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckAnnotation>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Information from a check run analysis to specific lines of code. */\nexport type CheckAnnotationData = {\n  /** Represents an annotation's information level */\n  annotationLevel: CheckAnnotationLevel\n  /** The location of the annotation */\n  location: CheckAnnotationRange\n  /** A short description of the feedback for these lines of code. */\n  message: Scalars['String']\n  /** The path of the file to add an annotation to. */\n  path: Scalars['String']\n  /** Details about this annotation. */\n  rawDetails?: Maybe<Scalars['String']>\n  /** The title that represents the annotation. */\n  title?: Maybe<Scalars['String']>\n}\n\n/** An edge in a connection. */\nexport type CheckAnnotationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckAnnotation>\n}\n\n/** Represents an annotation's information level. */\nexport enum CheckAnnotationLevel {\n  /** An annotation indicating an inescapable error. */\n  Failure = 'FAILURE',\n  /** An annotation indicating some information. */\n  Notice = 'NOTICE',\n  /** An annotation indicating an ignorable error. */\n  Warning = 'WARNING',\n}\n\n/** A character position in a check annotation. */\nexport type CheckAnnotationPosition = {\n  /** Column number (1 indexed). */\n  column?: Maybe<Scalars['Int']>\n  /** Line number (1 indexed). */\n  line: Scalars['Int']\n}\n\n/** Information from a check run analysis to specific lines of code. */\nexport type CheckAnnotationRange = {\n  /** The ending column of the range. */\n  endColumn?: Maybe<Scalars['Int']>\n  /** The ending line of the range. */\n  endLine: Scalars['Int']\n  /** The starting column of the range. */\n  startColumn?: Maybe<Scalars['Int']>\n  /** The starting line of the range. */\n  startLine: Scalars['Int']\n}\n\n/** An inclusive pair of positions for a check annotation. */\nexport type CheckAnnotationSpan = {\n  /** End position (inclusive). */\n  end: CheckAnnotationPosition\n  /** Start position (inclusive). */\n  start: CheckAnnotationPosition\n}\n\n/** The possible states for a check suite or run conclusion. */\nexport enum CheckConclusionState {\n  /** The check suite or run requires action. */\n  ActionRequired = 'ACTION_REQUIRED',\n  /** The check suite or run has been cancelled. */\n  Cancelled = 'CANCELLED',\n  /** The check suite or run has failed. */\n  Failure = 'FAILURE',\n  /** The check suite or run was neutral. */\n  Neutral = 'NEUTRAL',\n  /** The check suite or run was skipped. */\n  Skipped = 'SKIPPED',\n  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */\n  Stale = 'STALE',\n  /** The check suite or run has failed at startup. */\n  StartupFailure = 'STARTUP_FAILURE',\n  /** The check suite or run has succeeded. */\n  Success = 'SUCCESS',\n  /** The check suite or run has timed out. */\n  TimedOut = 'TIMED_OUT',\n}\n\n/** A check run. */\nexport type CheckRun = Node &\n  RequirableByPullRequest &\n  UniformResourceLocatable & {\n    /** The check run's annotations */\n    annotations?: Maybe<CheckAnnotationConnection>\n    /** The check suite that this run is a part of. */\n    checkSuite: CheckSuite\n    /** Identifies the date and time when the check run was completed. */\n    completedAt?: Maybe<Scalars['DateTime']>\n    /** The conclusion of the check run. */\n    conclusion?: Maybe<CheckConclusionState>\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The corresponding deployment for this job, if any */\n    deployment?: Maybe<Deployment>\n    /** The URL from which to find full details of the check run on the integrator's site. */\n    detailsUrl?: Maybe<Scalars['URI']>\n    /** A reference for the check run on the integrator's system. */\n    externalId?: Maybe<Scalars['String']>\n    id: Scalars['ID']\n    /** Whether this is required to pass before merging for a specific pull request. */\n    isRequired: Scalars['Boolean']\n    /** The name of the check for this check run. */\n    name: Scalars['String']\n    /** Information about a pending deployment, if any, in this check run */\n    pendingDeploymentRequest?: Maybe<DeploymentRequest>\n    /** The permalink to the check run summary. */\n    permalink: Scalars['URI']\n    /** The repository associated with this check run. */\n    repository: Repository\n    /** The HTTP path for this check run. */\n    resourcePath: Scalars['URI']\n    /** Identifies the date and time when the check run was started. */\n    startedAt?: Maybe<Scalars['DateTime']>\n    /** The current status of the check run. */\n    status: CheckStatusState\n    /** The check run's steps */\n    steps?: Maybe<CheckStepConnection>\n    /** A string representing the check run's summary */\n    summary?: Maybe<Scalars['String']>\n    /** A string representing the check run's text */\n    text?: Maybe<Scalars['String']>\n    /** A string representing the check run */\n    title?: Maybe<Scalars['String']>\n    /** The HTTP URL for this check run. */\n    url: Scalars['URI']\n  }\n\n/** A check run. */\nexport type CheckRunAnnotationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A check run. */\nexport type CheckRunIsRequiredArgs = {\n  pullRequestId?: Maybe<Scalars['ID']>\n  pullRequestNumber?: Maybe<Scalars['Int']>\n}\n\n/** A check run. */\nexport type CheckRunStepsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  number?: Maybe<Scalars['Int']>\n}\n\n/** Possible further actions the integrator can perform. */\nexport type CheckRunAction = {\n  /** A short explanation of what this action would do. */\n  description: Scalars['String']\n  /** A reference for the action on the integrator's system. */\n  identifier: Scalars['String']\n  /** The text to be displayed on a button in the web UI. */\n  label: Scalars['String']\n}\n\n/** The connection type for CheckRun. */\nexport type CheckRunConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckRunEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckRun>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type CheckRunEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckRun>\n}\n\n/** The filters that are available when fetching check runs. */\nexport type CheckRunFilter = {\n  /** Filters the check runs created by this application ID. */\n  appId?: Maybe<Scalars['Int']>\n  /** Filters the check runs by this name. */\n  checkName?: Maybe<Scalars['String']>\n  /** Filters the check runs by this type. */\n  checkType?: Maybe<CheckRunType>\n  /** Filters the check runs by this status. */\n  status?: Maybe<CheckStatusState>\n}\n\n/** Descriptive details about the check run. */\nexport type CheckRunOutput = {\n  /** The annotations that are made as part of the check run. */\n  annotations?: Maybe<Array<CheckAnnotationData>>\n  /** Images attached to the check run output displayed in the GitHub pull request UI. */\n  images?: Maybe<Array<CheckRunOutputImage>>\n  /** The summary of the check run (supports Commonmark). */\n  summary: Scalars['String']\n  /** The details of the check run (supports Commonmark). */\n  text?: Maybe<Scalars['String']>\n  /** A title to provide for this check run. */\n  title: Scalars['String']\n}\n\n/** Images attached to the check run output displayed in the GitHub pull request UI. */\nexport type CheckRunOutputImage = {\n  /** The alternative text for the image. */\n  alt: Scalars['String']\n  /** A short image description. */\n  caption?: Maybe<Scalars['String']>\n  /** The full URL of the image. */\n  imageUrl: Scalars['URI']\n}\n\n/** The possible types of check runs. */\nexport enum CheckRunType {\n  /** Every check run available. */\n  All = 'ALL',\n  /** The latest check run. */\n  Latest = 'LATEST',\n}\n\n/** The possible states for a check suite or run status. */\nexport enum CheckStatusState {\n  /** The check suite or run has been completed. */\n  Completed = 'COMPLETED',\n  /** The check suite or run is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The check suite or run is in pending state. */\n  Pending = 'PENDING',\n  /** The check suite or run has been queued. */\n  Queued = 'QUEUED',\n  /** The check suite or run has been requested. */\n  Requested = 'REQUESTED',\n  /** The check suite or run is in waiting state. */\n  Waiting = 'WAITING',\n}\n\n/** A single check step. */\nexport type CheckStep = {\n  /** Identifies the date and time when the check step was completed. */\n  completedAt?: Maybe<Scalars['DateTime']>\n  /** The conclusion of the check step. */\n  conclusion?: Maybe<CheckConclusionState>\n  /** A reference for the check step on the integrator's system. */\n  externalId?: Maybe<Scalars['String']>\n  /** The step's name. */\n  name: Scalars['String']\n  /** The index of the step in the list of steps of the parent check run. */\n  number: Scalars['Int']\n  /** Number of seconds to completion. */\n  secondsToCompletion?: Maybe<Scalars['Int']>\n  /** Identifies the date and time when the check step was started. */\n  startedAt?: Maybe<Scalars['DateTime']>\n  /** The current status of the check step. */\n  status: CheckStatusState\n}\n\n/** The connection type for CheckStep. */\nexport type CheckStepConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckStepEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckStep>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type CheckStepEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckStep>\n}\n\n/** A check suite. */\nexport type CheckSuite = Node & {\n  /** The GitHub App which created this check suite. */\n  app?: Maybe<App>\n  /** The name of the branch for this check suite. */\n  branch?: Maybe<Ref>\n  /** The check runs associated with a check suite. */\n  checkRuns?: Maybe<CheckRunConnection>\n  /** The commit for this check suite */\n  commit: Commit\n  /** The conclusion of this check suite. */\n  conclusion?: Maybe<CheckConclusionState>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The user who triggered the check suite. */\n  creator?: Maybe<User>\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** A list of open pull requests matching the check suite. */\n  matchingPullRequests?: Maybe<PullRequestConnection>\n  /** The push that triggered this check suite. */\n  push?: Maybe<Push>\n  /** The repository associated with this check suite. */\n  repository: Repository\n  /** The HTTP path for this check suite */\n  resourcePath: Scalars['URI']\n  /** The status of this check suite. */\n  status: CheckStatusState\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The HTTP URL for this check suite */\n  url: Scalars['URI']\n  /** The workflow run associated with this check suite. */\n  workflowRun?: Maybe<WorkflowRun>\n}\n\n/** A check suite. */\nexport type CheckSuiteCheckRunsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  filterBy?: Maybe<CheckRunFilter>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A check suite. */\nexport type CheckSuiteMatchingPullRequestsArgs = {\n  after?: Maybe<Scalars['String']>\n  baseRefName?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  headRefName?: Maybe<Scalars['String']>\n  labels?: Maybe<Array<Scalars['String']>>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n  states?: Maybe<Array<PullRequestState>>\n}\n\n/** The auto-trigger preferences that are available for check suites. */\nexport type CheckSuiteAutoTriggerPreference = {\n  /** The node ID of the application that owns the check suite. */\n  appId: Scalars['ID']\n  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */\n  setting: Scalars['Boolean']\n}\n\n/** The connection type for CheckSuite. */\nexport type CheckSuiteConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckSuiteEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckSuite>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type CheckSuiteEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckSuite>\n}\n\n/** The filters that are available when fetching check suites. */\nexport type CheckSuiteFilter = {\n  /** Filters the check suites created by this application ID. */\n  appId?: Maybe<Scalars['Int']>\n  /** Filters the check suites by this name. */\n  checkName?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of ClearLabelsFromLabelable */\nexport type ClearLabelsFromLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The id of the labelable object to clear the labels from. */\n  labelableId: Scalars['ID']\n}\n\n/** Autogenerated return type of ClearLabelsFromLabelable */\nexport type ClearLabelsFromLabelablePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The item that was unlabeled. */\n  labelable?: Maybe<Labelable>\n}\n\n/** Autogenerated input type of CloneProject */\nexport type CloneProjectInput = {\n  /** The description of the project. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Whether or not to clone the source project's workflows. */\n  includeWorkflows: Scalars['Boolean']\n  /** The name of the project. */\n  name: Scalars['String']\n  /** The visibility of the project, defaults to false (private). */\n  public?: Maybe<Scalars['Boolean']>\n  /** The source project to clone. */\n  sourceId: Scalars['ID']\n  /** The owner ID to create the project under. */\n  targetOwnerId: Scalars['ID']\n}\n\n/** Autogenerated return type of CloneProject */\nexport type CloneProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The id of the JobStatus for populating cloned fields. */\n  jobStatusId?: Maybe<Scalars['String']>\n  /** The new cloned project. */\n  project?: Maybe<Project>\n}\n\n/** Autogenerated input type of CloneTemplateRepository */\nexport type CloneTemplateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A short description of the new repository. */\n  description?: Maybe<Scalars['String']>\n  /**\n   * Whether to copy all branches from the template to the new repository. Defaults\n   * to copying only the default branch of the template.\n   */\n  includeAllBranches?: Maybe<Scalars['Boolean']>\n  /** The name of the new repository. */\n  name: Scalars['String']\n  /** The ID of the owner for the new repository. */\n  ownerId: Scalars['ID']\n  /** The Node ID of the template repository. */\n  repositoryId: Scalars['ID']\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility\n}\n\n/** Autogenerated return type of CloneTemplateRepository */\nexport type CloneTemplateRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new repository. */\n  repository?: Maybe<Repository>\n}\n\n/** An object that can be closed */\nexport type Closable = {\n  /** `true` if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean']\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']>\n}\n\n/** Autogenerated input type of CloseIssue */\nexport type CloseIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the issue to be closed. */\n  issueId: Scalars['ID']\n}\n\n/** Autogenerated return type of CloseIssue */\nexport type CloseIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The issue that was closed. */\n  issue?: Maybe<Issue>\n}\n\n/** Autogenerated input type of ClosePullRequest */\nexport type ClosePullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the pull request to be closed. */\n  pullRequestId: Scalars['ID']\n}\n\n/** Autogenerated return type of ClosePullRequest */\nexport type ClosePullRequestPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The pull request that was closed. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Represents a 'closed' event on any `Closable`. */\nexport type ClosedEvent = Node &\n  UniformResourceLocatable & {\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>\n    /** Object that was closed. */\n    closable: Closable\n    /** Object which triggered the creation of this event. */\n    closer?: Maybe<Closer>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    id: Scalars['ID']\n    /** The HTTP path for this closed event. */\n    resourcePath: Scalars['URI']\n    /** The HTTP URL for this closed event. */\n    url: Scalars['URI']\n  }\n\n/** The object which triggered a `ClosedEvent`. */\nexport type Closer = Commit | PullRequest\n\n/** The Code of Conduct for a repository */\nexport type CodeOfConduct = Node & {\n  /** The body of the Code of Conduct */\n  body?: Maybe<Scalars['String']>\n  id: Scalars['ID']\n  /** The key for the Code of Conduct */\n  key: Scalars['String']\n  /** The formal name of the Code of Conduct */\n  name: Scalars['String']\n  /** The HTTP path for this Code of Conduct */\n  resourcePath?: Maybe<Scalars['URI']>\n  /** The HTTP URL for this Code of Conduct */\n  url?: Maybe<Scalars['URI']>\n}\n\n/** Collaborators affiliation level with a subject. */\nexport enum CollaboratorAffiliation {\n  /** All collaborators the authenticated user can see. */\n  All = 'ALL',\n  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */\n  Direct = 'DIRECT',\n  /** All outside collaborators of an organization-owned subject. */\n  Outside = 'OUTSIDE',\n}\n\n/** Represents a comment. */\nexport type Comment = {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation\n  /** The body as Markdown. */\n  body: Scalars['String']\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML']\n  /** The body rendered to text. */\n  bodyText: Scalars['String']\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean']\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>\n  id: Scalars['ID']\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean']\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean']\n}\n\n/** Represents a comment. */\nexport type CommentUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A comment author association with repository. */\nexport enum CommentAuthorAssociation {\n  /** Author has been invited to collaborate on the repository. */\n  Collaborator = 'COLLABORATOR',\n  /** Author has previously committed to the repository. */\n  Contributor = 'CONTRIBUTOR',\n  /** Author has not previously committed to GitHub. */\n  FirstTimer = 'FIRST_TIMER',\n  /** Author has not previously committed to the repository. */\n  FirstTimeContributor = 'FIRST_TIME_CONTRIBUTOR',\n  /** Author is a placeholder for an unclaimed user. */\n  Mannequin = 'MANNEQUIN',\n  /** Author is a member of the organization that owns the repository. */\n  Member = 'MEMBER',\n  /** Author has no association with the repository. */\n  None = 'NONE',\n  /** Author is the owner of the repository. */\n  Owner = 'OWNER',\n}\n\n/** The possible errors that will prevent a user from updating a comment. */\nexport enum CommentCannotUpdateReason {\n  /** Unable to create comment because repository is archived. */\n  Archived = 'ARCHIVED',\n  /** You cannot update this comment */\n  Denied = 'DENIED',\n  /** You must be the author or have write access to this repository to update this comment. */\n  InsufficientAccess = 'INSUFFICIENT_ACCESS',\n  /** Unable to create comment because issue is locked. */\n  Locked = 'LOCKED',\n  /** You must be logged in to update this comment. */\n  LoginRequired = 'LOGIN_REQUIRED',\n  /** Repository is under maintenance. */\n  Maintenance = 'MAINTENANCE',\n  /** At least one email address must be verified to update this comment. */\n  VerifiedEmailRequired = 'VERIFIED_EMAIL_REQUIRED',\n}\n\n/** Represents a 'comment_deleted' event on a given issue or pull request. */\nexport type CommentDeletedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** The user who authored the deleted comment. */\n  deletedCommentAuthor?: Maybe<Actor>\n  id: Scalars['ID']\n}\n\n/** Represents a Git commit. */\nexport type Commit = GitObject &\n  Node &\n  Subscribable &\n  UniformResourceLocatable & {\n    /** An abbreviated version of the Git object ID */\n    abbreviatedOid: Scalars['String']\n    /** The number of additions in this commit. */\n    additions: Scalars['Int']\n    /**\n     * The merged Pull Request that introduced the commit to the repository. If the\n     * commit is not present in the default branch, additionally returns open Pull\n     * Requests associated with the commit\n     */\n    associatedPullRequests?: Maybe<PullRequestConnection>\n    /** Authorship details of the commit. */\n    author?: Maybe<GitActor>\n    /** Check if the committer and the author match. */\n    authoredByCommitter: Scalars['Boolean']\n    /** The datetime when this commit was authored. */\n    authoredDate: Scalars['DateTime']\n    /**\n     * The list of authors for this commit based on the git author and the Co-authored-by\n     * message trailer. The git author will always be first.\n     */\n    authors: GitActorConnection\n    /** Fetches `git blame` information. */\n    blame: Blame\n    /** The number of changed files in this commit. */\n    changedFiles: Scalars['Int']\n    /** The check suites associated with a commit. */\n    checkSuites?: Maybe<CheckSuiteConnection>\n    /** Comments made on the commit. */\n    comments: CommitCommentConnection\n    /** The HTTP path for this Git object */\n    commitResourcePath: Scalars['URI']\n    /** The HTTP URL for this Git object */\n    commitUrl: Scalars['URI']\n    /** The datetime when this commit was committed. */\n    committedDate: Scalars['DateTime']\n    /** Check if committed via GitHub web UI. */\n    committedViaWeb: Scalars['Boolean']\n    /** Committer details of the commit. */\n    committer?: Maybe<GitActor>\n    /** The number of deletions in this commit. */\n    deletions: Scalars['Int']\n    /** The deployments associated with a commit. */\n    deployments?: Maybe<DeploymentConnection>\n    /** The tree entry representing the file located at the given path. */\n    file?: Maybe<TreeEntry>\n    /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */\n    history: CommitHistoryConnection\n    id: Scalars['ID']\n    /** The Git commit message */\n    message: Scalars['String']\n    /** The Git commit message body */\n    messageBody: Scalars['String']\n    /** The commit message body rendered to HTML. */\n    messageBodyHTML: Scalars['HTML']\n    /** The Git commit message headline */\n    messageHeadline: Scalars['String']\n    /** The commit message headline rendered to HTML. */\n    messageHeadlineHTML: Scalars['HTML']\n    /** The Git object ID */\n    oid: Scalars['GitObjectID']\n    /** The organization this commit was made on behalf of. */\n    onBehalfOf?: Maybe<Organization>\n    /** The parents of a commit. */\n    parents: CommitConnection\n    /** The datetime when this commit was pushed. */\n    pushedDate?: Maybe<Scalars['DateTime']>\n    /** The Repository this commit belongs to */\n    repository: Repository\n    /** The HTTP path for this commit */\n    resourcePath: Scalars['URI']\n    /** Commit signing information, if present. */\n    signature?: Maybe<GitSignature>\n    /** Status information for this commit */\n    status?: Maybe<Status>\n    /** Check and Status rollup information for this commit. */\n    statusCheckRollup?: Maybe<StatusCheckRollup>\n    /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */\n    submodules: SubmoduleConnection\n    /**\n     * Returns a URL to download a tarball archive for a repository.\n     * Note: For private repositories, these links are temporary and expire after five minutes.\n     */\n    tarballUrl: Scalars['URI']\n    /** Commit's root Tree */\n    tree: Tree\n    /** The HTTP path for the tree of this commit */\n    treeResourcePath: Scalars['URI']\n    /** The HTTP URL for the tree of this commit */\n    treeUrl: Scalars['URI']\n    /** The HTTP URL for this commit */\n    url: Scalars['URI']\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars['Boolean']\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>\n    /**\n     * Returns a URL to download a zipball archive for a repository.\n     * Note: For private repositories, these links are temporary and expire after five minutes.\n     */\n    zipballUrl: Scalars['URI']\n  }\n\n/** Represents a Git commit. */\nexport type CommitAssociatedPullRequestsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<PullRequestOrder>\n}\n\n/** Represents a Git commit. */\nexport type CommitAuthorsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Represents a Git commit. */\nexport type CommitBlameArgs = {\n  path: Scalars['String']\n}\n\n/** Represents a Git commit. */\nexport type CommitCheckSuitesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  filterBy?: Maybe<CheckSuiteFilter>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Represents a Git commit. */\nexport type CommitCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Represents a Git commit. */\nexport type CommitDeploymentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  environments?: Maybe<Array<Scalars['String']>>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<DeploymentOrder>\n}\n\n/** Represents a Git commit. */\nexport type CommitFileArgs = {\n  path: Scalars['String']\n}\n\n/** Represents a Git commit. */\nexport type CommitHistoryArgs = {\n  after?: Maybe<Scalars['String']>\n  author?: Maybe<CommitAuthor>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  path?: Maybe<Scalars['String']>\n  since?: Maybe<Scalars['GitTimestamp']>\n  until?: Maybe<Scalars['GitTimestamp']>\n}\n\n/** Represents a Git commit. */\nexport type CommitParentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Represents a Git commit. */\nexport type CommitSubmodulesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Specifies an author for filtering Git commits. */\nexport type CommitAuthor = {\n  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */\n  emails?: Maybe<Array<Scalars['String']>>\n  /**\n   * ID of a User to filter by. If non-null, only commits authored by this user\n   * will be returned. This field takes precedence over emails.\n   */\n  id?: Maybe<Scalars['ID']>\n}\n\n/** Represents a comment on a given Commit. */\nexport type CommitComment = Comment &\n  Deletable &\n  Minimizable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Updatable &\n  UpdatableComment & {\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation\n    /** Identifies the comment body. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The body rendered to text. */\n    bodyText: Scalars['String']\n    /** Identifies the commit associated with the comment, if the commit exists. */\n    commit?: Maybe<Commit>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** Returns whether or not a comment has been minimized. */\n    isMinimized: Scalars['Boolean']\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** Returns why the comment was minimized. */\n    minimizedReason?: Maybe<Scalars['String']>\n    /** Identifies the file path associated with the comment. */\n    path?: Maybe<Scalars['String']>\n    /** Identifies the line position associated with the comment. */\n    position?: Maybe<Scalars['Int']>\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** The repository associated with this node. */\n    repository: Repository\n    /** The HTTP path permalink for this commit comment. */\n    resourcePath: Scalars['URI']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL permalink for this commit comment. */\n    url: Scalars['URI']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars['Boolean']\n    /** Check if the current viewer can minimize this object. */\n    viewerCanMinimize: Scalars['Boolean']\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n  }\n\n/** Represents a comment on a given Commit. */\nexport type CommitCommentReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** Represents a comment on a given Commit. */\nexport type CommitCommentUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for CommitComment. */\nexport type CommitCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitCommentEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CommitComment>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type CommitCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<CommitComment>\n}\n\n/** A thread of comments on a commit. */\nexport type CommitCommentThread = Node &\n  RepositoryNode & {\n    /** The comments that exist in this thread. */\n    comments: CommitCommentConnection\n    /** The commit the comments were made on. */\n    commit?: Maybe<Commit>\n    id: Scalars['ID']\n    /** The file the comments were made on. */\n    path?: Maybe<Scalars['String']>\n    /** The position in the diff for the commit that the comment was made on. */\n    position?: Maybe<Scalars['Int']>\n    /** The repository associated with this node. */\n    repository: Repository\n  }\n\n/** A thread of comments on a commit. */\nexport type CommitCommentThreadCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for Commit. */\nexport type CommitConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Commit>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Ordering options for commit contribution connections. */\nexport type CommitContributionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field by which to order commit contributions. */\n  field: CommitContributionOrderField\n}\n\n/** Properties by which commit contribution connections can be ordered. */\nexport enum CommitContributionOrderField {\n  /** Order commit contributions by how many commits they represent. */\n  CommitCount = 'COMMIT_COUNT',\n  /** Order commit contributions by when they were made. */\n  OccurredAt = 'OCCURRED_AT',\n}\n\n/** This aggregates commits made by a user within one repository. */\nexport type CommitContributionsByRepository = {\n  /** The commit contributions, each representing a day. */\n  contributions: CreatedCommitContributionConnection\n  /** The repository in which the commits were made. */\n  repository: Repository\n  /** The HTTP path for the user's commits to the repository in this time range. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for the user's commits to the repository in this time range. */\n  url: Scalars['URI']\n}\n\n/** This aggregates commits made by a user within one repository. */\nexport type CommitContributionsByRepositoryContributionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<CommitContributionOrder>\n}\n\n/** An edge in a connection. */\nexport type CommitEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Commit>\n}\n\n/** The connection type for Commit. */\nexport type CommitHistoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Commit>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** A message to include with a new commit */\nexport type CommitMessage = {\n  /** The body of the message. */\n  body?: Maybe<Scalars['String']>\n  /** The headline of the message. */\n  headline: Scalars['String']\n}\n\n/**\n * A git ref for a commit to be appended to.\n *\n * The ref must be a branch, i.e. its fully qualified name must start\n * with `refs/heads/` (although the input is not required to be fully\n * qualified).\n *\n * The Ref may be specified by its global node ID or by the\n * repository nameWithOwner and branch name.\n *\n * ### Examples\n *\n * Specify a branch using a global node ID:\n *\n *     { \"id\": \"MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=\" }\n *\n * Specify a branch using nameWithOwner and branch name:\n *\n *     {\n *       \"nameWithOwner\": \"github/graphql-client\",\n *       \"branchName\": \"main\"\n *     }\n */\nexport type CommittableBranch = {\n  /** The unqualified name of the branch to append the commit to. */\n  branchName?: Maybe<Scalars['String']>\n  /** The Node ID of the Ref to be updated. */\n  id?: Maybe<Scalars['ID']>\n  /** The nameWithOwner of the repository to commit to. */\n  repositoryNameWithOwner?: Maybe<Scalars['String']>\n}\n\n/** Represents a 'connected' event on a given issue or pull request. */\nexport type ConnectedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean']\n  /** Issue or pull request that made the reference. */\n  source: ReferencedSubject\n  /** Issue or pull request which was connected. */\n  subject: ReferencedSubject\n}\n\n/** A content attachment */\nexport type ContentAttachment = {\n  /** The body text of the content attachment. This parameter supports markdown. */\n  body: Scalars['String']\n  /** The content reference that the content attachment is attached to. */\n  contentReference: ContentReference\n  /** Identifies the primary key from the database. */\n  databaseId: Scalars['Int']\n  id: Scalars['ID']\n  /** The title of the content attachment. */\n  title: Scalars['String']\n}\n\n/** A content reference */\nexport type ContentReference = {\n  /** Identifies the primary key from the database. */\n  databaseId: Scalars['Int']\n  id: Scalars['ID']\n  /** The reference of the content reference. */\n  reference: Scalars['String']\n}\n\n/** Represents a contribution a user made on GitHub, such as opening an issue. */\nexport type Contribution = {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']\n  /** The user who made this contribution. */\n  user: User\n}\n\n/** A calendar of contributions made on GitHub by a user. */\nexport type ContributionCalendar = {\n  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */\n  colors: Array<Scalars['String']>\n  /** Determine if the color set was chosen because it's currently Halloween. */\n  isHalloween: Scalars['Boolean']\n  /** A list of the months of contributions in this calendar. */\n  months: Array<ContributionCalendarMonth>\n  /** The count of total contributions in the calendar. */\n  totalContributions: Scalars['Int']\n  /** A list of the weeks of contributions in this calendar. */\n  weeks: Array<ContributionCalendarWeek>\n}\n\n/** Represents a single day of contributions on GitHub by a user. */\nexport type ContributionCalendarDay = {\n  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */\n  color: Scalars['String']\n  /** How many contributions were made by the user on this day. */\n  contributionCount: Scalars['Int']\n  /**\n   * Indication of contributions, relative to other days. Can be used to indicate\n   * which color to represent this day on a calendar.\n   */\n  contributionLevel: ContributionLevel\n  /** The day this square represents. */\n  date: Scalars['Date']\n  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */\n  weekday: Scalars['Int']\n}\n\n/** A month of contributions in a user's contribution graph. */\nexport type ContributionCalendarMonth = {\n  /** The date of the first day of this month. */\n  firstDay: Scalars['Date']\n  /** The name of the month. */\n  name: Scalars['String']\n  /** How many weeks started in this month. */\n  totalWeeks: Scalars['Int']\n  /** The year the month occurred in. */\n  year: Scalars['Int']\n}\n\n/** A week of contributions in a user's contribution graph. */\nexport type ContributionCalendarWeek = {\n  /** The days of contributions in this week. */\n  contributionDays: Array<ContributionCalendarDay>\n  /** The date of the earliest square in this week. */\n  firstDay: Scalars['Date']\n}\n\n/** Varying levels of contributions from none to many. */\nexport enum ContributionLevel {\n  /** Lowest 25% of days of contributions. */\n  FirstQuartile = 'FIRST_QUARTILE',\n  /** Highest 25% of days of contributions. More contributions than the third quartile. */\n  FourthQuartile = 'FOURTH_QUARTILE',\n  /** No contributions occurred. */\n  None = 'NONE',\n  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */\n  SecondQuartile = 'SECOND_QUARTILE',\n  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */\n  ThirdQuartile = 'THIRD_QUARTILE',\n}\n\n/** Ordering options for contribution connections. */\nexport type ContributionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollection = {\n  /** Commit contributions made by the user, grouped by repository. */\n  commitContributionsByRepository: Array<CommitContributionsByRepository>\n  /** A calendar of this user's contributions on GitHub. */\n  contributionCalendar: ContributionCalendar\n  /** The years the user has been making contributions with the most recent year first. */\n  contributionYears: Array<Scalars['Int']>\n  /** Determine if this collection's time span ends in the current month. */\n  doesEndInCurrentMonth: Scalars['Boolean']\n  /**\n   * The date of the first restricted contribution the user made in this time\n   * period. Can only be non-null when the user has enabled private contribution counts.\n   */\n  earliestRestrictedContributionDate?: Maybe<Scalars['Date']>\n  /** The ending date and time of this collection. */\n  endedAt: Scalars['DateTime']\n  /**\n   * The first issue the user opened on GitHub. This will be null if that issue was\n   * opened outside the collection's time range and ignoreTimeRange is false. If\n   * the issue is not visible but the user has opted to show private contributions,\n   * a RestrictedContribution will be returned.\n   */\n  firstIssueContribution?: Maybe<CreatedIssueOrRestrictedContribution>\n  /**\n   * The first pull request the user opened on GitHub. This will be null if that\n   * pull request was opened outside the collection's time range and\n   * ignoreTimeRange is not true. If the pull request is not visible but the user\n   * has opted to show private contributions, a RestrictedContribution will be returned.\n   */\n  firstPullRequestContribution?: Maybe<CreatedPullRequestOrRestrictedContribution>\n  /**\n   * The first repository the user created on GitHub. This will be null if that\n   * first repository was created outside the collection's time range and\n   * ignoreTimeRange is false. If the repository is not visible, then a\n   * RestrictedContribution is returned.\n   */\n  firstRepositoryContribution?: Maybe<CreatedRepositoryOrRestrictedContribution>\n  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */\n  hasActivityInThePast: Scalars['Boolean']\n  /** Determine if there are any contributions in this collection. */\n  hasAnyContributions: Scalars['Boolean']\n  /**\n   * Determine if the user made any contributions in this time frame whose details\n   * are not visible because they were made in a private repository. Can only be\n   * true if the user enabled private contribution counts.\n   */\n  hasAnyRestrictedContributions: Scalars['Boolean']\n  /** Whether or not the collector's time span is all within the same day. */\n  isSingleDay: Scalars['Boolean']\n  /** A list of issues the user opened. */\n  issueContributions: CreatedIssueContributionConnection\n  /** Issue contributions made by the user, grouped by repository. */\n  issueContributionsByRepository: Array<IssueContributionsByRepository>\n  /**\n   * When the user signed up for GitHub. This will be null if that sign up date\n   * falls outside the collection's time range and ignoreTimeRange is false.\n   */\n  joinedGitHubContribution?: Maybe<JoinedGitHubContribution>\n  /**\n   * The date of the most recent restricted contribution the user made in this time\n   * period. Can only be non-null when the user has enabled private contribution counts.\n   */\n  latestRestrictedContributionDate?: Maybe<Scalars['Date']>\n  /**\n   * When this collection's time range does not include any activity from the user, use this\n   * to get a different collection from an earlier time range that does have activity.\n   */\n  mostRecentCollectionWithActivity?: Maybe<ContributionsCollection>\n  /**\n   * Returns a different contributions collection from an earlier time range than this one\n   * that does not have any contributions.\n   */\n  mostRecentCollectionWithoutActivity?: Maybe<ContributionsCollection>\n  /**\n   * The issue the user opened on GitHub that received the most comments in the specified\n   * time frame.\n   */\n  popularIssueContribution?: Maybe<CreatedIssueContribution>\n  /**\n   * The pull request the user opened on GitHub that received the most comments in the\n   * specified time frame.\n   */\n  popularPullRequestContribution?: Maybe<CreatedPullRequestContribution>\n  /** Pull request contributions made by the user. */\n  pullRequestContributions: CreatedPullRequestContributionConnection\n  /** Pull request contributions made by the user, grouped by repository. */\n  pullRequestContributionsByRepository: Array<PullRequestContributionsByRepository>\n  /** Pull request review contributions made by the user. */\n  pullRequestReviewContributions: CreatedPullRequestReviewContributionConnection\n  /** Pull request review contributions made by the user, grouped by repository. */\n  pullRequestReviewContributionsByRepository: Array<PullRequestReviewContributionsByRepository>\n  /** A list of repositories owned by the user that the user created in this time range. */\n  repositoryContributions: CreatedRepositoryContributionConnection\n  /**\n   * A count of contributions made by the user that the viewer cannot access. Only\n   * non-zero when the user has chosen to share their private contribution counts.\n   */\n  restrictedContributionsCount: Scalars['Int']\n  /** The beginning date and time of this collection. */\n  startedAt: Scalars['DateTime']\n  /** How many commits were made by the user in this time span. */\n  totalCommitContributions: Scalars['Int']\n  /** How many issues the user opened. */\n  totalIssueContributions: Scalars['Int']\n  /** How many pull requests the user opened. */\n  totalPullRequestContributions: Scalars['Int']\n  /** How many pull request reviews the user left. */\n  totalPullRequestReviewContributions: Scalars['Int']\n  /** How many different repositories the user committed to. */\n  totalRepositoriesWithContributedCommits: Scalars['Int']\n  /** How many different repositories the user opened issues in. */\n  totalRepositoriesWithContributedIssues: Scalars['Int']\n  /** How many different repositories the user left pull request reviews in. */\n  totalRepositoriesWithContributedPullRequestReviews: Scalars['Int']\n  /** How many different repositories the user opened pull requests in. */\n  totalRepositoriesWithContributedPullRequests: Scalars['Int']\n  /** How many repositories the user created. */\n  totalRepositoryContributions: Scalars['Int']\n  /** The user who made the contributions in this collection. */\n  user: User\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionCommitContributionsByRepositoryArgs = {\n  maxRepositories?: Maybe<Scalars['Int']>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionIssueContributionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  excludeFirst?: Maybe<Scalars['Boolean']>\n  excludePopular?: Maybe<Scalars['Boolean']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ContributionOrder>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionIssueContributionsByRepositoryArgs = {\n  excludeFirst?: Maybe<Scalars['Boolean']>\n  excludePopular?: Maybe<Scalars['Boolean']>\n  maxRepositories?: Maybe<Scalars['Int']>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestContributionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  excludeFirst?: Maybe<Scalars['Boolean']>\n  excludePopular?: Maybe<Scalars['Boolean']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ContributionOrder>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestContributionsByRepositoryArgs = {\n  excludeFirst?: Maybe<Scalars['Boolean']>\n  excludePopular?: Maybe<Scalars['Boolean']>\n  maxRepositories?: Maybe<Scalars['Int']>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestReviewContributionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ContributionOrder>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestReviewContributionsByRepositoryArgs = {\n  maxRepositories?: Maybe<Scalars['Int']>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionRepositoryContributionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  excludeFirst?: Maybe<Scalars['Boolean']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ContributionOrder>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalIssueContributionsArgs = {\n  excludeFirst?: Maybe<Scalars['Boolean']>\n  excludePopular?: Maybe<Scalars['Boolean']>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalPullRequestContributionsArgs = {\n  excludeFirst?: Maybe<Scalars['Boolean']>\n  excludePopular?: Maybe<Scalars['Boolean']>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoriesWithContributedIssuesArgs = {\n  excludeFirst?: Maybe<Scalars['Boolean']>\n  excludePopular?: Maybe<Scalars['Boolean']>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs = {\n  excludeFirst?: Maybe<Scalars['Boolean']>\n  excludePopular?: Maybe<Scalars['Boolean']>\n}\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoryContributionsArgs = {\n  excludeFirst?: Maybe<Scalars['Boolean']>\n}\n\n/** Autogenerated input type of ConvertProjectCardNoteToIssue */\nexport type ConvertProjectCardNoteToIssueInput = {\n  /** The body of the newly created issue. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ProjectCard ID to convert. */\n  projectCardId: Scalars['ID']\n  /** The ID of the repository to create the issue in. */\n  repositoryId: Scalars['ID']\n  /** The title of the newly created issue. Defaults to the card's note text. */\n  title?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of ConvertProjectCardNoteToIssue */\nexport type ConvertProjectCardNoteToIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated ProjectCard. */\n  projectCard?: Maybe<ProjectCard>\n}\n\n/** Autogenerated input type of ConvertPullRequestToDraft */\nexport type ConvertPullRequestToDraftInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the pull request to convert to draft */\n  pullRequestId: Scalars['ID']\n}\n\n/** Autogenerated return type of ConvertPullRequestToDraft */\nexport type ConvertPullRequestToDraftPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The pull request that is now a draft. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Represents a 'convert_to_draft' event on a given pull request. */\nexport type ConvertToDraftEvent = Node &\n  UniformResourceLocatable & {\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    id: Scalars['ID']\n    /** PullRequest referenced by event. */\n    pullRequest: PullRequest\n    /** The HTTP path for this convert to draft event. */\n    resourcePath: Scalars['URI']\n    /** The HTTP URL for this convert to draft event. */\n    url: Scalars['URI']\n  }\n\n/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\nexport type ConvertedNoteToIssueEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** Project referenced by event. */\n  project?: Maybe<Project>\n  /** Project card referenced by this project event. */\n  projectCard?: Maybe<ProjectCard>\n  /** Column name referenced by this project event. */\n  projectColumnName: Scalars['String']\n}\n\n/** Autogenerated input type of CreateBranchProtectionRule */\nexport type CreateBranchProtectionRuleInput = {\n  /** Can this branch be deleted. */\n  allowsDeletions?: Maybe<Scalars['Boolean']>\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes?: Maybe<Scalars['Boolean']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews?: Maybe<Scalars['Boolean']>\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced?: Maybe<Scalars['Boolean']>\n  /** The glob-like pattern used to determine matching branches. */\n  pattern: Scalars['String']\n  /** A list of User, Team or App IDs allowed to push to matching branches. */\n  pushActorIds?: Maybe<Array<Scalars['ID']>>\n  /** The global relay id of the repository in which a new branch protection rule should be created in. */\n  repositoryId: Scalars['ID']\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars['Int']>\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Scalars['String']>>\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews?: Maybe<Scalars['Boolean']>\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews?: Maybe<Scalars['Boolean']>\n  /** Are commits required to be signed. */\n  requiresCommitSignatures?: Maybe<Scalars['Boolean']>\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution?: Maybe<Scalars['Boolean']>\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory?: Maybe<Scalars['Boolean']>\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks?: Maybe<Scalars['Boolean']>\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks?: Maybe<Scalars['Boolean']>\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes?: Maybe<Scalars['Boolean']>\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals?: Maybe<Scalars['Boolean']>\n  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */\n  reviewDismissalActorIds?: Maybe<Array<Scalars['ID']>>\n}\n\n/** Autogenerated return type of CreateBranchProtectionRule */\nexport type CreateBranchProtectionRulePayload = {\n  /** The newly created BranchProtectionRule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of CreateCheckRun */\nexport type CreateCheckRunInput = {\n  /** Possible further actions the integrator can perform, which a user may trigger. */\n  actions?: Maybe<Array<CheckRunAction>>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The time that the check run finished. */\n  completedAt?: Maybe<Scalars['DateTime']>\n  /** The final conclusion of the check. */\n  conclusion?: Maybe<CheckConclusionState>\n  /** The URL of the integrator's site that has the full details of the check. */\n  detailsUrl?: Maybe<Scalars['URI']>\n  /** A reference for the run on the integrator's system. */\n  externalId?: Maybe<Scalars['String']>\n  /** The SHA of the head commit. */\n  headSha: Scalars['GitObjectID']\n  /** The name of the check. */\n  name: Scalars['String']\n  /** Descriptive details about the run. */\n  output?: Maybe<CheckRunOutput>\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID']\n  /** The time that the check run began. */\n  startedAt?: Maybe<Scalars['DateTime']>\n  /** The current status. */\n  status?: Maybe<RequestableCheckStatusState>\n}\n\n/** Autogenerated return type of CreateCheckRun */\nexport type CreateCheckRunPayload = {\n  /** The newly created check run. */\n  checkRun?: Maybe<CheckRun>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of CreateCheckSuite */\nexport type CreateCheckSuiteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The SHA of the head commit. */\n  headSha: Scalars['GitObjectID']\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of CreateCheckSuite */\nexport type CreateCheckSuitePayload = {\n  /** The newly created check suite. */\n  checkSuite?: Maybe<CheckSuite>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of CreateCommitOnBranch */\nexport type CreateCommitOnBranchInput = {\n  /** The Ref to be updated.  Must be a branch. */\n  branch: CommittableBranch\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The git commit oid expected at the head of the branch prior to the commit */\n  expectedHeadOid: Scalars['GitObjectID']\n  /** A description of changes to files in this commit. */\n  fileChanges?: Maybe<FileChanges>\n  /** The commit message the be included with the commit. */\n  message: CommitMessage\n}\n\n/** Autogenerated return type of CreateCommitOnBranch */\nexport type CreateCommitOnBranchPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new commit. */\n  commit?: Maybe<Commit>\n  /** The ref which has been updated to point to the new commit. */\n  ref?: Maybe<Ref>\n}\n\n/** Autogenerated input type of CreateContentAttachment */\nexport type CreateContentAttachmentInput = {\n  /** The body of the content attachment, which may contain markdown. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The node ID of the content_reference. */\n  contentReferenceId: Scalars['ID']\n  /** The title of the content attachment. */\n  title: Scalars['String']\n}\n\n/** Autogenerated return type of CreateContentAttachment */\nexport type CreateContentAttachmentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The newly created content attachment. */\n  contentAttachment?: Maybe<ContentAttachment>\n}\n\n/** Autogenerated input type of CreateDeployment */\nexport type CreateDeploymentInput = {\n  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */\n  autoMerge?: Maybe<Scalars['Boolean']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Short description of the deployment. */\n  description?: Maybe<Scalars['String']>\n  /** Name for the target deployment environment. */\n  environment?: Maybe<Scalars['String']>\n  /** JSON payload with extra information about the deployment. */\n  payload?: Maybe<Scalars['String']>\n  /** The node ID of the ref to be deployed. */\n  refId: Scalars['ID']\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID']\n  /**\n   * The status contexts to verify against commit status checks. To bypass required\n   * contexts, pass an empty array. Defaults to all unique contexts.\n   */\n  requiredContexts?: Maybe<Array<Scalars['String']>>\n  /** Specifies a task to execute. */\n  task?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of CreateDeployment */\nexport type CreateDeploymentPayload = {\n  /** True if the default branch has been auto-merged into the deployment ref. */\n  autoMerged?: Maybe<Scalars['Boolean']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new deployment. */\n  deployment?: Maybe<Deployment>\n}\n\n/** Autogenerated input type of CreateDeploymentStatus */\nexport type CreateDeploymentStatusInput = {\n  /**\n   * Adds a new inactive status to all non-transient, non-production environment\n   * deployments with the same repository and environment name as the created\n   * status's deployment.\n   */\n  autoInactive?: Maybe<Scalars['Boolean']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The node ID of the deployment. */\n  deploymentId: Scalars['ID']\n  /** A short description of the status. Maximum length of 140 characters. */\n  description?: Maybe<Scalars['String']>\n  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */\n  environment?: Maybe<Scalars['String']>\n  /** Sets the URL for accessing your environment. */\n  environmentUrl?: Maybe<Scalars['String']>\n  /**\n   * The log URL to associate with this status.       This URL should contain\n   * output to keep the user updated while the task is running       or serve as\n   * historical information for what happened in the deployment.\n   */\n  logUrl?: Maybe<Scalars['String']>\n  /** The state of the deployment. */\n  state: DeploymentStatusState\n}\n\n/** Autogenerated return type of CreateDeploymentStatus */\nexport type CreateDeploymentStatusPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new deployment status. */\n  deploymentStatus?: Maybe<DeploymentStatus>\n}\n\n/** Autogenerated input type of CreateDiscussion */\nexport type CreateDiscussionInput = {\n  /** The body of the discussion. */\n  body: Scalars['String']\n  /** The id of the discussion category to associate with this discussion. */\n  categoryId: Scalars['ID']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The id of the repository on which to create the discussion. */\n  repositoryId: Scalars['ID']\n  /** The title of the discussion. */\n  title: Scalars['String']\n}\n\n/** Autogenerated return type of CreateDiscussion */\nexport type CreateDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The discussion that was just created. */\n  discussion?: Maybe<Discussion>\n}\n\n/** Autogenerated input type of CreateEnterpriseOrganization */\nexport type CreateEnterpriseOrganizationInput = {\n  /** The logins for the administrators of the new organization. */\n  adminLogins: Array<Scalars['String']>\n  /** The email used for sending billing receipts. */\n  billingEmail: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise owning the new organization. */\n  enterpriseId: Scalars['ID']\n  /** The login of the new organization. */\n  login: Scalars['String']\n  /** The profile name of the new organization. */\n  profileName: Scalars['String']\n}\n\n/** Autogenerated return type of CreateEnterpriseOrganization */\nexport type CreateEnterpriseOrganizationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise that owns the created organization. */\n  enterprise?: Maybe<Enterprise>\n  /** The organization that was created. */\n  organization?: Maybe<Organization>\n}\n\n/** Autogenerated input type of CreateEnvironment */\nexport type CreateEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The name of the environment. */\n  name: Scalars['String']\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of CreateEnvironment */\nexport type CreateEnvironmentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new or existing environment. */\n  environment?: Maybe<Environment>\n}\n\n/** Autogenerated input type of CreateIpAllowListEntry */\nexport type CreateIpAllowListEntryInput = {\n  /** An IP address or range of addresses in CIDR notation. */\n  allowListValue: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Whether the IP allow list entry is active when an IP allow list is enabled. */\n  isActive: Scalars['Boolean']\n  /** An optional name for the IP allow list entry. */\n  name?: Maybe<Scalars['String']>\n  /** The ID of the owner for which to create the new IP allow list entry. */\n  ownerId: Scalars['ID']\n}\n\n/** Autogenerated return type of CreateIpAllowListEntry */\nexport type CreateIpAllowListEntryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The IP allow list entry that was created. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>\n}\n\n/** Autogenerated input type of CreateIssue */\nexport type CreateIssueInput = {\n  /** The Node ID for the user assignee for this issue. */\n  assigneeIds?: Maybe<Array<Scalars['ID']>>\n  /** The body for the issue description. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */\n  issueTemplate?: Maybe<Scalars['String']>\n  /** An array of Node IDs of labels for this issue. */\n  labelIds?: Maybe<Array<Scalars['ID']>>\n  /** The Node ID of the milestone for this issue. */\n  milestoneId?: Maybe<Scalars['ID']>\n  /** An array of Node IDs for projects associated with this issue. */\n  projectIds?: Maybe<Array<Scalars['ID']>>\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']\n  /** The title for the issue. */\n  title: Scalars['String']\n}\n\n/** Autogenerated return type of CreateIssue */\nexport type CreateIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new issue. */\n  issue?: Maybe<Issue>\n}\n\n/** Autogenerated input type of CreateLabel */\nexport type CreateLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A 6 character hex code, without the leading #, identifying the color of the label. */\n  color: Scalars['String']\n  /** A brief description of the label, such as its purpose. */\n  description?: Maybe<Scalars['String']>\n  /** The name of the label. */\n  name: Scalars['String']\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of CreateLabel */\nexport type CreateLabelPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new label. */\n  label?: Maybe<Label>\n}\n\n/** Autogenerated input type of CreateProject */\nexport type CreateProjectInput = {\n  /** The description of project. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The name of project. */\n  name: Scalars['String']\n  /** The owner ID to create the project under. */\n  ownerId: Scalars['ID']\n  /** A list of repository IDs to create as linked repositories for the project */\n  repositoryIds?: Maybe<Array<Scalars['ID']>>\n  /** The name of the GitHub-provided template. */\n  template?: Maybe<ProjectTemplate>\n}\n\n/** Autogenerated return type of CreateProject */\nexport type CreateProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new project. */\n  project?: Maybe<Project>\n}\n\n/** Autogenerated input type of CreatePullRequest */\nexport type CreatePullRequestInput = {\n  /**\n   * The name of the branch you want your changes pulled into. This should be an existing branch\n   * on the current repository. You cannot update the base branch on a pull request to point\n   * to another repository.\n   */\n  baseRefName: Scalars['String']\n  /** The contents of the pull request. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Indicates whether this pull request should be a draft. */\n  draft?: Maybe<Scalars['Boolean']>\n  /**\n   * The name of the branch where your changes are implemented. For cross-repository pull requests\n   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.\n   */\n  headRefName: Scalars['String']\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify?: Maybe<Scalars['Boolean']>\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']\n  /** The title of the pull request. */\n  title: Scalars['String']\n}\n\n/** Autogenerated return type of CreatePullRequest */\nexport type CreatePullRequestPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new pull request. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Autogenerated input type of CreateRef */\nexport type CreateRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */\n  name: Scalars['String']\n  /** The GitObjectID that the new Ref shall target. Must point to a commit. */\n  oid: Scalars['GitObjectID']\n  /** The Node ID of the Repository to create the Ref in. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of CreateRef */\nexport type CreateRefPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The newly created ref. */\n  ref?: Maybe<Ref>\n}\n\n/** Autogenerated input type of CreateRepository */\nexport type CreateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A short description of the new repository. */\n  description?: Maybe<Scalars['String']>\n  /** Indicates if the repository should have the issues feature enabled. */\n  hasIssuesEnabled?: Maybe<Scalars['Boolean']>\n  /** Indicates if the repository should have the wiki feature enabled. */\n  hasWikiEnabled?: Maybe<Scalars['Boolean']>\n  /** The URL for a web page about this repository. */\n  homepageUrl?: Maybe<Scalars['URI']>\n  /** The name of the new repository. */\n  name: Scalars['String']\n  /** The ID of the owner for the new repository. */\n  ownerId?: Maybe<Scalars['ID']>\n  /**\n   * When an organization is specified as the owner, this ID identifies the team\n   * that should be granted access to the new repository.\n   */\n  teamId?: Maybe<Scalars['ID']>\n  /**\n   * Whether this repository should be marked as a template such that anyone who\n   * can access it can create new repositories with the same files and directory structure.\n   */\n  template?: Maybe<Scalars['Boolean']>\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility\n}\n\n/** Autogenerated return type of CreateRepository */\nexport type CreateRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new repository. */\n  repository?: Maybe<Repository>\n}\n\n/** Autogenerated input type of CreateSponsorship */\nexport type CreateSponsorshipInput = {\n  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */\n  amount?: Maybe<Scalars['Int']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */\n  isRecurring?: Maybe<Scalars['Boolean']>\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorable. Public visibility still does not reveal which tier is used.\n   */\n  privacyLevel?: Maybe<SponsorshipPrivacy>\n  /** Whether the sponsor should receive email updates from the sponsorable. */\n  receiveEmails?: Maybe<Scalars['Boolean']>\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: Maybe<Scalars['ID']>\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: Maybe<Scalars['String']>\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: Maybe<Scalars['ID']>\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: Maybe<Scalars['String']>\n  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */\n  tierId?: Maybe<Scalars['ID']>\n}\n\n/** Autogenerated return type of CreateSponsorship */\nexport type CreateSponsorshipPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The sponsorship that was started. */\n  sponsorship?: Maybe<Sponsorship>\n}\n\n/** Autogenerated input type of CreateTeamDiscussionComment */\nexport type CreateTeamDiscussionCommentInput = {\n  /** The content of the comment. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the discussion to which the comment belongs. */\n  discussionId: Scalars['ID']\n}\n\n/** Autogenerated return type of CreateTeamDiscussionComment */\nexport type CreateTeamDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new comment. */\n  teamDiscussionComment?: Maybe<TeamDiscussionComment>\n}\n\n/** Autogenerated input type of CreateTeamDiscussion */\nexport type CreateTeamDiscussionInput = {\n  /** The content of the discussion. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /**\n   * If true, restricts the visibility of this discussion to team members and\n   * organization admins. If false or not specified, allows any organization member\n   * to view this discussion.\n   */\n  private?: Maybe<Scalars['Boolean']>\n  /** The ID of the team to which the discussion belongs. */\n  teamId: Scalars['ID']\n  /** The title of the discussion. */\n  title: Scalars['String']\n}\n\n/** Autogenerated return type of CreateTeamDiscussion */\nexport type CreateTeamDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new discussion. */\n  teamDiscussion?: Maybe<TeamDiscussion>\n}\n\n/** Represents the contribution a user made by committing to a repository. */\nexport type CreatedCommitContribution = Contribution & {\n  /** How many commits were made on this day to this repository by the user. */\n  commitCount: Scalars['Int']\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']\n  /** The repository the user made a commit in. */\n  repository: Repository\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']\n  /** The user who made this contribution. */\n  user: User\n}\n\n/** The connection type for CreatedCommitContribution. */\nexport type CreatedCommitContributionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedCommitContributionEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedCommitContribution>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of commits across days and repositories in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type CreatedCommitContributionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedCommitContribution>\n}\n\n/** Represents the contribution a user made on GitHub by opening an issue. */\nexport type CreatedIssueContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']\n  /** The issue that was opened. */\n  issue: Issue\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']\n  /** The user who made this contribution. */\n  user: User\n}\n\n/** The connection type for CreatedIssueContribution. */\nexport type CreatedIssueContributionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedIssueContributionEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedIssueContribution>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type CreatedIssueContributionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedIssueContribution>\n}\n\n/** Represents either a issue the viewer can access or a restricted contribution. */\nexport type CreatedIssueOrRestrictedContribution = CreatedIssueContribution | RestrictedContribution\n\n/** Represents the contribution a user made on GitHub by opening a pull request. */\nexport type CreatedPullRequestContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']\n  /** The pull request that was opened. */\n  pullRequest: PullRequest\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']\n  /** The user who made this contribution. */\n  user: User\n}\n\n/** The connection type for CreatedPullRequestContribution. */\nexport type CreatedPullRequestContributionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedPullRequestContributionEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedPullRequestContribution>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type CreatedPullRequestContributionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedPullRequestContribution>\n}\n\n/** Represents either a pull request the viewer can access or a restricted contribution. */\nexport type CreatedPullRequestOrRestrictedContribution =\n  | CreatedPullRequestContribution\n  | RestrictedContribution\n\n/** Represents the contribution a user made by leaving a review on a pull request. */\nexport type CreatedPullRequestReviewContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']\n  /** The pull request the user reviewed. */\n  pullRequest: PullRequest\n  /** The review the user left on the pull request. */\n  pullRequestReview: PullRequestReview\n  /** The repository containing the pull request that the user reviewed. */\n  repository: Repository\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']\n  /** The user who made this contribution. */\n  user: User\n}\n\n/** The connection type for CreatedPullRequestReviewContribution. */\nexport type CreatedPullRequestReviewContributionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedPullRequestReviewContributionEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedPullRequestReviewContribution>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type CreatedPullRequestReviewContributionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedPullRequestReviewContribution>\n}\n\n/** Represents the contribution a user made on GitHub by creating a repository. */\nexport type CreatedRepositoryContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']\n  /** The repository that was created. */\n  repository: Repository\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']\n  /** The user who made this contribution. */\n  user: User\n}\n\n/** The connection type for CreatedRepositoryContribution. */\nexport type CreatedRepositoryContributionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedRepositoryContributionEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedRepositoryContribution>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type CreatedRepositoryContributionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedRepositoryContribution>\n}\n\n/** Represents either a repository the viewer can access or a restricted contribution. */\nexport type CreatedRepositoryOrRestrictedContribution =\n  | CreatedRepositoryContribution\n  | RestrictedContribution\n\n/** Represents a mention made by one issue or pull request to another. */\nexport type CrossReferencedEvent = Node &\n  UniformResourceLocatable & {\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    id: Scalars['ID']\n    /** Reference originated in a different repository. */\n    isCrossRepository: Scalars['Boolean']\n    /** Identifies when the reference was made. */\n    referencedAt: Scalars['DateTime']\n    /** The HTTP path for this pull request. */\n    resourcePath: Scalars['URI']\n    /** Issue or pull request that made the reference. */\n    source: ReferencedSubject\n    /** Issue or pull request to which the reference was made. */\n    target: ReferencedSubject\n    /** The HTTP URL for this pull request. */\n    url: Scalars['URI']\n    /** Checks if the target will be closed when the source is merged. */\n    willCloseTarget: Scalars['Boolean']\n  }\n\n/** Autogenerated input type of DeclineTopicSuggestion */\nexport type DeclineTopicSuggestionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The name of the suggested topic. */\n  name: Scalars['String']\n  /** The reason why the suggested topic is declined. */\n  reason: TopicSuggestionDeclineReason\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of DeclineTopicSuggestion */\nexport type DeclineTopicSuggestionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The declined topic. */\n  topic?: Maybe<Topic>\n}\n\n/** The possible base permissions for repositories. */\nexport enum DefaultRepositoryPermissionField {\n  /** Can read, write, and administrate repos by default */\n  Admin = 'ADMIN',\n  /** No access */\n  None = 'NONE',\n  /** Can read repos by default */\n  Read = 'READ',\n  /** Can read and write repos by default */\n  Write = 'WRITE',\n}\n\n/** Entities that can be deleted. */\nexport type Deletable = {\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean']\n}\n\n/** Autogenerated input type of DeleteBranchProtectionRule */\nexport type DeleteBranchProtectionRuleInput = {\n  /** The global relay id of the branch protection rule to be deleted. */\n  branchProtectionRuleId: Scalars['ID']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of DeleteBranchProtectionRule */\nexport type DeleteBranchProtectionRulePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of DeleteDeployment */\nexport type DeleteDeploymentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the deployment to be deleted. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteDeployment */\nexport type DeleteDeploymentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of DeleteDiscussionComment */\nexport type DeleteDiscussionCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node id of the discussion comment to delete. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteDiscussionComment */\nexport type DeleteDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The discussion comment that was just deleted. */\n  comment?: Maybe<DiscussionComment>\n}\n\n/** Autogenerated input type of DeleteDiscussion */\nexport type DeleteDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The id of the discussion to delete. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteDiscussion */\nexport type DeleteDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The discussion that was just deleted. */\n  discussion?: Maybe<Discussion>\n}\n\n/** Autogenerated input type of DeleteEnvironment */\nexport type DeleteEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the environment to be deleted. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteEnvironment */\nexport type DeleteEnvironmentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of DeleteIpAllowListEntry */\nexport type DeleteIpAllowListEntryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the IP allow list entry to delete. */\n  ipAllowListEntryId: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteIpAllowListEntry */\nexport type DeleteIpAllowListEntryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The IP allow list entry that was deleted. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>\n}\n\n/** Autogenerated input type of DeleteIssueComment */\nexport type DeleteIssueCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the comment to delete. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteIssueComment */\nexport type DeleteIssueCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of DeleteIssue */\nexport type DeleteIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the issue to delete. */\n  issueId: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteIssue */\nexport type DeleteIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The repository the issue belonged to */\n  repository?: Maybe<Repository>\n}\n\n/** Autogenerated input type of DeleteLabel */\nexport type DeleteLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the label to be deleted. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteLabel */\nexport type DeleteLabelPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of DeletePackageVersion */\nexport type DeletePackageVersionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the package version to be deleted. */\n  packageVersionId: Scalars['ID']\n}\n\n/** Autogenerated return type of DeletePackageVersion */\nexport type DeletePackageVersionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Whether or not the operation succeeded. */\n  success?: Maybe<Scalars['Boolean']>\n}\n\n/** Autogenerated input type of DeleteProjectCard */\nexport type DeleteProjectCardInput = {\n  /** The id of the card to delete. */\n  cardId: Scalars['ID']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of DeleteProjectCard */\nexport type DeleteProjectCardPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The column the deleted card was in. */\n  column?: Maybe<ProjectColumn>\n  /** The deleted card ID. */\n  deletedCardId?: Maybe<Scalars['ID']>\n}\n\n/** Autogenerated input type of DeleteProjectColumn */\nexport type DeleteProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The id of the column to delete. */\n  columnId: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteProjectColumn */\nexport type DeleteProjectColumnPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The deleted column ID. */\n  deletedColumnId?: Maybe<Scalars['ID']>\n  /** The project the deleted column was in. */\n  project?: Maybe<Project>\n}\n\n/** Autogenerated input type of DeleteProject */\nexport type DeleteProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Project ID to update. */\n  projectId: Scalars['ID']\n}\n\n/** Autogenerated input type of DeleteProjectNextItem */\nexport type DeleteProjectNextItemInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the item to be removed. */\n  itemId: Scalars['ID']\n  /** The ID of the Project from which the item should be removed. */\n  projectId: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteProjectNextItem */\nexport type DeleteProjectNextItemPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the deleted item. */\n  deletedItemId?: Maybe<Scalars['ID']>\n}\n\n/** Autogenerated return type of DeleteProject */\nexport type DeleteProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The repository or organization the project was removed from. */\n  owner?: Maybe<ProjectOwner>\n}\n\n/** Autogenerated input type of DeletePullRequestReviewComment */\nexport type DeletePullRequestReviewCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the comment to delete. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of DeletePullRequestReviewComment */\nexport type DeletePullRequestReviewCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The pull request review the deleted comment belonged to. */\n  pullRequestReview?: Maybe<PullRequestReview>\n}\n\n/** Autogenerated input type of DeletePullRequestReview */\nexport type DeletePullRequestReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the pull request review to delete. */\n  pullRequestReviewId: Scalars['ID']\n}\n\n/** Autogenerated return type of DeletePullRequestReview */\nexport type DeletePullRequestReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The deleted pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>\n}\n\n/** Autogenerated input type of DeleteRef */\nexport type DeleteRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the Ref to be deleted. */\n  refId: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteRef */\nexport type DeleteRefPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of DeleteTeamDiscussionComment */\nexport type DeleteTeamDiscussionCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the comment to delete. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteTeamDiscussionComment */\nexport type DeleteTeamDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of DeleteTeamDiscussion */\nexport type DeleteTeamDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The discussion ID to delete. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteTeamDiscussion */\nexport type DeleteTeamDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of DeleteVerifiableDomain */\nexport type DeleteVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the verifiable domain to delete. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of DeleteVerifiableDomain */\nexport type DeleteVerifiableDomainPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The owning account from which the domain was deleted. */\n  owner?: Maybe<VerifiableDomainOwner>\n}\n\n/** Represents a 'demilestoned' event on a given issue or pull request. */\nexport type DemilestonedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Identifies the milestone title associated with the 'demilestoned' event. */\n  milestoneTitle: Scalars['String']\n  /** Object referenced by event. */\n  subject: MilestoneItem\n}\n\n/** A dependency manifest entry */\nexport type DependencyGraphDependency = {\n  /** Does the dependency itself have dependencies? */\n  hasDependencies: Scalars['Boolean']\n  /** The original name of the package, as it appears in the manifest. */\n  packageLabel: Scalars['String']\n  /** The dependency package manager */\n  packageManager?: Maybe<Scalars['String']>\n  /**\n   * The name of the package in the canonical form used by the package manager.\n   * This may differ from the original textual form (see packageLabel), for example\n   * in a package manager that uses case-insensitive comparisons.\n   */\n  packageName: Scalars['String']\n  /** The repository containing the package */\n  repository?: Maybe<Repository>\n  /** The dependency version requirements */\n  requirements: Scalars['String']\n}\n\n/** The connection type for DependencyGraphDependency. */\nexport type DependencyGraphDependencyConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DependencyGraphDependencyEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DependencyGraphDependency>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DependencyGraphDependencyEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<DependencyGraphDependency>\n}\n\n/** Dependency manifest for a repository */\nexport type DependencyGraphManifest = Node & {\n  /** Path to view the manifest file blob */\n  blobPath: Scalars['String']\n  /** A list of manifest dependencies */\n  dependencies?: Maybe<DependencyGraphDependencyConnection>\n  /** The number of dependencies listed in the manifest */\n  dependenciesCount?: Maybe<Scalars['Int']>\n  /** Is the manifest too big to parse? */\n  exceedsMaxSize: Scalars['Boolean']\n  /** Fully qualified manifest filename */\n  filename: Scalars['String']\n  id: Scalars['ID']\n  /** Were we able to parse the manifest? */\n  parseable: Scalars['Boolean']\n  /** The repository containing the manifest */\n  repository: Repository\n}\n\n/** Dependency manifest for a repository */\nexport type DependencyGraphManifestDependenciesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for DependencyGraphManifest. */\nexport type DependencyGraphManifestConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DependencyGraphManifestEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DependencyGraphManifest>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DependencyGraphManifestEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<DependencyGraphManifest>\n}\n\n/** A repository deploy key. */\nexport type DeployKey = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** The deploy key. */\n  key: Scalars['String']\n  /** Whether or not the deploy key is read only. */\n  readOnly: Scalars['Boolean']\n  /** The deploy key title. */\n  title: Scalars['String']\n  /** Whether or not the deploy key has been verified. */\n  verified: Scalars['Boolean']\n}\n\n/** The connection type for DeployKey. */\nexport type DeployKeyConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeployKeyEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeployKey>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DeployKeyEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<DeployKey>\n}\n\n/** Represents a 'deployed' event on a given pull request. */\nexport type DeployedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** The deployment associated with the 'deployed' event. */\n  deployment: Deployment\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n  /** The ref associated with the 'deployed' event. */\n  ref?: Maybe<Ref>\n}\n\n/** Represents triggered deployment instance. */\nexport type Deployment = Node & {\n  /** Identifies the commit sha of the deployment. */\n  commit?: Maybe<Commit>\n  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */\n  commitOid: Scalars['String']\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the actor who triggered the deployment. */\n  creator: Actor\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** The deployment description. */\n  description?: Maybe<Scalars['String']>\n  /** The latest environment to which this deployment was made. */\n  environment?: Maybe<Scalars['String']>\n  id: Scalars['ID']\n  /** The latest environment to which this deployment was made. */\n  latestEnvironment?: Maybe<Scalars['String']>\n  /** The latest status of this deployment. */\n  latestStatus?: Maybe<DeploymentStatus>\n  /** The original environment to which this deployment was made. */\n  originalEnvironment?: Maybe<Scalars['String']>\n  /** Extra information that a deployment system might need. */\n  payload?: Maybe<Scalars['String']>\n  /** Identifies the Ref of the deployment, if the deployment was created by ref. */\n  ref?: Maybe<Ref>\n  /** Identifies the repository associated with the deployment. */\n  repository: Repository\n  /** The current state of the deployment. */\n  state?: Maybe<DeploymentState>\n  /** A list of statuses associated with the deployment. */\n  statuses?: Maybe<DeploymentStatusConnection>\n  /** The deployment task. */\n  task?: Maybe<Scalars['String']>\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** Represents triggered deployment instance. */\nexport type DeploymentStatusesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for Deployment. */\nexport type DeploymentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Deployment>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DeploymentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Deployment>\n}\n\n/** Represents a 'deployment_environment_changed' event on a given pull request. */\nexport type DeploymentEnvironmentChangedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The deployment status that updated the deployment environment. */\n  deploymentStatus: DeploymentStatus\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n}\n\n/** Ordering options for deployment connections */\nexport type DeploymentOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order deployments by. */\n  field: DeploymentOrderField\n}\n\n/** Properties by which deployment connections can be ordered. */\nexport enum DeploymentOrderField {\n  /** Order collection by creation time */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** A protection rule. */\nexport type DeploymentProtectionRule = {\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** The teams or users that can review the deployment */\n  reviewers: DeploymentReviewerConnection\n  /** The timeout in minutes for this protection rule. */\n  timeout: Scalars['Int']\n  /** The type of protection rule. */\n  type: DeploymentProtectionRuleType\n}\n\n/** A protection rule. */\nexport type DeploymentProtectionRuleReviewersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for DeploymentProtectionRule. */\nexport type DeploymentProtectionRuleConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentProtectionRuleEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentProtectionRule>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DeploymentProtectionRuleEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentProtectionRule>\n}\n\n/** The possible protection rule types. */\nexport enum DeploymentProtectionRuleType {\n  /** Required reviewers */\n  RequiredReviewers = 'REQUIRED_REVIEWERS',\n  /** Wait timer */\n  WaitTimer = 'WAIT_TIMER',\n}\n\n/** A request to deploy a workflow run to an environment. */\nexport type DeploymentRequest = {\n  /** Whether or not the current user can approve the deployment */\n  currentUserCanApprove: Scalars['Boolean']\n  /** The target environment of the deployment */\n  environment: Environment\n  /** The teams or users that can review the deployment */\n  reviewers: DeploymentReviewerConnection\n  /** The wait timer in minutes configured in the environment */\n  waitTimer: Scalars['Int']\n  /** The wait timer in minutes configured in the environment */\n  waitTimerStartedAt?: Maybe<Scalars['DateTime']>\n}\n\n/** A request to deploy a workflow run to an environment. */\nexport type DeploymentRequestReviewersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for DeploymentRequest. */\nexport type DeploymentRequestConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentRequestEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentRequest>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DeploymentRequestEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentRequest>\n}\n\n/** A deployment review. */\nexport type DeploymentReview = Node & {\n  /** The comment the user left. */\n  comment: Scalars['String']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** The environments approved or rejected */\n  environments: EnvironmentConnection\n  id: Scalars['ID']\n  /** The decision of the user. */\n  state: DeploymentReviewState\n  /** The user that reviewed the deployment. */\n  user: User\n}\n\n/** A deployment review. */\nexport type DeploymentReviewEnvironmentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for DeploymentReview. */\nexport type DeploymentReviewConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentReviewEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentReview>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DeploymentReviewEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentReview>\n}\n\n/** The possible states for a deployment review. */\nexport enum DeploymentReviewState {\n  /** The deployment was approved. */\n  Approved = 'APPROVED',\n  /** The deployment was rejected. */\n  Rejected = 'REJECTED',\n}\n\n/** Users and teams. */\nexport type DeploymentReviewer = Team | User\n\n/** The connection type for DeploymentReviewer. */\nexport type DeploymentReviewerConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentReviewerEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentReviewer>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DeploymentReviewerEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentReviewer>\n}\n\n/** The possible states in which a deployment can be. */\nexport enum DeploymentState {\n  /** The pending deployment was not updated after 30 minutes. */\n  Abandoned = 'ABANDONED',\n  /** The deployment is currently active. */\n  Active = 'ACTIVE',\n  /** An inactive transient deployment. */\n  Destroyed = 'DESTROYED',\n  /** The deployment experienced an error. */\n  Error = 'ERROR',\n  /** The deployment has failed. */\n  Failure = 'FAILURE',\n  /** The deployment is inactive. */\n  Inactive = 'INACTIVE',\n  /** The deployment is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The deployment is pending. */\n  Pending = 'PENDING',\n  /** The deployment has queued */\n  Queued = 'QUEUED',\n  /** The deployment is waiting. */\n  Waiting = 'WAITING',\n}\n\n/** Describes the status of a given deployment attempt. */\nexport type DeploymentStatus = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the actor who triggered the deployment. */\n  creator: Actor\n  /** Identifies the deployment associated with status. */\n  deployment: Deployment\n  /** Identifies the description of the deployment. */\n  description?: Maybe<Scalars['String']>\n  /** Identifies the environment of the deployment at the time of this deployment status */\n  environment?: Maybe<Scalars['String']>\n  /** Identifies the environment URL of the deployment. */\n  environmentUrl?: Maybe<Scalars['URI']>\n  id: Scalars['ID']\n  /** Identifies the log URL of the deployment. */\n  logUrl?: Maybe<Scalars['URI']>\n  /** Identifies the current state of the deployment. */\n  state: DeploymentStatusState\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** The connection type for DeploymentStatus. */\nexport type DeploymentStatusConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentStatusEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentStatus>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DeploymentStatusEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentStatus>\n}\n\n/** The possible states for a deployment status. */\nexport enum DeploymentStatusState {\n  /** The deployment experienced an error. */\n  Error = 'ERROR',\n  /** The deployment has failed. */\n  Failure = 'FAILURE',\n  /** The deployment is inactive. */\n  Inactive = 'INACTIVE',\n  /** The deployment is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The deployment is pending. */\n  Pending = 'PENDING',\n  /** The deployment is queued */\n  Queued = 'QUEUED',\n  /** The deployment was successful. */\n  Success = 'SUCCESS',\n  /** The deployment is waiting. */\n  Waiting = 'WAITING',\n}\n\n/** The possible sides of a diff. */\nexport enum DiffSide {\n  /** The left side of the diff. */\n  Left = 'LEFT',\n  /** The right side of the diff. */\n  Right = 'RIGHT',\n}\n\n/** Autogenerated input type of DisablePullRequestAutoMerge */\nexport type DisablePullRequestAutoMergeInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the pull request to disable auto merge on. */\n  pullRequestId: Scalars['ID']\n}\n\n/** Autogenerated return type of DisablePullRequestAutoMerge */\nexport type DisablePullRequestAutoMergePayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The pull request auto merge was disabled on. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Represents a 'disconnected' event on a given issue or pull request. */\nexport type DisconnectedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean']\n  /** Issue or pull request from which the issue was disconnected. */\n  source: ReferencedSubject\n  /** Issue or pull request which was disconnected. */\n  subject: ReferencedSubject\n}\n\n/** A discussion in a repository. */\nexport type Discussion = Comment &\n  Deletable &\n  Labelable &\n  Lockable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Subscribable &\n  Updatable &\n  Votable & {\n    /** Reason that the conversation was locked. */\n    activeLockReason?: Maybe<LockReason>\n    /** The comment chosen as this discussion's answer, if any. */\n    answer?: Maybe<DiscussionComment>\n    /** The time when a user chose this discussion's answer, if answered. */\n    answerChosenAt?: Maybe<Scalars['DateTime']>\n    /** The user who chose this discussion's answer, if answered. */\n    answerChosenBy?: Maybe<Actor>\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation\n    /** The main text of the discussion post. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The body rendered to text. */\n    bodyText: Scalars['String']\n    /** The category for this discussion. */\n    category: DiscussionCategory\n    /** The replies to the discussion. */\n    comments: DiscussionCommentConnection\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** A list of labels associated with the object. */\n    labels?: Maybe<LabelConnection>\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** `true` if the object is locked */\n    locked: Scalars['Boolean']\n    /** The number identifying this discussion within the repository. */\n    number: Scalars['Int']\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** The repository associated with this node. */\n    repository: Repository\n    /** The path for this discussion. */\n    resourcePath: Scalars['URI']\n    /** The title of this discussion. */\n    title: Scalars['String']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** Number of upvotes that this subject has received. */\n    upvoteCount: Scalars['Int']\n    /** The URL for this discussion. */\n    url: Scalars['URI']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars['Boolean']\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Whether or not the current user can add or remove an upvote on this subject. */\n    viewerCanUpvote: Scalars['Boolean']\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n    /** Whether or not the current user has already upvoted this subject. */\n    viewerHasUpvoted: Scalars['Boolean']\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>\n  }\n\n/** A discussion in a repository. */\nexport type DiscussionCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A discussion in a repository. */\nexport type DiscussionLabelsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<LabelOrder>\n}\n\n/** A discussion in a repository. */\nexport type DiscussionReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** A discussion in a repository. */\nexport type DiscussionUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A category for discussions in a repository. */\nexport type DiscussionCategory = Node &\n  RepositoryNode & {\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** A description of this category. */\n    description?: Maybe<Scalars['String']>\n    /** An emoji representing this category. */\n    emoji: Scalars['String']\n    /** This category's emoji rendered as HTML. */\n    emojiHTML: Scalars['HTML']\n    id: Scalars['ID']\n    /** Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation. */\n    isAnswerable: Scalars['Boolean']\n    /** The name of this category. */\n    name: Scalars['String']\n    /** The repository associated with this node. */\n    repository: Repository\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n  }\n\n/** The connection type for DiscussionCategory. */\nexport type DiscussionCategoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionCategoryEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DiscussionCategory>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DiscussionCategoryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<DiscussionCategory>\n}\n\n/** A comment on a discussion. */\nexport type DiscussionComment = Comment &\n  Deletable &\n  Minimizable &\n  Node &\n  Reactable &\n  Updatable &\n  UpdatableComment &\n  Votable & {\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation\n    /** The body as Markdown. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The body rendered to text. */\n    bodyText: Scalars['String']\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The time when this replied-to comment was deleted */\n    deletedAt?: Maybe<Scalars['DateTime']>\n    /** The discussion this comment was created in */\n    discussion?: Maybe<Discussion>\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** Has this comment been chosen as the answer of its discussion? */\n    isAnswer: Scalars['Boolean']\n    /** Returns whether or not a comment has been minimized. */\n    isMinimized: Scalars['Boolean']\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** Returns why the comment was minimized. */\n    minimizedReason?: Maybe<Scalars['String']>\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** The threaded replies to this comment. */\n    replies: DiscussionCommentConnection\n    /** The discussion comment this comment is a reply to */\n    replyTo?: Maybe<DiscussionComment>\n    /** The path for this discussion comment. */\n    resourcePath: Scalars['URI']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** Number of upvotes that this subject has received. */\n    upvoteCount: Scalars['Int']\n    /** The URL for this discussion comment. */\n    url: Scalars['URI']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars['Boolean']\n    /** Can the current user mark this comment as an answer? */\n    viewerCanMarkAsAnswer: Scalars['Boolean']\n    /** Check if the current viewer can minimize this object. */\n    viewerCanMinimize: Scalars['Boolean']\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n    /** Can the current user unmark this comment as an answer? */\n    viewerCanUnmarkAsAnswer: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Whether or not the current user can add or remove an upvote on this subject. */\n    viewerCanUpvote: Scalars['Boolean']\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n    /** Whether or not the current user has already upvoted this subject. */\n    viewerHasUpvoted: Scalars['Boolean']\n  }\n\n/** A comment on a discussion. */\nexport type DiscussionCommentReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** A comment on a discussion. */\nexport type DiscussionCommentRepliesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A comment on a discussion. */\nexport type DiscussionCommentUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for DiscussionComment. */\nexport type DiscussionCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionCommentEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DiscussionComment>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DiscussionCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<DiscussionComment>\n}\n\n/** The connection type for Discussion. */\nexport type DiscussionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Discussion>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type DiscussionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Discussion>\n}\n\n/** Ways in which lists of discussions can be ordered upon return. */\nexport type DiscussionOrder = {\n  /** The direction in which to order discussions by the specified field. */\n  direction: OrderDirection\n  /** The field by which to order discussions. */\n  field: DiscussionOrderField\n}\n\n/** Properties by which discussion connections can be ordered. */\nexport enum DiscussionOrderField {\n  /** Order discussions by creation time. */\n  CreatedAt = 'CREATED_AT',\n  /** Order discussions by most recent modification time. */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** Autogenerated input type of DismissPullRequestReview */\nexport type DismissPullRequestReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The contents of the pull request review dismissal message. */\n  message: Scalars['String']\n  /** The Node ID of the pull request review to modify. */\n  pullRequestReviewId: Scalars['ID']\n}\n\n/** Autogenerated return type of DismissPullRequestReview */\nexport type DismissPullRequestReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The dismissed pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>\n}\n\n/** The possible reasons that a Dependabot alert was dismissed. */\nexport enum DismissReason {\n  /** A fix has already been started */\n  FixStarted = 'FIX_STARTED',\n  /** This alert is inaccurate or incorrect */\n  Inaccurate = 'INACCURATE',\n  /** Vulnerable code is not actually used */\n  NotUsed = 'NOT_USED',\n  /** No bandwidth to fix this */\n  NoBandwidth = 'NO_BANDWIDTH',\n  /** Risk is tolerable to this project */\n  TolerableRisk = 'TOLERABLE_RISK',\n}\n\n/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */\nexport type DismissRepositoryVulnerabilityAlertInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The reason the Dependabot alert is being dismissed. */\n  dismissReason: DismissReason\n  /** The Dependabot alert ID to dismiss. */\n  repositoryVulnerabilityAlertId: Scalars['ID']\n}\n\n/** Autogenerated return type of DismissRepositoryVulnerabilityAlert */\nexport type DismissRepositoryVulnerabilityAlertPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Dependabot alert that was dismissed */\n  repositoryVulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>\n}\n\n/** Specifies a review comment to be left with a Pull Request Review. */\nexport type DraftPullRequestReviewComment = {\n  /** Body of the comment to leave. */\n  body: Scalars['String']\n  /** Path to the file being commented on. */\n  path: Scalars['String']\n  /** Position in the file to leave a comment on. */\n  position: Scalars['Int']\n}\n\n/** Specifies a review comment thread to be left with a Pull Request Review. */\nexport type DraftPullRequestReviewThread = {\n  /** Body of the comment to leave. */\n  body: Scalars['String']\n  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */\n  line: Scalars['Int']\n  /** Path to the file being commented on. */\n  path: Scalars['String']\n  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */\n  side?: Maybe<DiffSide>\n  /** The first line of the range to which the comment refers. */\n  startLine?: Maybe<Scalars['Int']>\n  /** The side of the diff on which the start line resides. */\n  startSide?: Maybe<DiffSide>\n}\n\n/** Autogenerated input type of EnablePullRequestAutoMerge */\nexport type EnablePullRequestAutoMergeInput = {\n  /** The email address to associate with this merge. */\n  authorEmail?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Commit body to use for the commit when the PR is mergable; if omitted, a default message will be used. */\n  commitBody?: Maybe<Scalars['String']>\n  /** Commit headline to use for the commit when the PR is mergable; if omitted, a default message will be used. */\n  commitHeadline?: Maybe<Scalars['String']>\n  /** The merge method to use. If omitted, defaults to 'MERGE' */\n  mergeMethod?: Maybe<PullRequestMergeMethod>\n  /** ID of the pull request to enable auto-merge on. */\n  pullRequestId: Scalars['ID']\n}\n\n/** Autogenerated return type of EnablePullRequestAutoMerge */\nexport type EnablePullRequestAutoMergePayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The pull request auto-merge was enabled on. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type Enterprise = Node & {\n  /** A URL pointing to the enterprise's public avatar. */\n  avatarUrl: Scalars['URI']\n  /** Enterprise billing information visible to enterprise billing managers. */\n  billingInfo?: Maybe<EnterpriseBillingInfo>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** The description of the enterprise. */\n  description?: Maybe<Scalars['String']>\n  /** The description of the enterprise as HTML. */\n  descriptionHTML: Scalars['HTML']\n  id: Scalars['ID']\n  /** The location of the enterprise. */\n  location?: Maybe<Scalars['String']>\n  /** A list of users who are members of this enterprise. */\n  members: EnterpriseMemberConnection\n  /** The name of the enterprise. */\n  name: Scalars['String']\n  /** A list of organizations that belong to this enterprise. */\n  organizations: OrganizationConnection\n  /** Enterprise information only visible to enterprise owners. */\n  ownerInfo?: Maybe<EnterpriseOwnerInfo>\n  /** The HTTP path for this enterprise. */\n  resourcePath: Scalars['URI']\n  /** The URL-friendly identifier for the enterprise. */\n  slug: Scalars['String']\n  /** The HTTP URL for this enterprise. */\n  url: Scalars['URI']\n  /** A list of user accounts on this enterprise. */\n  userAccounts: EnterpriseUserAccountConnection\n  /** Is the current viewer an admin of this enterprise? */\n  viewerIsAdmin: Scalars['Boolean']\n  /** The URL of the enterprise website. */\n  websiteUrl?: Maybe<Scalars['URI']>\n}\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseMembersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  deployment?: Maybe<EnterpriseUserDeployment>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<EnterpriseMemberOrder>\n  organizationLogins?: Maybe<Array<Scalars['String']>>\n  query?: Maybe<Scalars['String']>\n  role?: Maybe<EnterpriseUserAccountMembershipRole>\n}\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  query?: Maybe<Scalars['String']>\n}\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseUserAccountsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for User. */\nexport type EnterpriseAdministratorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseAdministratorEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** A User who is an administrator of an enterprise. */\nexport type EnterpriseAdministratorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<User>\n  /** The role of the administrator. */\n  role: EnterpriseAdministratorRole\n}\n\n/** An invitation for a user to become an owner or billing manager of an enterprise. */\nexport type EnterpriseAdministratorInvitation = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The email of the person who was invited to the enterprise. */\n  email?: Maybe<Scalars['String']>\n  /** The enterprise the invitation is for. */\n  enterprise: Enterprise\n  id: Scalars['ID']\n  /** The user who was invited to the enterprise. */\n  invitee?: Maybe<User>\n  /** The user who created the invitation. */\n  inviter?: Maybe<User>\n  /** The invitee's pending role in the enterprise (owner or billing_manager). */\n  role: EnterpriseAdministratorRole\n}\n\n/** The connection type for EnterpriseAdministratorInvitation. */\nexport type EnterpriseAdministratorInvitationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseAdministratorInvitationEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseAdministratorInvitation>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type EnterpriseAdministratorInvitationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseAdministratorInvitation>\n}\n\n/** Ordering options for enterprise administrator invitation connections */\nexport type EnterpriseAdministratorInvitationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order enterprise administrator invitations by. */\n  field: EnterpriseAdministratorInvitationOrderField\n}\n\n/** Properties by which enterprise administrator invitation connections can be ordered. */\nexport enum EnterpriseAdministratorInvitationOrderField {\n  /** Order enterprise administrator member invitations by creation time */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** The possible administrator roles in an enterprise account. */\nexport enum EnterpriseAdministratorRole {\n  /** Represents a billing manager of the enterprise account. */\n  BillingManager = 'BILLING_MANAGER',\n  /** Represents an owner of the enterprise account. */\n  Owner = 'OWNER',\n}\n\n/** Metadata for an audit entry containing enterprise account information. */\nexport type EnterpriseAuditEntryData = {\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']>\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']>\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']>\n}\n\n/** Enterprise billing information visible to enterprise billing managers and owners. */\nexport type EnterpriseBillingInfo = {\n  /** The number of licenseable users/emails across the enterprise. */\n  allLicensableUsersCount: Scalars['Int']\n  /** The number of data packs used by all organizations owned by the enterprise. */\n  assetPacks: Scalars['Int']\n  /**\n   * The number of available seats across all owned organizations based on the unique number of billable users.\n   * @deprecated `availableSeats` will be replaced with `totalAvailableLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalAvailableLicenses instead. Removal on 2020-01-01 UTC.\n   */\n  availableSeats: Scalars['Int']\n  /** The bandwidth quota in GB for all organizations owned by the enterprise. */\n  bandwidthQuota: Scalars['Float']\n  /** The bandwidth usage in GB for all organizations owned by the enterprise. */\n  bandwidthUsage: Scalars['Float']\n  /** The bandwidth usage as a percentage of the bandwidth quota. */\n  bandwidthUsagePercentage: Scalars['Int']\n  /**\n   * The total seats across all organizations owned by the enterprise.\n   * @deprecated `seats` will be replaced with `totalLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalLicenses instead. Removal on 2020-01-01 UTC.\n   */\n  seats: Scalars['Int']\n  /** The storage quota in GB for all organizations owned by the enterprise. */\n  storageQuota: Scalars['Float']\n  /** The storage usage in GB for all organizations owned by the enterprise. */\n  storageUsage: Scalars['Float']\n  /** The storage usage as a percentage of the storage quota. */\n  storageUsagePercentage: Scalars['Int']\n  /** The number of available licenses across all owned organizations based on the unique number of billable users. */\n  totalAvailableLicenses: Scalars['Int']\n  /** The total number of licenses allocated. */\n  totalLicenses: Scalars['Int']\n}\n\n/** The possible values for the enterprise base repository permission setting. */\nexport enum EnterpriseDefaultRepositoryPermissionSettingValue {\n  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */\n  Admin = 'ADMIN',\n  /** Organization members will only be able to clone and pull public repositories. */\n  None = 'NONE',\n  /** Organizations in the enterprise choose base repository permissions for their members. */\n  NoPolicy = 'NO_POLICY',\n  /** Organization members will be able to clone and pull all organization repositories. */\n  Read = 'READ',\n  /** Organization members will be able to clone, pull, and push all organization repositories. */\n  Write = 'WRITE',\n}\n\n/** The possible values for an enabled/disabled enterprise setting. */\nexport enum EnterpriseEnabledDisabledSettingValue {\n  /** The setting is disabled for organizations in the enterprise. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED',\n  /** There is no policy set for organizations in the enterprise. */\n  NoPolicy = 'NO_POLICY',\n}\n\n/** The possible values for an enabled/no policy enterprise setting. */\nexport enum EnterpriseEnabledSettingValue {\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED',\n  /** There is no policy set for organizations in the enterprise. */\n  NoPolicy = 'NO_POLICY',\n}\n\n/** An identity provider configured to provision identities for an enterprise. */\nexport type EnterpriseIdentityProvider = Node & {\n  /** The digest algorithm used to sign SAML requests for the identity provider. */\n  digestMethod?: Maybe<SamlDigestAlgorithm>\n  /** The enterprise this identity provider belongs to. */\n  enterprise?: Maybe<Enterprise>\n  /** ExternalIdentities provisioned by this identity provider. */\n  externalIdentities: ExternalIdentityConnection\n  id: Scalars['ID']\n  /** The x509 certificate used by the identity provider to sign assertions and responses. */\n  idpCertificate?: Maybe<Scalars['X509Certificate']>\n  /** The Issuer Entity ID for the SAML identity provider. */\n  issuer?: Maybe<Scalars['String']>\n  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */\n  recoveryCodes?: Maybe<Array<Scalars['String']>>\n  /** The signature algorithm used to sign SAML requests for the identity provider. */\n  signatureMethod?: Maybe<SamlSignatureAlgorithm>\n  /** The URL endpoint for the identity provider's SAML SSO. */\n  ssoUrl?: Maybe<Scalars['URI']>\n}\n\n/** An identity provider configured to provision identities for an enterprise. */\nexport type EnterpriseIdentityProviderExternalIdentitiesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  membersOnly?: Maybe<Scalars['Boolean']>\n}\n\n/** An object that is a member of an enterprise. */\nexport type EnterpriseMember = EnterpriseUserAccount | User\n\n/** The connection type for EnterpriseMember. */\nexport type EnterpriseMemberConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseMemberEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseMember>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** A User who is a member of an enterprise through one or more organizations. */\nexport type EnterpriseMemberEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /**\n   * Whether the user does not have a license for the enterprise.\n   * @deprecated All members consume a license Removal on 2021-01-01 UTC.\n   */\n  isUnlicensed: Scalars['Boolean']\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseMember>\n}\n\n/** Ordering options for enterprise member connections. */\nexport type EnterpriseMemberOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order enterprise members by. */\n  field: EnterpriseMemberOrderField\n}\n\n/** Properties by which enterprise member connections can be ordered. */\nexport enum EnterpriseMemberOrderField {\n  /** Order enterprise members by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order enterprise members by login */\n  Login = 'LOGIN',\n}\n\n/** The possible values for the enterprise members can create repositories setting. */\nexport enum EnterpriseMembersCanCreateRepositoriesSettingValue {\n  /** Members will be able to create public and private repositories. */\n  All = 'ALL',\n  /** Members will not be able to create public or private repositories. */\n  Disabled = 'DISABLED',\n  /** Organization administrators choose whether to allow members to create repositories. */\n  NoPolicy = 'NO_POLICY',\n  /** Members will be able to create only private repositories. */\n  Private = 'PRIVATE',\n  /** Members will be able to create only public repositories. */\n  Public = 'PUBLIC',\n}\n\n/** The possible values for the members can make purchases setting. */\nexport enum EnterpriseMembersCanMakePurchasesSettingValue {\n  /** The setting is disabled for organizations in the enterprise. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED',\n}\n\n/** The connection type for Organization. */\nexport type EnterpriseOrganizationMembershipConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseOrganizationMembershipEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Organization>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An enterprise organization that a user is a member of. */\nexport type EnterpriseOrganizationMembershipEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Organization>\n  /** The role of the user in the enterprise membership. */\n  role: EnterpriseUserAccountMembershipRole\n}\n\n/** The connection type for User. */\nexport type EnterpriseOutsideCollaboratorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseOutsideCollaboratorEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** A User who is an outside collaborator of an enterprise through one or more organizations. */\nexport type EnterpriseOutsideCollaboratorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /**\n   * Whether the outside collaborator does not have a license for the enterprise.\n   * @deprecated All outside collaborators consume a license Removal on 2021-01-01 UTC.\n   */\n  isUnlicensed: Scalars['Boolean']\n  /** The item at the end of the edge. */\n  node?: Maybe<User>\n  /** The enterprise organization repositories this user is a member of. */\n  repositories: EnterpriseRepositoryInfoConnection\n}\n\n/** A User who is an outside collaborator of an enterprise through one or more organizations. */\nexport type EnterpriseOutsideCollaboratorEdgeRepositoriesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryOrder>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfo = {\n  /** A list of all of the administrators for this enterprise. */\n  admins: EnterpriseAdministratorConnection\n  /** A list of users in the enterprise who currently have two-factor authentication disabled. */\n  affiliatedUsersWithTwoFactorDisabled: UserConnection\n  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */\n  affiliatedUsersWithTwoFactorDisabledExist: Scalars['Boolean']\n  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */\n  allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue\n  /** A list of enterprise organizations configured with the provided private repository forking setting value. */\n  allowPrivateRepositoryForkingSettingOrganizations: OrganizationConnection\n  /** The setting value for base repository permissions for organizations in this enterprise. */\n  defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue\n  /** A list of enterprise organizations configured with the provided base repository permission. */\n  defaultRepositoryPermissionSettingOrganizations: OrganizationConnection\n  /** A list of domains owned by the enterprise. */\n  domains: VerifiableDomainConnection\n  /** Enterprise Server installations owned by the enterprise. */\n  enterpriseServerInstallations: EnterpriseServerInstallationConnection\n  /** The setting value for whether the enterprise has an IP allow list enabled. */\n  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue\n  /** The IP addresses that are allowed to access resources owned by the enterprise. */\n  ipAllowListEntries: IpAllowListEntryConnection\n  /** The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled. */\n  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue\n  /** Whether or not the base repository permission is currently being updated. */\n  isUpdatingDefaultRepositoryPermission: Scalars['Boolean']\n  /** Whether the two-factor authentication requirement is currently being enforced. */\n  isUpdatingTwoFactorRequirement: Scalars['Boolean']\n  /**\n   * The setting value for whether organization members with admin permissions on a\n   * repository can change repository visibility.\n   */\n  membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue\n  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */\n  membersCanChangeRepositoryVisibilitySettingOrganizations: OrganizationConnection\n  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */\n  membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars['Boolean']>\n  /** The setting value for whether members of organizations in the enterprise can create private repositories. */\n  membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars['Boolean']>\n  /** The setting value for whether members of organizations in the enterprise can create public repositories. */\n  membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars['Boolean']>\n  /** The setting value for whether members of organizations in the enterprise can create repositories. */\n  membersCanCreateRepositoriesSetting?: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>\n  /** A list of enterprise organizations configured with the provided repository creation setting value. */\n  membersCanCreateRepositoriesSettingOrganizations: OrganizationConnection\n  /** The setting value for whether members with admin permissions for repositories can delete issues. */\n  membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue\n  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */\n  membersCanDeleteIssuesSettingOrganizations: OrganizationConnection\n  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */\n  membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue\n  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */\n  membersCanDeleteRepositoriesSettingOrganizations: OrganizationConnection\n  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */\n  membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue\n  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */\n  membersCanInviteCollaboratorsSettingOrganizations: OrganizationConnection\n  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */\n  membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue\n  /** The setting value for whether members with admin permissions for repositories can update protected branches. */\n  membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue\n  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */\n  membersCanUpdateProtectedBranchesSettingOrganizations: OrganizationConnection\n  /** The setting value for whether members can view dependency insights. */\n  membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue\n  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */\n  membersCanViewDependencyInsightsSettingOrganizations: OrganizationConnection\n  /** Indicates if email notification delivery for this enterprise is restricted to verified or approved domains. */\n  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue\n  /** The OIDC Identity Provider for the enterprise. */\n  oidcProvider?: Maybe<OidcProvider>\n  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */\n  organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue\n  /** A list of enterprise organizations configured with the provided organization projects setting value. */\n  organizationProjectsSettingOrganizations: OrganizationConnection\n  /** A list of outside collaborators across the repositories in the enterprise. */\n  outsideCollaborators: EnterpriseOutsideCollaboratorConnection\n  /** A list of pending administrator invitations for the enterprise. */\n  pendingAdminInvitations: EnterpriseAdministratorInvitationConnection\n  /** A list of pending collaborator invitations across the repositories in the enterprise. */\n  pendingCollaboratorInvitations: RepositoryInvitationConnection\n  /**\n   * A list of pending collaborators across the repositories in the enterprise.\n   * @deprecated Repository invitations can now be associated with an email, not only an invitee. Use the `pendingCollaboratorInvitations` field instead. Removal on 2020-10-01 UTC.\n   */\n  pendingCollaborators: EnterprisePendingCollaboratorConnection\n  /** A list of pending member invitations for organizations in the enterprise. */\n  pendingMemberInvitations: EnterprisePendingMemberInvitationConnection\n  /** The setting value for whether repository projects are enabled in this enterprise. */\n  repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue\n  /** A list of enterprise organizations configured with the provided repository projects setting value. */\n  repositoryProjectsSettingOrganizations: OrganizationConnection\n  /** The SAML Identity Provider for the enterprise. */\n  samlIdentityProvider?: Maybe<EnterpriseIdentityProvider>\n  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */\n  samlIdentityProviderSettingOrganizations: OrganizationConnection\n  /** A list of members with a support entitlement. */\n  supportEntitlements: EnterpriseMemberConnection\n  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */\n  teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue\n  /** A list of enterprise organizations configured with the provided team discussions setting value. */\n  teamDiscussionsSettingOrganizations: OrganizationConnection\n  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */\n  twoFactorRequiredSetting: EnterpriseEnabledSettingValue\n  /** A list of enterprise organizations configured with the two-factor authentication setting value. */\n  twoFactorRequiredSettingOrganizations: OrganizationConnection\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoAdminsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<EnterpriseMemberOrder>\n  query?: Maybe<Scalars['String']>\n  role?: Maybe<EnterpriseAdministratorRole>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: DefaultRepositoryPermissionField\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoDomainsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  isApproved?: Maybe<Scalars['Boolean']>\n  isVerified?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<VerifiableDomainOrder>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoEnterpriseServerInstallationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  connectedOnly?: Maybe<Scalars['Boolean']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<EnterpriseServerInstallationOrder>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoIpAllowListEntriesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IpAllowListEntryOrder>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: OrganizationMembersCanCreateRepositoriesSettingValue\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoOutsideCollaboratorsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  login?: Maybe<Scalars['String']>\n  orderBy?: Maybe<EnterpriseMemberOrder>\n  query?: Maybe<Scalars['String']>\n  visibility?: Maybe<RepositoryVisibility>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoPendingAdminInvitationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<EnterpriseAdministratorInvitationOrder>\n  query?: Maybe<Scalars['String']>\n  role?: Maybe<EnterpriseAdministratorRole>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoPendingCollaboratorInvitationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryInvitationOrder>\n  query?: Maybe<Scalars['String']>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoPendingCollaboratorsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryInvitationOrder>\n  query?: Maybe<Scalars['String']>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoPendingMemberInvitationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  query?: Maybe<Scalars['String']>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: IdentityProviderConfigurationState\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoSupportEntitlementsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<EnterpriseMemberOrder>\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** Enterprise information only visible to enterprise owners. */\nexport type EnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  value: Scalars['Boolean']\n}\n\n/** The connection type for User. */\nexport type EnterprisePendingCollaboratorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterprisePendingCollaboratorEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** A user with an invitation to be a collaborator on a repository owned by an organization in an enterprise. */\nexport type EnterprisePendingCollaboratorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /**\n   * Whether the invited collaborator does not have a license for the enterprise.\n   * @deprecated All pending collaborators consume a license Removal on 2021-01-01 UTC.\n   */\n  isUnlicensed: Scalars['Boolean']\n  /** The item at the end of the edge. */\n  node?: Maybe<User>\n  /** The enterprise organization repositories this user is a member of. */\n  repositories: EnterpriseRepositoryInfoConnection\n}\n\n/** A user with an invitation to be a collaborator on a repository owned by an organization in an enterprise. */\nexport type EnterprisePendingCollaboratorEdgeRepositoriesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryOrder>\n}\n\n/** The connection type for OrganizationInvitation. */\nexport type EnterprisePendingMemberInvitationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterprisePendingMemberInvitationEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n  /** Identifies the total count of unique users in the connection. */\n  totalUniqueUserCount: Scalars['Int']\n}\n\n/** An invitation to be a member in an enterprise organization. */\nexport type EnterprisePendingMemberInvitationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /**\n   * Whether the invitation has a license for the enterprise.\n   * @deprecated All pending members consume a license Removal on 2020-07-01 UTC.\n   */\n  isUnlicensed: Scalars['Boolean']\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationInvitation>\n}\n\n/** A subset of repository information queryable from an enterprise. */\nexport type EnterpriseRepositoryInfo = Node & {\n  id: Scalars['ID']\n  /** Identifies if the repository is private or internal. */\n  isPrivate: Scalars['Boolean']\n  /** The repository's name. */\n  name: Scalars['String']\n  /** The repository's name with owner. */\n  nameWithOwner: Scalars['String']\n}\n\n/** The connection type for EnterpriseRepositoryInfo. */\nexport type EnterpriseRepositoryInfoConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseRepositoryInfoEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseRepositoryInfo>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type EnterpriseRepositoryInfoEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseRepositoryInfo>\n}\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallation = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The customer name to which the Enterprise Server installation belongs. */\n  customerName: Scalars['String']\n  /** The host name of the Enterprise Server installation. */\n  hostName: Scalars['String']\n  id: Scalars['ID']\n  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */\n  isConnected: Scalars['Boolean']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** User accounts on this Enterprise Server installation. */\n  userAccounts: EnterpriseServerUserAccountConnection\n  /** User accounts uploads for the Enterprise Server installation. */\n  userAccountsUploads: EnterpriseServerUserAccountsUploadConnection\n}\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallationUserAccountsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<EnterpriseServerUserAccountOrder>\n}\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallationUserAccountsUploadsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<EnterpriseServerUserAccountsUploadOrder>\n}\n\n/** The connection type for EnterpriseServerInstallation. */\nexport type EnterpriseServerInstallationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerInstallationEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerInstallation>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type EnterpriseServerInstallationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerInstallation>\n}\n\n/** Ordering options for Enterprise Server installation connections. */\nexport type EnterpriseServerInstallationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order Enterprise Server installations by. */\n  field: EnterpriseServerInstallationOrderField\n}\n\n/** Properties by which Enterprise Server installation connections can be ordered. */\nexport enum EnterpriseServerInstallationOrderField {\n  /** Order Enterprise Server installations by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order Enterprise Server installations by customer name */\n  CustomerName = 'CUSTOMER_NAME',\n  /** Order Enterprise Server installations by host name */\n  HostName = 'HOST_NAME',\n}\n\n/** A user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccount = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** User emails belonging to this user account. */\n  emails: EnterpriseServerUserAccountEmailConnection\n  /** The Enterprise Server installation on which this user account exists. */\n  enterpriseServerInstallation: EnterpriseServerInstallation\n  id: Scalars['ID']\n  /** Whether the user account is a site administrator on the Enterprise Server installation. */\n  isSiteAdmin: Scalars['Boolean']\n  /** The login of the user account on the Enterprise Server installation. */\n  login: Scalars['String']\n  /** The profile name of the user account on the Enterprise Server installation. */\n  profileName?: Maybe<Scalars['String']>\n  /** The date and time when the user account was created on the Enterprise Server installation. */\n  remoteCreatedAt: Scalars['DateTime']\n  /** The ID of the user account on the Enterprise Server installation. */\n  remoteUserId: Scalars['Int']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** A user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountEmailsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<EnterpriseServerUserAccountEmailOrder>\n}\n\n/** The connection type for EnterpriseServerUserAccount. */\nexport type EnterpriseServerUserAccountConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccount>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccount>\n}\n\n/** An email belonging to a user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountEmail = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The email address. */\n  email: Scalars['String']\n  id: Scalars['ID']\n  /** Indicates whether this is the primary email of the associated user account. */\n  isPrimary: Scalars['Boolean']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The user account to which the email belongs. */\n  userAccount: EnterpriseServerUserAccount\n}\n\n/** The connection type for EnterpriseServerUserAccountEmail. */\nexport type EnterpriseServerUserAccountEmailConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmailEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmail>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountEmailEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccountEmail>\n}\n\n/** Ordering options for Enterprise Server user account email connections. */\nexport type EnterpriseServerUserAccountEmailOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order emails by. */\n  field: EnterpriseServerUserAccountEmailOrderField\n}\n\n/** Properties by which Enterprise Server user account email connections can be ordered. */\nexport enum EnterpriseServerUserAccountEmailOrderField {\n  /** Order emails by email */\n  Email = 'EMAIL',\n}\n\n/** Ordering options for Enterprise Server user account connections. */\nexport type EnterpriseServerUserAccountOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order user accounts by. */\n  field: EnterpriseServerUserAccountOrderField\n}\n\n/** Properties by which Enterprise Server user account connections can be ordered. */\nexport enum EnterpriseServerUserAccountOrderField {\n  /** Order user accounts by login */\n  Login = 'LOGIN',\n  /** Order user accounts by creation time on the Enterprise Server installation */\n  RemoteCreatedAt = 'REMOTE_CREATED_AT',\n}\n\n/** A user accounts upload from an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountsUpload = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The enterprise to which this upload belongs. */\n  enterprise: Enterprise\n  /** The Enterprise Server installation for which this upload was generated. */\n  enterpriseServerInstallation: EnterpriseServerInstallation\n  id: Scalars['ID']\n  /** The name of the file uploaded. */\n  name: Scalars['String']\n  /** The synchronization state of the upload */\n  syncState: EnterpriseServerUserAccountsUploadSyncState\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** The connection type for EnterpriseServerUserAccountsUpload. */\nexport type EnterpriseServerUserAccountsUploadConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUploadEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUpload>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountsUploadEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccountsUpload>\n}\n\n/** Ordering options for Enterprise Server user accounts upload connections. */\nexport type EnterpriseServerUserAccountsUploadOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order user accounts uploads by. */\n  field: EnterpriseServerUserAccountsUploadOrderField\n}\n\n/** Properties by which Enterprise Server user accounts upload connections can be ordered. */\nexport enum EnterpriseServerUserAccountsUploadOrderField {\n  /** Order user accounts uploads by creation time */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** Synchronization state of the Enterprise Server user accounts upload */\nexport enum EnterpriseServerUserAccountsUploadSyncState {\n  /** The synchronization of the upload failed. */\n  Failure = 'FAILURE',\n  /** The synchronization of the upload is pending. */\n  Pending = 'PENDING',\n  /** The synchronization of the upload succeeded. */\n  Success = 'SUCCESS',\n}\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccount = Actor &\n  Node & {\n    /** A URL pointing to the enterprise user account's public avatar. */\n    avatarUrl: Scalars['URI']\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** The enterprise in which this user account exists. */\n    enterprise: Enterprise\n    id: Scalars['ID']\n    /** An identifier for the enterprise user account, a login or email address */\n    login: Scalars['String']\n    /** The name of the enterprise user account */\n    name?: Maybe<Scalars['String']>\n    /** A list of enterprise organizations this user is a member of. */\n    organizations: EnterpriseOrganizationMembershipConnection\n    /** The HTTP path for this user. */\n    resourcePath: Scalars['URI']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this user. */\n    url: Scalars['URI']\n    /** The user within the enterprise. */\n    user?: Maybe<User>\n  }\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccountAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccountOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<OrganizationOrder>\n  query?: Maybe<Scalars['String']>\n  role?: Maybe<EnterpriseUserAccountMembershipRole>\n}\n\n/** The connection type for EnterpriseUserAccount. */\nexport type EnterpriseUserAccountConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseUserAccountEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseUserAccount>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type EnterpriseUserAccountEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseUserAccount>\n}\n\n/** The possible roles for enterprise membership. */\nexport enum EnterpriseUserAccountMembershipRole {\n  /** The user is a member of the enterprise membership. */\n  Member = 'MEMBER',\n  /** The user is an owner of the enterprise membership. */\n  Owner = 'OWNER',\n}\n\n/** The possible GitHub Enterprise deployments where this user can exist. */\nexport enum EnterpriseUserDeployment {\n  /** The user is part of a GitHub Enterprise Cloud deployment. */\n  Cloud = 'CLOUD',\n  /** The user is part of a GitHub Enterprise Server deployment. */\n  Server = 'SERVER',\n}\n\n/** An environment. */\nexport type Environment = Node & {\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** The name of the environment */\n  name: Scalars['String']\n  /** The protection rules defined for this environment */\n  protectionRules: DeploymentProtectionRuleConnection\n}\n\n/** An environment. */\nexport type EnvironmentProtectionRulesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for Environment. */\nexport type EnvironmentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnvironmentEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Environment>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type EnvironmentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Environment>\n}\n\n/** An external identity provisioned by SAML SSO or SCIM. */\nexport type ExternalIdentity = Node & {\n  /** The GUID for this identity */\n  guid: Scalars['String']\n  id: Scalars['ID']\n  /** Organization invitation for this SCIM-provisioned external identity */\n  organizationInvitation?: Maybe<OrganizationInvitation>\n  /** SAML Identity attributes */\n  samlIdentity?: Maybe<ExternalIdentitySamlAttributes>\n  /** SCIM Identity attributes */\n  scimIdentity?: Maybe<ExternalIdentityScimAttributes>\n  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */\n  user?: Maybe<User>\n}\n\n/** The connection type for ExternalIdentity. */\nexport type ExternalIdentityConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ExternalIdentityEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ExternalIdentity>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ExternalIdentityEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<ExternalIdentity>\n}\n\n/** SAML attributes for the External Identity */\nexport type ExternalIdentitySamlAttributes = {\n  /** The emails associated with the SAML identity */\n  emails?: Maybe<Array<UserEmailMetadata>>\n  /** Family name of the SAML identity */\n  familyName?: Maybe<Scalars['String']>\n  /** Given name of the SAML identity */\n  givenName?: Maybe<Scalars['String']>\n  /** The groups linked to this identity in IDP */\n  groups?: Maybe<Array<Scalars['String']>>\n  /** The NameID of the SAML identity */\n  nameId?: Maybe<Scalars['String']>\n  /** The userName of the SAML identity */\n  username?: Maybe<Scalars['String']>\n}\n\n/** SCIM attributes for the External Identity */\nexport type ExternalIdentityScimAttributes = {\n  /** The emails associated with the SCIM identity */\n  emails?: Maybe<Array<UserEmailMetadata>>\n  /** Family name of the SCIM identity */\n  familyName?: Maybe<Scalars['String']>\n  /** Given name of the SCIM identity */\n  givenName?: Maybe<Scalars['String']>\n  /** The groups linked to this identity in IDP */\n  groups?: Maybe<Array<Scalars['String']>>\n  /** The userName of the SCIM identity */\n  username?: Maybe<Scalars['String']>\n}\n\n/**\n * A command to add a file at the given path with the given contents as part of a\n * commit.  Any existing file at that that path will be replaced.\n */\nexport type FileAddition = {\n  /** The base64 encoded contents of the file */\n  contents: Scalars['Base64String']\n  /** The path in the repository where the file will be located */\n  path: Scalars['String']\n}\n\n/**\n * A description of a set of changes to a file tree to be made as part of\n * a git commit, modeled as zero or more file `additions` and zero or more\n * file `deletions`.\n *\n * Both fields are optional; omitting both will produce a commit with no\n * file changes.\n *\n * `deletions` and `additions` describe changes to files identified\n * by their path in the git tree using unix-style path separators, i.e.\n * `/`.  The root of a git tree is an empty string, so paths are not\n * slash-prefixed.\n *\n * `path` values must be unique across all `additions` and `deletions`\n * provided.  Any duplication will result in a validation error.\n *\n * ### Encoding\n *\n * File contents must be provided in full for each `FileAddition`.\n *\n * The `contents` of a `FileAddition` must be encoded using RFC 4648\n * compliant base64, i.e. correct padding is required and no characters\n * outside the standard alphabet may be used.  Invalid base64\n * encoding will be rejected with a validation error.\n *\n * The encoded contents may be binary.\n *\n * For text files, no assumptions are made about the character encoding of\n * the file contents (after base64 decoding).  No charset transcoding or\n * line-ending normalization will be performed; it is the client's\n * responsibility to manage the character encoding of files they provide.\n * However, for maximum compatibility we recommend using UTF-8 encoding\n * and ensuring that all files in a repository use a consistent\n * line-ending convention (`\\n` or `\\r\\n`), and that all files end\n * with a newline.\n *\n * ### Modeling file changes\n *\n * Each of the the five types of conceptual changes that can be made in a\n * git commit can be described using the `FileChanges` type as follows:\n *\n * 1. New file addition: create file `hello world\\n` at path `docs/README.txt`:\n *\n *        {\n *          \"additions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *              \"contents\": base64encode(\"hello world\\n\")\n *            }\n *          ]\n *        }\n *\n * 2. Existing file modification: change existing `docs/README.txt` to have new\n *    content `new content here\\n`:\n *\n *        {\n *          \"additions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *              \"contents\": base64encode(\"new content here\\n\")\n *            }\n *          ]\n *        }\n *\n * 3. Existing file deletion: remove existing file `docs/README.txt`.\n *    Note that the path is required to exist -- specifying a\n *    path that does not exist on the given branch will abort the\n *    commit and return an error.\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\"\n *            }\n *          ]\n *        }\n *\n *\n * 4. File rename with no changes: rename `docs/README.txt` with\n *    previous content `hello world\\n` to the same content at\n *    `newdocs/README.txt`:\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *            }\n *          ],\n *          \"additions\" [\n *            {\n *              \"path\": \"newdocs/README.txt\",\n *              \"contents\": base64encode(\"hello world\\n\")\n *            }\n *          ]\n *        }\n *\n *\n * 5. File rename with changes: rename `docs/README.txt` with\n *    previous content `hello world\\n` to a file at path\n *    `newdocs/README.txt` with content `new contents\\n`:\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *            }\n *          ],\n *          \"additions\" [\n *            {\n *              \"path\": \"newdocs/README.txt\",\n *              \"contents\": base64encode(\"new contents\\n\")\n *            }\n *          ]\n *        }\n */\nexport type FileChanges = {\n  /** File to add or change. */\n  additions?: Maybe<Array<FileAddition>>\n  /** Files to delete. */\n  deletions?: Maybe<Array<FileDeletion>>\n}\n\n/** A command to delete the file at the given path as part of a commit. */\nexport type FileDeletion = {\n  /** The path to delete */\n  path: Scalars['String']\n}\n\n/** The possible viewed states of a file . */\nexport enum FileViewedState {\n  /** The file has new changes since last viewed. */\n  Dismissed = 'DISMISSED',\n  /** The file has not been marked as viewed. */\n  Unviewed = 'UNVIEWED',\n  /** The file has been marked as viewed. */\n  Viewed = 'VIEWED',\n}\n\n/** Autogenerated input type of FollowUser */\nexport type FollowUserInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the user to follow. */\n  userId: Scalars['ID']\n}\n\n/** Autogenerated return type of FollowUser */\nexport type FollowUserPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The user that was followed. */\n  user?: Maybe<User>\n}\n\n/** The connection type for User. */\nexport type FollowerConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** The connection type for User. */\nexport type FollowingConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** A funding platform link for a repository. */\nexport type FundingLink = {\n  /** The funding platform this link is for. */\n  platform: FundingPlatform\n  /** The configured URL for this funding link. */\n  url: Scalars['URI']\n}\n\n/** The possible funding platforms for repository funding links. */\nexport enum FundingPlatform {\n  /** Community Bridge funding platform. */\n  CommunityBridge = 'COMMUNITY_BRIDGE',\n  /** Custom funding platform. */\n  Custom = 'CUSTOM',\n  /** GitHub funding platform. */\n  Github = 'GITHUB',\n  /** IssueHunt funding platform. */\n  Issuehunt = 'ISSUEHUNT',\n  /** Ko-fi funding platform. */\n  KoFi = 'KO_FI',\n  /** Liberapay funding platform. */\n  Liberapay = 'LIBERAPAY',\n  /** Open Collective funding platform. */\n  OpenCollective = 'OPEN_COLLECTIVE',\n  /** Otechie funding platform. */\n  Otechie = 'OTECHIE',\n  /** Patreon funding platform. */\n  Patreon = 'PATREON',\n  /** Tidelift funding platform. */\n  Tidelift = 'TIDELIFT',\n}\n\n/** A generic hovercard context with a message and icon */\nexport type GenericHovercardContext = HovercardContext & {\n  /** A string describing this context */\n  message: Scalars['String']\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']\n}\n\n/** A Gist. */\nexport type Gist = Node &\n  Starrable &\n  UniformResourceLocatable & {\n    /** A list of comments associated with the gist */\n    comments: GistCommentConnection\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** The gist description. */\n    description?: Maybe<Scalars['String']>\n    /** The files in this gist. */\n    files?: Maybe<Array<Maybe<GistFile>>>\n    /** A list of forks associated with the gist */\n    forks: GistConnection\n    id: Scalars['ID']\n    /** Identifies if the gist is a fork. */\n    isFork: Scalars['Boolean']\n    /** Whether the gist is public or not. */\n    isPublic: Scalars['Boolean']\n    /** The gist name. */\n    name: Scalars['String']\n    /** The gist owner. */\n    owner?: Maybe<RepositoryOwner>\n    /** Identifies when the gist was last pushed to. */\n    pushedAt?: Maybe<Scalars['DateTime']>\n    /** The HTML path to this resource. */\n    resourcePath: Scalars['URI']\n    /** Returns a count of how many stargazers there are on this object */\n    stargazerCount: Scalars['Int']\n    /** A list of users who have starred this starrable. */\n    stargazers: StargazerConnection\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this Gist. */\n    url: Scalars['URI']\n    /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n    viewerHasStarred: Scalars['Boolean']\n  }\n\n/** A Gist. */\nexport type GistCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A Gist. */\nexport type GistFilesArgs = {\n  limit?: Maybe<Scalars['Int']>\n  oid?: Maybe<Scalars['GitObjectID']>\n}\n\n/** A Gist. */\nexport type GistForksArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<GistOrder>\n}\n\n/** A Gist. */\nexport type GistStargazersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<StarOrder>\n}\n\n/** Represents a comment on an Gist. */\nexport type GistComment = Comment &\n  Deletable &\n  Minimizable &\n  Node &\n  Updatable &\n  UpdatableComment & {\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the gist. */\n    authorAssociation: CommentAuthorAssociation\n    /** Identifies the comment body. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The body rendered to text. */\n    bodyText: Scalars['String']\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>\n    /** The associated gist. */\n    gist: Gist\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** Returns whether or not a comment has been minimized. */\n    isMinimized: Scalars['Boolean']\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** Returns why the comment was minimized. */\n    minimizedReason?: Maybe<Scalars['String']>\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars['Boolean']\n    /** Check if the current viewer can minimize this object. */\n    viewerCanMinimize: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n  }\n\n/** Represents a comment on an Gist. */\nexport type GistCommentUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for GistComment. */\nexport type GistCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GistCommentEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<GistComment>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type GistCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<GistComment>\n}\n\n/** The connection type for Gist. */\nexport type GistConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GistEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Gist>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type GistEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Gist>\n}\n\n/** A file in a gist. */\nexport type GistFile = {\n  /** The file name encoded to remove characters that are invalid in URL paths. */\n  encodedName?: Maybe<Scalars['String']>\n  /** The gist file encoding. */\n  encoding?: Maybe<Scalars['String']>\n  /** The file extension from the file name. */\n  extension?: Maybe<Scalars['String']>\n  /** Indicates if this file is an image. */\n  isImage: Scalars['Boolean']\n  /** Whether the file's contents were truncated. */\n  isTruncated: Scalars['Boolean']\n  /** The programming language this file is written in. */\n  language?: Maybe<Language>\n  /** The gist file name. */\n  name?: Maybe<Scalars['String']>\n  /** The gist file size in bytes. */\n  size?: Maybe<Scalars['Int']>\n  /** UTF8 text data or null if the file is binary */\n  text?: Maybe<Scalars['String']>\n}\n\n/** A file in a gist. */\nexport type GistFileTextArgs = {\n  truncate?: Maybe<Scalars['Int']>\n}\n\n/** Ordering options for gist connections */\nexport type GistOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order repositories by. */\n  field: GistOrderField\n}\n\n/** Properties by which gist connections can be ordered. */\nexport enum GistOrderField {\n  /** Order gists by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order gists by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order gists by update time */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** The privacy of a Gist */\nexport enum GistPrivacy {\n  /** Gists that are public and secret */\n  All = 'ALL',\n  /** Public */\n  Public = 'PUBLIC',\n  /** Secret */\n  Secret = 'SECRET',\n}\n\n/** Represents an actor in a Git commit (ie. an author or committer). */\nexport type GitActor = {\n  /** A URL pointing to the author's public avatar. */\n  avatarUrl: Scalars['URI']\n  /** The timestamp of the Git action (authoring or committing). */\n  date?: Maybe<Scalars['GitTimestamp']>\n  /** The email in the Git commit. */\n  email?: Maybe<Scalars['String']>\n  /** The name in the Git commit. */\n  name?: Maybe<Scalars['String']>\n  /** The GitHub user corresponding to the email field. Null if no such user exists. */\n  user?: Maybe<User>\n}\n\n/** Represents an actor in a Git commit (ie. an author or committer). */\nexport type GitActorAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for GitActor. */\nexport type GitActorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GitActorEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<GitActor>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type GitActorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<GitActor>\n}\n\n/** Represents information about the GitHub instance. */\nexport type GitHubMetadata = {\n  /** Returns a String that's a SHA of `github-services` */\n  gitHubServicesSha: Scalars['GitObjectID']\n  /** IP addresses that users connect to for git operations */\n  gitIpAddresses?: Maybe<Array<Scalars['String']>>\n  /** IP addresses that service hooks are sent from */\n  hookIpAddresses?: Maybe<Array<Scalars['String']>>\n  /** IP addresses that the importer connects from */\n  importerIpAddresses?: Maybe<Array<Scalars['String']>>\n  /** Whether or not users are verified */\n  isPasswordAuthenticationVerifiable: Scalars['Boolean']\n  /** IP addresses for GitHub Pages' A records */\n  pagesIpAddresses?: Maybe<Array<Scalars['String']>>\n}\n\n/** Represents a Git object. */\nexport type GitObject = {\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String']\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI']\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI']\n  id: Scalars['ID']\n  /** The Git object ID */\n  oid: Scalars['GitObjectID']\n  /** The Repository the Git object belongs to */\n  repository: Repository\n}\n\n/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */\nexport type GitSignature = {\n  /** Email used to sign this object. */\n  email: Scalars['String']\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean']\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String']\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String']\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean']\n}\n\n/** The state of a Git signature. */\nexport enum GitSignatureState {\n  /** The signing certificate or its chain could not be verified */\n  BadCert = 'BAD_CERT',\n  /** Invalid email used for signing */\n  BadEmail = 'BAD_EMAIL',\n  /** Signing key expired */\n  ExpiredKey = 'EXPIRED_KEY',\n  /** Internal error - the GPG verification service misbehaved */\n  GpgverifyError = 'GPGVERIFY_ERROR',\n  /** Internal error - the GPG verification service is unavailable at the moment */\n  GpgverifyUnavailable = 'GPGVERIFY_UNAVAILABLE',\n  /** Invalid signature */\n  Invalid = 'INVALID',\n  /** Malformed signature */\n  MalformedSig = 'MALFORMED_SIG',\n  /** The usage flags for the key that signed this don't allow signing */\n  NotSigningKey = 'NOT_SIGNING_KEY',\n  /** Email used for signing not known to GitHub */\n  NoUser = 'NO_USER',\n  /** Valid signature, though certificate revocation check failed */\n  OcspError = 'OCSP_ERROR',\n  /** Valid signature, pending certificate revocation checking */\n  OcspPending = 'OCSP_PENDING',\n  /** One or more certificates in chain has been revoked */\n  OcspRevoked = 'OCSP_REVOKED',\n  /** Key used for signing not known to GitHub */\n  UnknownKey = 'UNKNOWN_KEY',\n  /** Unknown signature type */\n  UnknownSigType = 'UNKNOWN_SIG_TYPE',\n  /** Unsigned */\n  Unsigned = 'UNSIGNED',\n  /** Email used for signing unverified on GitHub */\n  UnverifiedEmail = 'UNVERIFIED_EMAIL',\n  /** Valid signature and verified by GitHub */\n  Valid = 'VALID',\n}\n\n/** Represents a GPG signature on a Commit or Tag. */\nexport type GpgSignature = GitSignature & {\n  /** Email used to sign this object. */\n  email: Scalars['String']\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean']\n  /** Hex-encoded ID of the key that signed this object. */\n  keyId?: Maybe<Scalars['String']>\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String']\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String']\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean']\n}\n\n/** Represents a 'head_ref_deleted' event on a given pull request. */\nexport type HeadRefDeletedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the Ref associated with the `head_ref_deleted` event. */\n  headRef?: Maybe<Ref>\n  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */\n  headRefName: Scalars['String']\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n}\n\n/** Represents a 'head_ref_force_pushed' event on a given pull request. */\nexport type HeadRefForcePushedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */\n  afterCommit?: Maybe<Commit>\n  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */\n  beforeCommit?: Maybe<Commit>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */\n  ref?: Maybe<Ref>\n}\n\n/** Represents a 'head_ref_restored' event on a given pull request. */\nexport type HeadRefRestoredEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n}\n\n/** Detail needed to display a hovercard for a user */\nexport type Hovercard = {\n  /** Each of the contexts for this hovercard */\n  contexts: Array<HovercardContext>\n}\n\n/** An individual line of a hovercard */\nexport type HovercardContext = {\n  /** A string describing this context */\n  message: Scalars['String']\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']\n}\n\n/** The possible states in which authentication can be configured with an identity provider. */\nexport enum IdentityProviderConfigurationState {\n  /** Authentication with an identity provider is configured but not enforced. */\n  Configured = 'CONFIGURED',\n  /** Authentication with an identity provider is configured and enforced. */\n  Enforced = 'ENFORCED',\n  /** Authentication with an identity provider is not configured. */\n  Unconfigured = 'UNCONFIGURED',\n}\n\n/** Autogenerated input type of ImportProject */\nexport type ImportProjectInput = {\n  /** The description of Project. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A list of columns containing issues and pull requests. */\n  columnImports: Array<ProjectColumnImport>\n  /** The name of Project. */\n  name: Scalars['String']\n  /** The name of the Organization or User to create the Project under. */\n  ownerName: Scalars['String']\n  /** Whether the Project is public or not. */\n  public?: Maybe<Scalars['Boolean']>\n}\n\n/** Autogenerated return type of ImportProject */\nexport type ImportProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new Project! */\n  project?: Maybe<Project>\n}\n\n/** Autogenerated input type of InviteEnterpriseAdmin */\nexport type InviteEnterpriseAdminInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The email of the person to invite as an administrator. */\n  email?: Maybe<Scalars['String']>\n  /** The ID of the enterprise to which you want to invite an administrator. */\n  enterpriseId: Scalars['ID']\n  /** The login of a user to invite as an administrator. */\n  invitee?: Maybe<Scalars['String']>\n  /** The role of the administrator. */\n  role?: Maybe<EnterpriseAdministratorRole>\n}\n\n/** Autogenerated return type of InviteEnterpriseAdmin */\nexport type InviteEnterpriseAdminPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The created enterprise administrator invitation. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>\n}\n\n/** The possible values for the IP allow list enabled setting. */\nexport enum IpAllowListEnabledSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED',\n}\n\n/** An IP address or range of addresses that is allowed to access an owner's resources. */\nexport type IpAllowListEntry = Node & {\n  /** A single IP address or range of IP addresses in CIDR notation. */\n  allowListValue: Scalars['String']\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Whether the entry is currently active. */\n  isActive: Scalars['Boolean']\n  /** The name of the IP allow list entry. */\n  name?: Maybe<Scalars['String']>\n  /** The owner of the IP allow list entry. */\n  owner: IpAllowListOwner\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** The connection type for IpAllowListEntry. */\nexport type IpAllowListEntryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IpAllowListEntryEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IpAllowListEntry>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type IpAllowListEntryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<IpAllowListEntry>\n}\n\n/** Ordering options for IP allow list entry connections. */\nexport type IpAllowListEntryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order IP allow list entries by. */\n  field: IpAllowListEntryOrderField\n}\n\n/** Properties by which IP allow list entry connections can be ordered. */\nexport enum IpAllowListEntryOrderField {\n  /** Order IP allow list entries by the allow list value. */\n  AllowListValue = 'ALLOW_LIST_VALUE',\n  /** Order IP allow list entries by creation time. */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */\nexport enum IpAllowListForInstalledAppsEnabledSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED',\n}\n\n/** Types that can own an IP allow list. */\nexport type IpAllowListOwner = App | Enterprise | Organization\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type Issue = Assignable &\n  Closable &\n  Comment &\n  Labelable &\n  Lockable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Subscribable &\n  UniformResourceLocatable &\n  Updatable &\n  UpdatableComment & {\n    /** Reason that the conversation was locked. */\n    activeLockReason?: Maybe<LockReason>\n    /** A list of Users assigned to this object. */\n    assignees: UserConnection\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation\n    /** Identifies the body of the issue. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The http path for this issue body */\n    bodyResourcePath: Scalars['URI']\n    /** Identifies the body of the issue rendered to text. */\n    bodyText: Scalars['String']\n    /** The http URL for this issue body */\n    bodyUrl: Scalars['URI']\n    /** `true` if the object is closed (definition of closed may depend on type) */\n    closed: Scalars['Boolean']\n    /** Identifies the date and time when the object was closed. */\n    closedAt?: Maybe<Scalars['DateTime']>\n    /** A list of comments associated with the Issue. */\n    comments: IssueCommentConnection\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>\n    /** The hovercard information for this issue */\n    hovercard: Hovercard\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** Indicates whether or not this issue is currently pinned to the repository issues list */\n    isPinned?: Maybe<Scalars['Boolean']>\n    /** Is this issue read by the viewer */\n    isReadByViewer?: Maybe<Scalars['Boolean']>\n    /** A list of labels associated with the object. */\n    labels?: Maybe<LabelConnection>\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** `true` if the object is locked */\n    locked: Scalars['Boolean']\n    /** Identifies the milestone associated with the issue. */\n    milestone?: Maybe<Milestone>\n    /** Identifies the issue number. */\n    number: Scalars['Int']\n    /** A list of Users that are participating in the Issue conversation. */\n    participants: UserConnection\n    /** List of project cards associated with this issue. */\n    projectCards: ProjectCardConnection\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** The repository associated with this node. */\n    repository: Repository\n    /** The HTTP path for this issue */\n    resourcePath: Scalars['URI']\n    /** Identifies the state of the issue. */\n    state: IssueState\n    /**\n     * A list of events, comments, commits, etc. associated with the issue.\n     * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.\n     */\n    timeline: IssueTimelineConnection\n    /** A list of events, comments, commits, etc. associated with the issue. */\n    timelineItems: IssueTimelineItemsConnection\n    /** Identifies the issue title. */\n    title: Scalars['String']\n    /** Identifies the issue title rendered to HTML. */\n    titleHTML: Scalars['String']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this issue */\n    url: Scalars['URI']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>\n  }\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueAssigneesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueCommentOrder>\n}\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueHovercardArgs = {\n  includeNotificationContexts?: Maybe<Scalars['Boolean']>\n}\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueLabelsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<LabelOrder>\n}\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueParticipantsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectCardsArgs = {\n  after?: Maybe<Scalars['String']>\n  archivedStates?: Maybe<Array<Maybe<ProjectCardArchivedState>>>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTimelineArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  since?: Maybe<Scalars['DateTime']>\n}\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTimelineItemsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  itemTypes?: Maybe<Array<IssueTimelineItemsItemType>>\n  last?: Maybe<Scalars['Int']>\n  since?: Maybe<Scalars['DateTime']>\n  skip?: Maybe<Scalars['Int']>\n}\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Represents a comment on an Issue. */\nexport type IssueComment = Comment &\n  Deletable &\n  Minimizable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Updatable &\n  UpdatableComment & {\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation\n    /** The body as Markdown. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The body rendered to text. */\n    bodyText: Scalars['String']\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** Returns whether or not a comment has been minimized. */\n    isMinimized: Scalars['Boolean']\n    /** Identifies the issue associated with the comment. */\n    issue: Issue\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** Returns why the comment was minimized. */\n    minimizedReason?: Maybe<Scalars['String']>\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /**\n     * Returns the pull request associated with the comment, if this comment was made on a\n     * pull request.\n     */\n    pullRequest?: Maybe<PullRequest>\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** The repository associated with this node. */\n    repository: Repository\n    /** The HTTP path for this issue comment */\n    resourcePath: Scalars['URI']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this issue comment */\n    url: Scalars['URI']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars['Boolean']\n    /** Check if the current viewer can minimize this object. */\n    viewerCanMinimize: Scalars['Boolean']\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n  }\n\n/** Represents a comment on an Issue. */\nexport type IssueCommentReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** Represents a comment on an Issue. */\nexport type IssueCommentUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for IssueComment. */\nexport type IssueCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueCommentEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueComment>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type IssueCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueComment>\n}\n\n/** Ways in which lists of issue comments can be ordered upon return. */\nexport type IssueCommentOrder = {\n  /** The direction in which to order issue comments by the specified field. */\n  direction: OrderDirection\n  /** The field in which to order issue comments by. */\n  field: IssueCommentOrderField\n}\n\n/** Properties by which issue comment connections can be ordered. */\nexport enum IssueCommentOrderField {\n  /** Order issue comments by update time */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** The connection type for Issue. */\nexport type IssueConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Issue>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** This aggregates issues opened by a user within one repository. */\nexport type IssueContributionsByRepository = {\n  /** The issue contributions. */\n  contributions: CreatedIssueContributionConnection\n  /** The repository in which the issues were opened. */\n  repository: Repository\n}\n\n/** This aggregates issues opened by a user within one repository. */\nexport type IssueContributionsByRepositoryContributionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ContributionOrder>\n}\n\n/** An edge in a connection. */\nexport type IssueEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Issue>\n}\n\n/** Ways in which to filter lists of issues. */\nexport type IssueFilters = {\n  /**\n   * List issues assigned to given name. Pass in `null` for issues with no assigned\n   * user, and `*` for issues assigned to any user.\n   */\n  assignee?: Maybe<Scalars['String']>\n  /** List issues created by given name. */\n  createdBy?: Maybe<Scalars['String']>\n  /** List issues where the list of label names exist on the issue. */\n  labels?: Maybe<Array<Scalars['String']>>\n  /** List issues where the given name is mentioned in the issue. */\n  mentioned?: Maybe<Scalars['String']>\n  /**\n   * List issues by given milestone argument. If an string representation of an\n   * integer is passed, it should refer to a milestone by its number field. Pass in\n   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.\n   */\n  milestone?: Maybe<Scalars['String']>\n  /** List issues that have been updated at or after the given date. */\n  since?: Maybe<Scalars['DateTime']>\n  /** List issues filtered by the list of states given. */\n  states?: Maybe<Array<IssueState>>\n  /** List issues subscribed to by viewer. */\n  viewerSubscribed?: Maybe<Scalars['Boolean']>\n}\n\n/** Used for return value of Repository.issueOrPullRequest. */\nexport type IssueOrPullRequest = Issue | PullRequest\n\n/** Ways in which lists of issues can be ordered upon return. */\nexport type IssueOrder = {\n  /** The direction in which to order issues by the specified field. */\n  direction: OrderDirection\n  /** The field in which to order issues by. */\n  field: IssueOrderField\n}\n\n/** Properties by which issue connections can be ordered. */\nexport enum IssueOrderField {\n  /** Order issues by comment count */\n  Comments = 'COMMENTS',\n  /** Order issues by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order issues by update time */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** The possible states of an issue. */\nexport enum IssueState {\n  /** An issue that has been closed */\n  Closed = 'CLOSED',\n  /** An issue that is still open */\n  Open = 'OPEN',\n}\n\n/** A repository issue template. */\nexport type IssueTemplate = {\n  /** The template purpose. */\n  about?: Maybe<Scalars['String']>\n  /** The suggested issue body. */\n  body?: Maybe<Scalars['String']>\n  /** The template name. */\n  name: Scalars['String']\n  /** The suggested issue title. */\n  title?: Maybe<Scalars['String']>\n}\n\n/** The connection type for IssueTimelineItem. */\nexport type IssueTimelineConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueTimelineItemEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueTimelineItem>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An item in an issue timeline */\nexport type IssueTimelineItem =\n  | AssignedEvent\n  | ClosedEvent\n  | Commit\n  | CrossReferencedEvent\n  | DemilestonedEvent\n  | IssueComment\n  | LabeledEvent\n  | LockedEvent\n  | MilestonedEvent\n  | ReferencedEvent\n  | RenamedTitleEvent\n  | ReopenedEvent\n  | SubscribedEvent\n  | TransferredEvent\n  | UnassignedEvent\n  | UnlabeledEvent\n  | UnlockedEvent\n  | UnsubscribedEvent\n  | UserBlockedEvent\n\n/** An edge in a connection. */\nexport type IssueTimelineItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueTimelineItem>\n}\n\n/** An item in an issue timeline */\nexport type IssueTimelineItems =\n  | AddedToProjectEvent\n  | AssignedEvent\n  | ClosedEvent\n  | CommentDeletedEvent\n  | ConnectedEvent\n  | ConvertedNoteToIssueEvent\n  | CrossReferencedEvent\n  | DemilestonedEvent\n  | DisconnectedEvent\n  | IssueComment\n  | LabeledEvent\n  | LockedEvent\n  | MarkedAsDuplicateEvent\n  | MentionedEvent\n  | MilestonedEvent\n  | MovedColumnsInProjectEvent\n  | PinnedEvent\n  | ReferencedEvent\n  | RemovedFromProjectEvent\n  | RenamedTitleEvent\n  | ReopenedEvent\n  | SubscribedEvent\n  | TransferredEvent\n  | UnassignedEvent\n  | UnlabeledEvent\n  | UnlockedEvent\n  | UnmarkedAsDuplicateEvent\n  | UnpinnedEvent\n  | UnsubscribedEvent\n  | UserBlockedEvent\n\n/** The connection type for IssueTimelineItems. */\nexport type IssueTimelineItemsConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueTimelineItemsEdge>>>\n  /** Identifies the count of items after applying `before` and `after` filters. */\n  filteredCount: Scalars['Int']\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueTimelineItems>>>\n  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */\n  pageCount: Scalars['Int']\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n  /** Identifies the date and time when the timeline was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** An edge in a connection. */\nexport type IssueTimelineItemsEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueTimelineItems>\n}\n\n/** The possible item types found in a timeline. */\nexport enum IssueTimelineItemsItemType {\n  /** Represents a 'added_to_project' event on a given issue or pull request. */\n  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',\n  /** Represents an 'assigned' event on any assignable object. */\n  AssignedEvent = 'ASSIGNED_EVENT',\n  /** Represents a 'closed' event on any `Closable`. */\n  ClosedEvent = 'CLOSED_EVENT',\n  /** Represents a 'comment_deleted' event on a given issue or pull request. */\n  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',\n  /** Represents a 'connected' event on a given issue or pull request. */\n  ConnectedEvent = 'CONNECTED_EVENT',\n  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\n  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',\n  /** Represents a mention made by one issue or pull request to another. */\n  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',\n  /** Represents a 'demilestoned' event on a given issue or pull request. */\n  DemilestonedEvent = 'DEMILESTONED_EVENT',\n  /** Represents a 'disconnected' event on a given issue or pull request. */\n  DisconnectedEvent = 'DISCONNECTED_EVENT',\n  /** Represents a comment on an Issue. */\n  IssueComment = 'ISSUE_COMMENT',\n  /** Represents a 'labeled' event on a given issue or pull request. */\n  LabeledEvent = 'LABELED_EVENT',\n  /** Represents a 'locked' event on a given issue or pull request. */\n  LockedEvent = 'LOCKED_EVENT',\n  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\n  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',\n  /** Represents a 'mentioned' event on a given issue or pull request. */\n  MentionedEvent = 'MENTIONED_EVENT',\n  /** Represents a 'milestoned' event on a given issue or pull request. */\n  MilestonedEvent = 'MILESTONED_EVENT',\n  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\n  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',\n  /** Represents a 'pinned' event on a given issue or pull request. */\n  PinnedEvent = 'PINNED_EVENT',\n  /** Represents a 'referenced' event on a given `ReferencedSubject`. */\n  ReferencedEvent = 'REFERENCED_EVENT',\n  /** Represents a 'removed_from_project' event on a given issue or pull request. */\n  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',\n  /** Represents a 'renamed' event on a given issue or pull request */\n  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',\n  /** Represents a 'reopened' event on any `Closable`. */\n  ReopenedEvent = 'REOPENED_EVENT',\n  /** Represents a 'subscribed' event on a given `Subscribable`. */\n  SubscribedEvent = 'SUBSCRIBED_EVENT',\n  /** Represents a 'transferred' event on a given issue or pull request. */\n  TransferredEvent = 'TRANSFERRED_EVENT',\n  /** Represents an 'unassigned' event on any assignable object. */\n  UnassignedEvent = 'UNASSIGNED_EVENT',\n  /** Represents an 'unlabeled' event on a given issue or pull request. */\n  UnlabeledEvent = 'UNLABELED_EVENT',\n  /** Represents an 'unlocked' event on a given issue or pull request. */\n  UnlockedEvent = 'UNLOCKED_EVENT',\n  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\n  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',\n  /** Represents an 'unpinned' event on a given issue or pull request. */\n  UnpinnedEvent = 'UNPINNED_EVENT',\n  /** Represents an 'unsubscribed' event on a given `Subscribable`. */\n  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',\n  /** Represents a 'user_blocked' event on a given user. */\n  UserBlockedEvent = 'USER_BLOCKED_EVENT',\n}\n\n/** Represents a user signing up for a GitHub account. */\nexport type JoinedGitHubContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']\n  /** The user who made this contribution. */\n  user: User\n}\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type Label = Node & {\n  /** Identifies the label color. */\n  color: Scalars['String']\n  /** Identifies the date and time when the label was created. */\n  createdAt?: Maybe<Scalars['DateTime']>\n  /** A brief description of this label. */\n  description?: Maybe<Scalars['String']>\n  id: Scalars['ID']\n  /** Indicates whether or not this is a default label. */\n  isDefault: Scalars['Boolean']\n  /** A list of issues associated with this label. */\n  issues: IssueConnection\n  /** Identifies the label name. */\n  name: Scalars['String']\n  /** A list of pull requests associated with this label. */\n  pullRequests: PullRequestConnection\n  /** The repository associated with this label. */\n  repository: Repository\n  /** The HTTP path for this label. */\n  resourcePath: Scalars['URI']\n  /** Identifies the date and time when the label was last updated. */\n  updatedAt?: Maybe<Scalars['DateTime']>\n  /** The HTTP URL for this label. */\n  url: Scalars['URI']\n}\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type LabelIssuesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  filterBy?: Maybe<IssueFilters>\n  first?: Maybe<Scalars['Int']>\n  labels?: Maybe<Array<Scalars['String']>>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n  states?: Maybe<Array<IssueState>>\n}\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type LabelPullRequestsArgs = {\n  after?: Maybe<Scalars['String']>\n  baseRefName?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  headRefName?: Maybe<Scalars['String']>\n  labels?: Maybe<Array<Scalars['String']>>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n  states?: Maybe<Array<PullRequestState>>\n}\n\n/** The connection type for Label. */\nexport type LabelConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<LabelEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Label>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type LabelEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Label>\n}\n\n/** Ways in which lists of labels can be ordered upon return. */\nexport type LabelOrder = {\n  /** The direction in which to order labels by the specified field. */\n  direction: OrderDirection\n  /** The field in which to order labels by. */\n  field: LabelOrderField\n}\n\n/** Properties by which label connections can be ordered. */\nexport enum LabelOrderField {\n  /** Order labels by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order labels by name */\n  Name = 'NAME',\n}\n\n/** An object that can have labels assigned to it. */\nexport type Labelable = {\n  /** A list of labels associated with the object. */\n  labels?: Maybe<LabelConnection>\n}\n\n/** An object that can have labels assigned to it. */\nexport type LabelableLabelsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<LabelOrder>\n}\n\n/** Represents a 'labeled' event on a given issue or pull request. */\nexport type LabeledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Identifies the label associated with the 'labeled' event. */\n  label: Label\n  /** Identifies the `Labelable` associated with the event. */\n  labelable: Labelable\n}\n\n/** Represents a given language found in repositories. */\nexport type Language = Node & {\n  /** The color defined for the current language. */\n  color?: Maybe<Scalars['String']>\n  id: Scalars['ID']\n  /** The name of the current language. */\n  name: Scalars['String']\n}\n\n/** A list of languages associated with the parent. */\nexport type LanguageConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<LanguageEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Language>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n  /** The total size in bytes of files written in that language. */\n  totalSize: Scalars['Int']\n}\n\n/** Represents the language of a repository. */\nexport type LanguageEdge = {\n  cursor: Scalars['String']\n  node: Language\n  /** The number of bytes of code written in the language. */\n  size: Scalars['Int']\n}\n\n/** Ordering options for language connections. */\nexport type LanguageOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order languages by. */\n  field: LanguageOrderField\n}\n\n/** Properties by which language connections can be ordered. */\nexport enum LanguageOrderField {\n  /** Order languages by the size of all files containing the language */\n  Size = 'SIZE',\n}\n\n/** A repository's open source license */\nexport type License = Node & {\n  /** The full text of the license */\n  body: Scalars['String']\n  /** The conditions set by the license */\n  conditions: Array<Maybe<LicenseRule>>\n  /** A human-readable description of the license */\n  description?: Maybe<Scalars['String']>\n  /** Whether the license should be featured */\n  featured: Scalars['Boolean']\n  /** Whether the license should be displayed in license pickers */\n  hidden: Scalars['Boolean']\n  id: Scalars['ID']\n  /** Instructions on how to implement the license */\n  implementation?: Maybe<Scalars['String']>\n  /** The lowercased SPDX ID of the license */\n  key: Scalars['String']\n  /** The limitations set by the license */\n  limitations: Array<Maybe<LicenseRule>>\n  /** The license full name specified by <https://spdx.org/licenses> */\n  name: Scalars['String']\n  /** Customary short name if applicable (e.g, GPLv3) */\n  nickname?: Maybe<Scalars['String']>\n  /** The permissions set by the license */\n  permissions: Array<Maybe<LicenseRule>>\n  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */\n  pseudoLicense: Scalars['Boolean']\n  /** Short identifier specified by <https://spdx.org/licenses> */\n  spdxId?: Maybe<Scalars['String']>\n  /** URL to the license on <https://choosealicense.com> */\n  url?: Maybe<Scalars['URI']>\n}\n\n/** Describes a License's conditions, permissions, and limitations */\nexport type LicenseRule = {\n  /** A description of the rule */\n  description: Scalars['String']\n  /** The machine-readable rule key */\n  key: Scalars['String']\n  /** The human-readable rule label */\n  label: Scalars['String']\n}\n\n/** Autogenerated input type of LinkRepositoryToProject */\nexport type LinkRepositoryToProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the Project to link to a Repository */\n  projectId: Scalars['ID']\n  /** The ID of the Repository to link to a Project. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of LinkRepositoryToProject */\nexport type LinkRepositoryToProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The linked Project. */\n  project?: Maybe<Project>\n  /** The linked Repository. */\n  repository?: Maybe<Repository>\n}\n\n/** Autogenerated input type of LockLockable */\nexport type LockLockableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A reason for why the item will be locked. */\n  lockReason?: Maybe<LockReason>\n  /** ID of the item to be locked. */\n  lockableId: Scalars['ID']\n}\n\n/** Autogenerated return type of LockLockable */\nexport type LockLockablePayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The item that was locked. */\n  lockedRecord?: Maybe<Lockable>\n}\n\n/** The possible reasons that an issue or pull request was locked. */\nexport enum LockReason {\n  /** The issue or pull request was locked because the conversation was off-topic. */\n  OffTopic = 'OFF_TOPIC',\n  /** The issue or pull request was locked because the conversation was resolved. */\n  Resolved = 'RESOLVED',\n  /** The issue or pull request was locked because the conversation was spam. */\n  Spam = 'SPAM',\n  /** The issue or pull request was locked because the conversation was too heated. */\n  TooHeated = 'TOO_HEATED',\n}\n\n/** An object that can be locked. */\nexport type Lockable = {\n  /** Reason that the conversation was locked. */\n  activeLockReason?: Maybe<LockReason>\n  /** `true` if the object is locked */\n  locked: Scalars['Boolean']\n}\n\n/** Represents a 'locked' event on a given issue or pull request. */\nexport type LockedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Reason that the conversation was locked (optional). */\n  lockReason?: Maybe<LockReason>\n  /** Object that was locked. */\n  lockable: Lockable\n}\n\n/** A placeholder user for attribution of imported data on GitHub. */\nexport type Mannequin = Actor &\n  Node &\n  UniformResourceLocatable & {\n    /** A URL pointing to the GitHub App's public avatar. */\n    avatarUrl: Scalars['URI']\n    /** The user that has claimed the data attributed to this mannequin. */\n    claimant?: Maybe<User>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The mannequin's email on the source instance. */\n    email?: Maybe<Scalars['String']>\n    id: Scalars['ID']\n    /** The username of the actor. */\n    login: Scalars['String']\n    /** The HTML path to this resource. */\n    resourcePath: Scalars['URI']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The URL to this resource. */\n    url: Scalars['URI']\n  }\n\n/** A placeholder user for attribution of imported data on GitHub. */\nexport type MannequinAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** Autogenerated input type of MarkDiscussionCommentAsAnswer */\nexport type MarkDiscussionCommentAsAnswerInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the discussion comment to mark as an answer. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of MarkDiscussionCommentAsAnswer */\nexport type MarkDiscussionCommentAsAnswerPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The discussion that includes the chosen comment. */\n  discussion?: Maybe<Discussion>\n}\n\n/** Autogenerated input type of MarkFileAsViewed */\nexport type MarkFileAsViewedInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The path of the file to mark as viewed */\n  path: Scalars['String']\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID']\n}\n\n/** Autogenerated return type of MarkFileAsViewed */\nexport type MarkFileAsViewedPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Autogenerated input type of MarkPullRequestReadyForReview */\nexport type MarkPullRequestReadyForReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the pull request to be marked as ready for review. */\n  pullRequestId: Scalars['ID']\n}\n\n/** Autogenerated return type of MarkPullRequestReadyForReview */\nexport type MarkPullRequestReadyForReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The pull request that is ready for review. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\nexport type MarkedAsDuplicateEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** The authoritative issue or pull request which has been duplicated by another. */\n  canonical?: Maybe<IssueOrPullRequest>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The issue or pull request which has been marked as a duplicate of another. */\n  duplicate?: Maybe<IssueOrPullRequest>\n  id: Scalars['ID']\n  /** Canonical and duplicate belong to different repositories. */\n  isCrossRepository: Scalars['Boolean']\n}\n\n/** A public description of a Marketplace category. */\nexport type MarketplaceCategory = Node & {\n  /** The category's description. */\n  description?: Maybe<Scalars['String']>\n  /** The technical description of how apps listed in this category work with GitHub. */\n  howItWorks?: Maybe<Scalars['String']>\n  id: Scalars['ID']\n  /** The category's name. */\n  name: Scalars['String']\n  /** How many Marketplace listings have this as their primary category. */\n  primaryListingCount: Scalars['Int']\n  /** The HTTP path for this Marketplace category. */\n  resourcePath: Scalars['URI']\n  /** How many Marketplace listings have this as their secondary category. */\n  secondaryListingCount: Scalars['Int']\n  /** The short name of the category used in its URL. */\n  slug: Scalars['String']\n  /** The HTTP URL for this Marketplace category. */\n  url: Scalars['URI']\n}\n\n/** A listing in the GitHub integration marketplace. */\nexport type MarketplaceListing = Node & {\n  /** The GitHub App this listing represents. */\n  app?: Maybe<App>\n  /** URL to the listing owner's company site. */\n  companyUrl?: Maybe<Scalars['URI']>\n  /** The HTTP path for configuring access to the listing's integration or OAuth app */\n  configurationResourcePath: Scalars['URI']\n  /** The HTTP URL for configuring access to the listing's integration or OAuth app */\n  configurationUrl: Scalars['URI']\n  /** URL to the listing's documentation. */\n  documentationUrl?: Maybe<Scalars['URI']>\n  /** The listing's detailed description. */\n  extendedDescription?: Maybe<Scalars['String']>\n  /** The listing's detailed description rendered to HTML. */\n  extendedDescriptionHTML: Scalars['HTML']\n  /** The listing's introductory description. */\n  fullDescription: Scalars['String']\n  /** The listing's introductory description rendered to HTML. */\n  fullDescriptionHTML: Scalars['HTML']\n  /** Does this listing have any plans with a free trial? */\n  hasPublishedFreeTrialPlans: Scalars['Boolean']\n  /** Does this listing have a terms of service link? */\n  hasTermsOfService: Scalars['Boolean']\n  /** Whether the creator of the app is a verified org */\n  hasVerifiedOwner: Scalars['Boolean']\n  /** A technical description of how this app works with GitHub. */\n  howItWorks?: Maybe<Scalars['String']>\n  /** The listing's technical description rendered to HTML. */\n  howItWorksHTML: Scalars['HTML']\n  id: Scalars['ID']\n  /** URL to install the product to the viewer's account or organization. */\n  installationUrl?: Maybe<Scalars['URI']>\n  /** Whether this listing's app has been installed for the current viewer */\n  installedForViewer: Scalars['Boolean']\n  /** Whether this listing has been removed from the Marketplace. */\n  isArchived: Scalars['Boolean']\n  /**\n   * Whether this listing is still an editable draft that has not been submitted\n   * for review and is not publicly visible in the Marketplace.\n   */\n  isDraft: Scalars['Boolean']\n  /** Whether the product this listing represents is available as part of a paid plan. */\n  isPaid: Scalars['Boolean']\n  /** Whether this listing has been approved for display in the Marketplace. */\n  isPublic: Scalars['Boolean']\n  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */\n  isRejected: Scalars['Boolean']\n  /** Whether this listing has been approved for unverified display in the Marketplace. */\n  isUnverified: Scalars['Boolean']\n  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */\n  isUnverifiedPending: Scalars['Boolean']\n  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */\n  isVerificationPendingFromDraft: Scalars['Boolean']\n  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */\n  isVerificationPendingFromUnverified: Scalars['Boolean']\n  /** Whether this listing has been approved for verified display in the Marketplace. */\n  isVerified: Scalars['Boolean']\n  /** The hex color code, without the leading '#', for the logo background. */\n  logoBackgroundColor: Scalars['String']\n  /** URL for the listing's logo image. */\n  logoUrl?: Maybe<Scalars['URI']>\n  /** The listing's full name. */\n  name: Scalars['String']\n  /** The listing's very short description without a trailing period or ampersands. */\n  normalizedShortDescription: Scalars['String']\n  /** URL to the listing's detailed pricing. */\n  pricingUrl?: Maybe<Scalars['URI']>\n  /** The category that best describes the listing. */\n  primaryCategory: MarketplaceCategory\n  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */\n  privacyPolicyUrl: Scalars['URI']\n  /** The HTTP path for the Marketplace listing. */\n  resourcePath: Scalars['URI']\n  /** The URLs for the listing's screenshots. */\n  screenshotUrls: Array<Maybe<Scalars['String']>>\n  /** An alternate category that describes the listing. */\n  secondaryCategory?: Maybe<MarketplaceCategory>\n  /** The listing's very short description. */\n  shortDescription: Scalars['String']\n  /** The short name of the listing used in its URL. */\n  slug: Scalars['String']\n  /** URL to the listing's status page. */\n  statusUrl?: Maybe<Scalars['URI']>\n  /** An email address for support for this listing's app. */\n  supportEmail?: Maybe<Scalars['String']>\n  /**\n   * Either a URL or an email address for support for this listing's app, may\n   * return an empty string for listings that do not require a support URL.\n   */\n  supportUrl: Scalars['URI']\n  /** URL to the listing's terms of service. */\n  termsOfServiceUrl?: Maybe<Scalars['URI']>\n  /** The HTTP URL for the Marketplace listing. */\n  url: Scalars['URI']\n  /** Can the current viewer add plans for this Marketplace listing. */\n  viewerCanAddPlans: Scalars['Boolean']\n  /** Can the current viewer approve this Marketplace listing. */\n  viewerCanApprove: Scalars['Boolean']\n  /** Can the current viewer delist this Marketplace listing. */\n  viewerCanDelist: Scalars['Boolean']\n  /** Can the current viewer edit this Marketplace listing. */\n  viewerCanEdit: Scalars['Boolean']\n  /**\n   * Can the current viewer edit the primary and secondary category of this\n   * Marketplace listing.\n   */\n  viewerCanEditCategories: Scalars['Boolean']\n  /** Can the current viewer edit the plans for this Marketplace listing. */\n  viewerCanEditPlans: Scalars['Boolean']\n  /**\n   * Can the current viewer return this Marketplace listing to draft state\n   * so it becomes editable again.\n   */\n  viewerCanRedraft: Scalars['Boolean']\n  /**\n   * Can the current viewer reject this Marketplace listing by returning it to\n   * an editable draft state or rejecting it entirely.\n   */\n  viewerCanReject: Scalars['Boolean']\n  /**\n   * Can the current viewer request this listing be reviewed for display in\n   * the Marketplace as verified.\n   */\n  viewerCanRequestApproval: Scalars['Boolean']\n  /** Indicates whether the current user has an active subscription to this Marketplace listing. */\n  viewerHasPurchased: Scalars['Boolean']\n  /**\n   * Indicates if the current user has purchased a subscription to this Marketplace listing\n   * for all of the organizations the user owns.\n   */\n  viewerHasPurchasedForAllOrganizations: Scalars['Boolean']\n  /** Does the current viewer role allow them to administer this Marketplace listing. */\n  viewerIsListingAdmin: Scalars['Boolean']\n}\n\n/** A listing in the GitHub integration marketplace. */\nexport type MarketplaceListingLogoUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** Look up Marketplace Listings */\nexport type MarketplaceListingConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MarketplaceListingEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<MarketplaceListing>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type MarketplaceListingEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<MarketplaceListing>\n}\n\n/** Entities that have members who can set status messages. */\nexport type MemberStatusable = {\n  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n  memberStatuses: UserStatusConnection\n}\n\n/** Entities that have members who can set status messages. */\nexport type MemberStatusableMemberStatusesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<UserStatusOrder>\n}\n\n/** Audit log entry for a members_can_delete_repos.clear event. */\nexport type MembersCanDeleteReposClearAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars['URI']>\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars['String']>\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a members_can_delete_repos.disable event. */\nexport type MembersCanDeleteReposDisableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars['URI']>\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars['String']>\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a members_can_delete_repos.enable event. */\nexport type MembersCanDeleteReposEnableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars['URI']>\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars['String']>\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Represents a 'mentioned' event on a given issue or pull request. */\nexport type MentionedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n}\n\n/** Autogenerated input type of MergeBranch */\nexport type MergeBranchInput = {\n  /** The email address to associate with this commit. */\n  authorEmail?: Maybe<Scalars['String']>\n  /** The name of the base branch that the provided head will be merged into. */\n  base: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Message to use for the merge commit. If omitted, a default will be used. */\n  commitMessage?: Maybe<Scalars['String']>\n  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */\n  head: Scalars['String']\n  /** The Node ID of the Repository containing the base branch that will be modified. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of MergeBranch */\nexport type MergeBranchPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The resulting merge Commit. */\n  mergeCommit?: Maybe<Commit>\n}\n\n/** Autogenerated input type of MergePullRequest */\nexport type MergePullRequestInput = {\n  /** The email address to associate with this merge. */\n  authorEmail?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Commit body to use for the merge commit; if omitted, a default message will be used */\n  commitBody?: Maybe<Scalars['String']>\n  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */\n  commitHeadline?: Maybe<Scalars['String']>\n  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */\n  expectedHeadOid?: Maybe<Scalars['GitObjectID']>\n  /** The merge method to use. If omitted, defaults to 'MERGE' */\n  mergeMethod?: Maybe<PullRequestMergeMethod>\n  /** ID of the pull request to be merged. */\n  pullRequestId: Scalars['ID']\n}\n\n/** Autogenerated return type of MergePullRequest */\nexport type MergePullRequestPayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The pull request that was merged. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Detailed status information about a pull request merge. */\nexport enum MergeStateStatus {\n  /** The head ref is out of date. */\n  Behind = 'BEHIND',\n  /** The merge is blocked. */\n  Blocked = 'BLOCKED',\n  /** Mergeable and passing commit status. */\n  Clean = 'CLEAN',\n  /** The merge commit cannot be cleanly created. */\n  Dirty = 'DIRTY',\n  /** The merge is blocked due to the pull request being a draft. */\n  Draft = 'DRAFT',\n  /** Mergeable with passing commit status and pre-receive hooks. */\n  HasHooks = 'HAS_HOOKS',\n  /** The state cannot currently be determined. */\n  Unknown = 'UNKNOWN',\n  /** Mergeable with non-passing commit status. */\n  Unstable = 'UNSTABLE',\n}\n\n/** Whether or not a PullRequest can be merged. */\nexport enum MergeableState {\n  /** The pull request cannot be merged due to merge conflicts. */\n  Conflicting = 'CONFLICTING',\n  /** The pull request can be merged. */\n  Mergeable = 'MERGEABLE',\n  /** The mergeability of the pull request is still being calculated. */\n  Unknown = 'UNKNOWN',\n}\n\n/** Represents a 'merged' event on a given pull request. */\nexport type MergedEvent = Node &\n  UniformResourceLocatable & {\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>\n    /** Identifies the commit associated with the `merge` event. */\n    commit?: Maybe<Commit>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    id: Scalars['ID']\n    /** Identifies the Ref associated with the `merge` event. */\n    mergeRef?: Maybe<Ref>\n    /** Identifies the name of the Ref associated with the `merge` event. */\n    mergeRefName: Scalars['String']\n    /** PullRequest referenced by event. */\n    pullRequest: PullRequest\n    /** The HTTP path for this merged event. */\n    resourcePath: Scalars['URI']\n    /** The HTTP URL for this merged event. */\n    url: Scalars['URI']\n  }\n\n/** Represents a Milestone object on a given repository. */\nexport type Milestone = Closable &\n  Node &\n  UniformResourceLocatable & {\n    /** `true` if the object is closed (definition of closed may depend on type) */\n    closed: Scalars['Boolean']\n    /** Identifies the date and time when the object was closed. */\n    closedAt?: Maybe<Scalars['DateTime']>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Identifies the actor who created the milestone. */\n    creator?: Maybe<Actor>\n    /** Identifies the description of the milestone. */\n    description?: Maybe<Scalars['String']>\n    /** Identifies the due date of the milestone. */\n    dueOn?: Maybe<Scalars['DateTime']>\n    id: Scalars['ID']\n    /** A list of issues associated with the milestone. */\n    issues: IssueConnection\n    /** Identifies the number of the milestone. */\n    number: Scalars['Int']\n    /** Identifies the percentage complete for the milestone */\n    progressPercentage: Scalars['Float']\n    /** A list of pull requests associated with the milestone. */\n    pullRequests: PullRequestConnection\n    /** The repository associated with this milestone. */\n    repository: Repository\n    /** The HTTP path for this milestone */\n    resourcePath: Scalars['URI']\n    /** Identifies the state of the milestone. */\n    state: MilestoneState\n    /** Identifies the title of the milestone. */\n    title: Scalars['String']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this milestone */\n    url: Scalars['URI']\n  }\n\n/** Represents a Milestone object on a given repository. */\nexport type MilestoneIssuesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  filterBy?: Maybe<IssueFilters>\n  first?: Maybe<Scalars['Int']>\n  labels?: Maybe<Array<Scalars['String']>>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n  states?: Maybe<Array<IssueState>>\n}\n\n/** Represents a Milestone object on a given repository. */\nexport type MilestonePullRequestsArgs = {\n  after?: Maybe<Scalars['String']>\n  baseRefName?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  headRefName?: Maybe<Scalars['String']>\n  labels?: Maybe<Array<Scalars['String']>>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n  states?: Maybe<Array<PullRequestState>>\n}\n\n/** The connection type for Milestone. */\nexport type MilestoneConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MilestoneEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Milestone>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type MilestoneEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Milestone>\n}\n\n/** Types that can be inside a Milestone. */\nexport type MilestoneItem = Issue | PullRequest\n\n/** Ordering options for milestone connections. */\nexport type MilestoneOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order milestones by. */\n  field: MilestoneOrderField\n}\n\n/** Properties by which milestone connections can be ordered. */\nexport enum MilestoneOrderField {\n  /** Order milestones by when they were created. */\n  CreatedAt = 'CREATED_AT',\n  /** Order milestones by when they are due. */\n  DueDate = 'DUE_DATE',\n  /** Order milestones by their number. */\n  Number = 'NUMBER',\n  /** Order milestones by when they were last updated. */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** The possible states of a milestone. */\nexport enum MilestoneState {\n  /** A milestone that has been closed. */\n  Closed = 'CLOSED',\n  /** A milestone that is still open. */\n  Open = 'OPEN',\n}\n\n/** Represents a 'milestoned' event on a given issue or pull request. */\nexport type MilestonedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Identifies the milestone title associated with the 'milestoned' event. */\n  milestoneTitle: Scalars['String']\n  /** Object referenced by event. */\n  subject: MilestoneItem\n}\n\n/** Entities that can be minimized. */\nexport type Minimizable = {\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean']\n  /** Returns why the comment was minimized. */\n  minimizedReason?: Maybe<Scalars['String']>\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean']\n}\n\n/** Autogenerated input type of MinimizeComment */\nexport type MinimizeCommentInput = {\n  /** The classification of comment */\n  classifier: ReportedContentClassifiers\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID']\n}\n\n/** Autogenerated return type of MinimizeComment */\nexport type MinimizeCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The comment that was minimized. */\n  minimizedComment?: Maybe<Minimizable>\n}\n\n/** Autogenerated input type of MoveProjectCard */\nexport type MoveProjectCardInput = {\n  /** Place the new card after the card with this id. Pass null to place it at the top. */\n  afterCardId?: Maybe<Scalars['ID']>\n  /** The id of the card to move. */\n  cardId: Scalars['ID']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The id of the column to move it into. */\n  columnId: Scalars['ID']\n}\n\n/** Autogenerated return type of MoveProjectCard */\nexport type MoveProjectCardPayload = {\n  /** The new edge of the moved card. */\n  cardEdge?: Maybe<ProjectCardEdge>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of MoveProjectColumn */\nexport type MoveProjectColumnInput = {\n  /** Place the new column after the column with this id. Pass null to place it at the front. */\n  afterColumnId?: Maybe<Scalars['ID']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The id of the column to move. */\n  columnId: Scalars['ID']\n}\n\n/** Autogenerated return type of MoveProjectColumn */\nexport type MoveProjectColumnPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new edge of the moved column. */\n  columnEdge?: Maybe<ProjectColumnEdge>\n}\n\n/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\nexport type MovedColumnsInProjectEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** Column name the issue or pull request was moved from. */\n  previousProjectColumnName: Scalars['String']\n  /** Project referenced by event. */\n  project?: Maybe<Project>\n  /** Project card referenced by this project event. */\n  projectCard?: Maybe<ProjectCard>\n  /** Column name the issue or pull request was moved to. */\n  projectColumnName: Scalars['String']\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type Mutation = {\n  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */\n  acceptEnterpriseAdministratorInvitation?: Maybe<AcceptEnterpriseAdministratorInvitationPayload>\n  /** Applies a suggested topic to the repository. */\n  acceptTopicSuggestion?: Maybe<AcceptTopicSuggestionPayload>\n  /** Adds assignees to an assignable object. */\n  addAssigneesToAssignable?: Maybe<AddAssigneesToAssignablePayload>\n  /** Adds a comment to an Issue or Pull Request. */\n  addComment?: Maybe<AddCommentPayload>\n  /** Adds a comment to a Discussion, possibly as a reply to another comment. */\n  addDiscussionComment?: Maybe<AddDiscussionCommentPayload>\n  /** Adds a support entitlement to an enterprise member. */\n  addEnterpriseSupportEntitlement?: Maybe<AddEnterpriseSupportEntitlementPayload>\n  /** Adds labels to a labelable object. */\n  addLabelsToLabelable?: Maybe<AddLabelsToLabelablePayload>\n  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */\n  addProjectCard?: Maybe<AddProjectCardPayload>\n  /** Adds a column to a Project. */\n  addProjectColumn?: Maybe<AddProjectColumnPayload>\n  /** Adds an existing item (Issue or PullRequest) to a Project. */\n  addProjectNextItem?: Maybe<AddProjectNextItemPayload>\n  /** Adds a review to a Pull Request. */\n  addPullRequestReview?: Maybe<AddPullRequestReviewPayload>\n  /** Adds a comment to a review. */\n  addPullRequestReviewComment?: Maybe<AddPullRequestReviewCommentPayload>\n  /** Adds a new thread to a pending Pull Request Review. */\n  addPullRequestReviewThread?: Maybe<AddPullRequestReviewThreadPayload>\n  /** Adds a reaction to a subject. */\n  addReaction?: Maybe<AddReactionPayload>\n  /** Adds a star to a Starrable. */\n  addStar?: Maybe<AddStarPayload>\n  /** Add an upvote to a discussion or discussion comment. */\n  addUpvote?: Maybe<AddUpvotePayload>\n  /** Adds a verifiable domain to an owning account. */\n  addVerifiableDomain?: Maybe<AddVerifiableDomainPayload>\n  /** Approve all pending deployments under one or more environments */\n  approveDeployments?: Maybe<ApproveDeploymentsPayload>\n  /** Approve a verifiable domain for notification delivery. */\n  approveVerifiableDomain?: Maybe<ApproveVerifiableDomainPayload>\n  /** Marks a repository as archived. */\n  archiveRepository?: Maybe<ArchiveRepositoryPayload>\n  /** Cancels a pending invitation for an administrator to join an enterprise. */\n  cancelEnterpriseAdminInvitation?: Maybe<CancelEnterpriseAdminInvitationPayload>\n  /** Cancel an active sponsorship. */\n  cancelSponsorship?: Maybe<CancelSponsorshipPayload>\n  /** Update your status on GitHub. */\n  changeUserStatus?: Maybe<ChangeUserStatusPayload>\n  /** Clears all labels from a labelable object. */\n  clearLabelsFromLabelable?: Maybe<ClearLabelsFromLabelablePayload>\n  /** Creates a new project by cloning configuration from an existing project. */\n  cloneProject?: Maybe<CloneProjectPayload>\n  /** Create a new repository with the same files and directory structure as a template repository. */\n  cloneTemplateRepository?: Maybe<CloneTemplateRepositoryPayload>\n  /** Close an issue. */\n  closeIssue?: Maybe<CloseIssuePayload>\n  /** Close a pull request. */\n  closePullRequest?: Maybe<ClosePullRequestPayload>\n  /** Convert a project note card to one associated with a newly created issue. */\n  convertProjectCardNoteToIssue?: Maybe<ConvertProjectCardNoteToIssuePayload>\n  /** Converts a pull request to draft */\n  convertPullRequestToDraft?: Maybe<ConvertPullRequestToDraftPayload>\n  /** Create a new branch protection rule */\n  createBranchProtectionRule?: Maybe<CreateBranchProtectionRulePayload>\n  /** Create a check run. */\n  createCheckRun?: Maybe<CreateCheckRunPayload>\n  /** Create a check suite */\n  createCheckSuite?: Maybe<CreateCheckSuitePayload>\n  /**\n   * Appends a commit to the given branch as the authenticated user.\n   *\n   * This mutation creates a commit whose parent is the HEAD of the provided\n   * branch and also updates that branch to point to the new commit.\n   * It can be thought of as similar to `git commit`.\n   *\n   * ### Locating a Branch\n   *\n   * Commits are appended to a `branch` of type `Ref`.\n   * This must refer to a git branch (i.e.  the fully qualified path must\n   * begin with `refs/heads/`, although including this prefix is optional.\n   *\n   * Callers may specify the `branch` to commit to either by its global node\n   * ID or by passing both of `repositoryNameWithOwner` and `refName`.  For\n   * more details see the documentation for `CommittableBranch`.\n   *\n   * ### Describing Changes\n   *\n   * `fileChanges` are specified as a `FilesChanges` object describing\n   * `FileAdditions` and `FileDeletions`.\n   *\n   * Please see the documentation for `FileChanges` for more information on\n   * how to use this argument to describe any set of file changes.\n   *\n   * ### Authorship\n   *\n   * Similar to the web commit interface, this mutation does not support\n   * specifying the author or committer of the commit and will not add\n   * support for this in the future.\n   *\n   * A commit created by a successful execution of this mutation will be\n   * authored by the owner of the credential which authenticates the API\n   * request.  The committer will be identical to that of commits authored\n   * using the web interface.\n   *\n   * If you need full control over author and committer information, please\n   * use the Git Database REST API instead.\n   *\n   * ### Commit Signing\n   *\n   * Commits made using this mutation are automatically signed by GitHub if\n   * supported and will be marked as verified in the user interface.\n   */\n  createCommitOnBranch?: Maybe<CreateCommitOnBranchPayload>\n  /** Create a content attachment. */\n  createContentAttachment?: Maybe<CreateContentAttachmentPayload>\n  /** Creates a new deployment event. */\n  createDeployment?: Maybe<CreateDeploymentPayload>\n  /** Create a deployment status. */\n  createDeploymentStatus?: Maybe<CreateDeploymentStatusPayload>\n  /** Create a discussion. */\n  createDiscussion?: Maybe<CreateDiscussionPayload>\n  /** Creates an organization as part of an enterprise account. */\n  createEnterpriseOrganization?: Maybe<CreateEnterpriseOrganizationPayload>\n  /** Creates an environment or simply returns it if already exists. */\n  createEnvironment?: Maybe<CreateEnvironmentPayload>\n  /** Creates a new IP allow list entry. */\n  createIpAllowListEntry?: Maybe<CreateIpAllowListEntryPayload>\n  /** Creates a new issue. */\n  createIssue?: Maybe<CreateIssuePayload>\n  /** Creates a new label. */\n  createLabel?: Maybe<CreateLabelPayload>\n  /** Creates a new project. */\n  createProject?: Maybe<CreateProjectPayload>\n  /** Create a new pull request */\n  createPullRequest?: Maybe<CreatePullRequestPayload>\n  /** Create a new Git Ref. */\n  createRef?: Maybe<CreateRefPayload>\n  /** Create a new repository. */\n  createRepository?: Maybe<CreateRepositoryPayload>\n  /** Start a new sponsorship of a maintainer in GitHub Sponsors, or reactivate a past sponsorship. */\n  createSponsorship?: Maybe<CreateSponsorshipPayload>\n  /** Creates a new team discussion. */\n  createTeamDiscussion?: Maybe<CreateTeamDiscussionPayload>\n  /** Creates a new team discussion comment. */\n  createTeamDiscussionComment?: Maybe<CreateTeamDiscussionCommentPayload>\n  /** Rejects a suggested topic for the repository. */\n  declineTopicSuggestion?: Maybe<DeclineTopicSuggestionPayload>\n  /** Delete a branch protection rule */\n  deleteBranchProtectionRule?: Maybe<DeleteBranchProtectionRulePayload>\n  /** Deletes a deployment. */\n  deleteDeployment?: Maybe<DeleteDeploymentPayload>\n  /** Delete a discussion and all of its replies. */\n  deleteDiscussion?: Maybe<DeleteDiscussionPayload>\n  /** Delete a discussion comment. If it has replies, wipe it instead. */\n  deleteDiscussionComment?: Maybe<DeleteDiscussionCommentPayload>\n  /** Deletes an environment */\n  deleteEnvironment?: Maybe<DeleteEnvironmentPayload>\n  /** Deletes an IP allow list entry. */\n  deleteIpAllowListEntry?: Maybe<DeleteIpAllowListEntryPayload>\n  /** Deletes an Issue object. */\n  deleteIssue?: Maybe<DeleteIssuePayload>\n  /** Deletes an IssueComment object. */\n  deleteIssueComment?: Maybe<DeleteIssueCommentPayload>\n  /** Deletes a label. */\n  deleteLabel?: Maybe<DeleteLabelPayload>\n  /** Delete a package version. */\n  deletePackageVersion?: Maybe<DeletePackageVersionPayload>\n  /** Deletes a project. */\n  deleteProject?: Maybe<DeleteProjectPayload>\n  /** Deletes a project card. */\n  deleteProjectCard?: Maybe<DeleteProjectCardPayload>\n  /** Deletes a project column. */\n  deleteProjectColumn?: Maybe<DeleteProjectColumnPayload>\n  /** Deletes an item from a Project. */\n  deleteProjectNextItem?: Maybe<DeleteProjectNextItemPayload>\n  /** Deletes a pull request review. */\n  deletePullRequestReview?: Maybe<DeletePullRequestReviewPayload>\n  /** Deletes a pull request review comment. */\n  deletePullRequestReviewComment?: Maybe<DeletePullRequestReviewCommentPayload>\n  /** Delete a Git Ref. */\n  deleteRef?: Maybe<DeleteRefPayload>\n  /** Deletes a team discussion. */\n  deleteTeamDiscussion?: Maybe<DeleteTeamDiscussionPayload>\n  /** Deletes a team discussion comment. */\n  deleteTeamDiscussionComment?: Maybe<DeleteTeamDiscussionCommentPayload>\n  /** Deletes a verifiable domain. */\n  deleteVerifiableDomain?: Maybe<DeleteVerifiableDomainPayload>\n  /** Disable auto merge on the given pull request */\n  disablePullRequestAutoMerge?: Maybe<DisablePullRequestAutoMergePayload>\n  /** Dismisses an approved or rejected pull request review. */\n  dismissPullRequestReview?: Maybe<DismissPullRequestReviewPayload>\n  /** Dismisses the Dependabot alert. */\n  dismissRepositoryVulnerabilityAlert?: Maybe<DismissRepositoryVulnerabilityAlertPayload>\n  /** Enable the default auto-merge on a pull request. */\n  enablePullRequestAutoMerge?: Maybe<EnablePullRequestAutoMergePayload>\n  /** Follow a user. */\n  followUser?: Maybe<FollowUserPayload>\n  /** Creates a new project by importing columns and a list of issues/PRs. */\n  importProject?: Maybe<ImportProjectPayload>\n  /** Invite someone to become an administrator of the enterprise. */\n  inviteEnterpriseAdmin?: Maybe<InviteEnterpriseAdminPayload>\n  /** Creates a repository link for a project. */\n  linkRepositoryToProject?: Maybe<LinkRepositoryToProjectPayload>\n  /** Lock a lockable object */\n  lockLockable?: Maybe<LockLockablePayload>\n  /** Mark a discussion comment as the chosen answer for discussions in an answerable category. */\n  markDiscussionCommentAsAnswer?: Maybe<MarkDiscussionCommentAsAnswerPayload>\n  /** Mark a pull request file as viewed */\n  markFileAsViewed?: Maybe<MarkFileAsViewedPayload>\n  /** Marks a pull request ready for review. */\n  markPullRequestReadyForReview?: Maybe<MarkPullRequestReadyForReviewPayload>\n  /** Merge a head into a branch. */\n  mergeBranch?: Maybe<MergeBranchPayload>\n  /** Merge a pull request. */\n  mergePullRequest?: Maybe<MergePullRequestPayload>\n  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */\n  minimizeComment?: Maybe<MinimizeCommentPayload>\n  /** Moves a project card to another place. */\n  moveProjectCard?: Maybe<MoveProjectCardPayload>\n  /** Moves a project column to another place. */\n  moveProjectColumn?: Maybe<MoveProjectColumnPayload>\n  /** Pin an issue to a repository */\n  pinIssue?: Maybe<PinIssuePayload>\n  /** Regenerates the identity provider recovery codes for an enterprise */\n  regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>\n  /** Regenerates a verifiable domain's verification token. */\n  regenerateVerifiableDomainToken?: Maybe<RegenerateVerifiableDomainTokenPayload>\n  /** Reject all pending deployments under one or more environments */\n  rejectDeployments?: Maybe<RejectDeploymentsPayload>\n  /** Removes assignees from an assignable object. */\n  removeAssigneesFromAssignable?: Maybe<RemoveAssigneesFromAssignablePayload>\n  /** Removes an administrator from the enterprise. */\n  removeEnterpriseAdmin?: Maybe<RemoveEnterpriseAdminPayload>\n  /** Removes the identity provider from an enterprise */\n  removeEnterpriseIdentityProvider?: Maybe<RemoveEnterpriseIdentityProviderPayload>\n  /** Removes an organization from the enterprise */\n  removeEnterpriseOrganization?: Maybe<RemoveEnterpriseOrganizationPayload>\n  /** Removes a support entitlement from an enterprise member. */\n  removeEnterpriseSupportEntitlement?: Maybe<RemoveEnterpriseSupportEntitlementPayload>\n  /** Removes labels from a Labelable object. */\n  removeLabelsFromLabelable?: Maybe<RemoveLabelsFromLabelablePayload>\n  /** Removes outside collaborator from all repositories in an organization. */\n  removeOutsideCollaborator?: Maybe<RemoveOutsideCollaboratorPayload>\n  /** Removes a reaction from a subject. */\n  removeReaction?: Maybe<RemoveReactionPayload>\n  /** Removes a star from a Starrable. */\n  removeStar?: Maybe<RemoveStarPayload>\n  /** Remove an upvote to a discussion or discussion comment. */\n  removeUpvote?: Maybe<RemoveUpvotePayload>\n  /** Reopen a issue. */\n  reopenIssue?: Maybe<ReopenIssuePayload>\n  /** Reopen a pull request. */\n  reopenPullRequest?: Maybe<ReopenPullRequestPayload>\n  /** Set review requests on a pull request. */\n  requestReviews?: Maybe<RequestReviewsPayload>\n  /** Rerequests an existing check suite. */\n  rerequestCheckSuite?: Maybe<RerequestCheckSuitePayload>\n  /** Marks a review thread as resolved. */\n  resolveReviewThread?: Maybe<ResolveReviewThreadPayload>\n  /** Creates or updates the identity provider for an enterprise. */\n  setEnterpriseIdentityProvider?: Maybe<SetEnterpriseIdentityProviderPayload>\n  /** Set an organization level interaction limit for an organization's public repositories. */\n  setOrganizationInteractionLimit?: Maybe<SetOrganizationInteractionLimitPayload>\n  /** Sets an interaction limit setting for a repository. */\n  setRepositoryInteractionLimit?: Maybe<SetRepositoryInteractionLimitPayload>\n  /** Set a user level interaction limit for an user's public repositories. */\n  setUserInteractionLimit?: Maybe<SetUserInteractionLimitPayload>\n  /** Submits a pending pull request review. */\n  submitPullRequestReview?: Maybe<SubmitPullRequestReviewPayload>\n  /** Transfer an issue to a different repository */\n  transferIssue?: Maybe<TransferIssuePayload>\n  /** Unarchives a repository. */\n  unarchiveRepository?: Maybe<UnarchiveRepositoryPayload>\n  /** Unfollow a user. */\n  unfollowUser?: Maybe<UnfollowUserPayload>\n  /** Deletes a repository link from a project. */\n  unlinkRepositoryFromProject?: Maybe<UnlinkRepositoryFromProjectPayload>\n  /** Unlock a lockable object */\n  unlockLockable?: Maybe<UnlockLockablePayload>\n  /** Unmark a discussion comment as the chosen answer for discussions in an answerable category. */\n  unmarkDiscussionCommentAsAnswer?: Maybe<UnmarkDiscussionCommentAsAnswerPayload>\n  /** Unmark a pull request file as viewed */\n  unmarkFileAsViewed?: Maybe<UnmarkFileAsViewedPayload>\n  /** Unmark an issue as a duplicate of another issue. */\n  unmarkIssueAsDuplicate?: Maybe<UnmarkIssueAsDuplicatePayload>\n  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */\n  unminimizeComment?: Maybe<UnminimizeCommentPayload>\n  /** Unpin a pinned issue from a repository */\n  unpinIssue?: Maybe<UnpinIssuePayload>\n  /** Marks a review thread as unresolved. */\n  unresolveReviewThread?: Maybe<UnresolveReviewThreadPayload>\n  /** Create a new branch protection rule */\n  updateBranchProtectionRule?: Maybe<UpdateBranchProtectionRulePayload>\n  /** Update a check run */\n  updateCheckRun?: Maybe<UpdateCheckRunPayload>\n  /** Modifies the settings of an existing check suite */\n  updateCheckSuitePreferences?: Maybe<UpdateCheckSuitePreferencesPayload>\n  /** Update a discussion */\n  updateDiscussion?: Maybe<UpdateDiscussionPayload>\n  /** Update the contents of a comment on a Discussion */\n  updateDiscussionComment?: Maybe<UpdateDiscussionCommentPayload>\n  /** Updates the role of an enterprise administrator. */\n  updateEnterpriseAdministratorRole?: Maybe<UpdateEnterpriseAdministratorRolePayload>\n  /** Sets whether private repository forks are enabled for an enterprise. */\n  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>\n  /** Sets the base repository permission for organizations in an enterprise. */\n  updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>\n  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */\n  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>\n  /** Sets the members can create repositories setting for an enterprise. */\n  updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>\n  /** Sets the members can delete issues setting for an enterprise. */\n  updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>\n  /** Sets the members can delete repositories setting for an enterprise. */\n  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>\n  /** Sets whether members can invite collaborators are enabled for an enterprise. */\n  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>\n  /** Sets whether or not an organization admin can make purchases. */\n  updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<UpdateEnterpriseMembersCanMakePurchasesSettingPayload>\n  /** Sets the members can update protected branches setting for an enterprise. */\n  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>\n  /** Sets the members can view dependency insights for an enterprise. */\n  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>\n  /** Sets whether organization projects are enabled for an enterprise. */\n  updateEnterpriseOrganizationProjectsSetting?: Maybe<UpdateEnterpriseOrganizationProjectsSettingPayload>\n  /** Updates an enterprise's profile. */\n  updateEnterpriseProfile?: Maybe<UpdateEnterpriseProfilePayload>\n  /** Sets whether repository projects are enabled for a enterprise. */\n  updateEnterpriseRepositoryProjectsSetting?: Maybe<UpdateEnterpriseRepositoryProjectsSettingPayload>\n  /** Sets whether team discussions are enabled for an enterprise. */\n  updateEnterpriseTeamDiscussionsSetting?: Maybe<UpdateEnterpriseTeamDiscussionsSettingPayload>\n  /** Sets whether two factor authentication is required for all users in an enterprise. */\n  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>\n  /** Updates an environment. */\n  updateEnvironment?: Maybe<UpdateEnvironmentPayload>\n  /** Sets whether an IP allow list is enabled on an owner. */\n  updateIpAllowListEnabledSetting?: Maybe<UpdateIpAllowListEnabledSettingPayload>\n  /** Updates an IP allow list entry. */\n  updateIpAllowListEntry?: Maybe<UpdateIpAllowListEntryPayload>\n  /** Sets whether IP allow list configuration for installed GitHub Apps is enabled on an owner. */\n  updateIpAllowListForInstalledAppsEnabledSetting?: Maybe<UpdateIpAllowListForInstalledAppsEnabledSettingPayload>\n  /** Updates an Issue. */\n  updateIssue?: Maybe<UpdateIssuePayload>\n  /** Updates an IssueComment object. */\n  updateIssueComment?: Maybe<UpdateIssueCommentPayload>\n  /** Updates an existing label. */\n  updateLabel?: Maybe<UpdateLabelPayload>\n  /** Update the setting to restrict notifications to only verified or approved domains available to an owner. */\n  updateNotificationRestrictionSetting?: Maybe<UpdateNotificationRestrictionSettingPayload>\n  /** Updates an existing project. */\n  updateProject?: Maybe<UpdateProjectPayload>\n  /** Updates an existing project card. */\n  updateProjectCard?: Maybe<UpdateProjectCardPayload>\n  /** Updates an existing project column. */\n  updateProjectColumn?: Maybe<UpdateProjectColumnPayload>\n  /** Updates a field of an item from a Project. */\n  updateProjectNextItemField?: Maybe<UpdateProjectNextItemFieldPayload>\n  /** Update a pull request */\n  updatePullRequest?: Maybe<UpdatePullRequestPayload>\n  /** Updates the body of a pull request review. */\n  updatePullRequestReview?: Maybe<UpdatePullRequestReviewPayload>\n  /** Updates a pull request review comment. */\n  updatePullRequestReviewComment?: Maybe<UpdatePullRequestReviewCommentPayload>\n  /** Update a Git Ref. */\n  updateRef?: Maybe<UpdateRefPayload>\n  /**\n   * Creates, updates and/or deletes multiple refs in a repository.\n   *\n   * This mutation takes a list of `RefUpdate`s and performs these updates\n   * on the repository. All updates are performed atomically, meaning that\n   * if one of them is rejected, no other ref will be modified.\n   *\n   * `RefUpdate.beforeOid` specifies that the given reference needs to point\n   * to the given value before performing any updates. A value of\n   * `0000000000000000000000000000000000000000` can be used to verify that\n   * the references should not exist.\n   *\n   * `RefUpdate.afterOid` specifies the value that the given reference\n   * will point to after performing all updates. A value of\n   * `0000000000000000000000000000000000000000` can be used to delete a\n   * reference.\n   *\n   * If `RefUpdate.force` is set to `true`, a non-fast-forward updates\n   * for the given reference will be allowed.\n   */\n  updateRefs?: Maybe<UpdateRefsPayload>\n  /** Update information about a repository. */\n  updateRepository?: Maybe<UpdateRepositoryPayload>\n  /** Change visibility of your sponsorship and opt in or out of email updates from the maintainer. */\n  updateSponsorshipPreferences?: Maybe<UpdateSponsorshipPreferencesPayload>\n  /** Updates the state for subscribable subjects. */\n  updateSubscription?: Maybe<UpdateSubscriptionPayload>\n  /** Updates a team discussion. */\n  updateTeamDiscussion?: Maybe<UpdateTeamDiscussionPayload>\n  /** Updates a discussion comment. */\n  updateTeamDiscussionComment?: Maybe<UpdateTeamDiscussionCommentPayload>\n  /** Updates team review assignment. */\n  updateTeamReviewAssignment?: Maybe<UpdateTeamReviewAssignmentPayload>\n  /** Replaces the repository's topics with the given topics. */\n  updateTopics?: Maybe<UpdateTopicsPayload>\n  /** Verify that a verifiable domain has the expected DNS record. */\n  verifyVerifiableDomain?: Maybe<VerifyVerifiableDomainPayload>\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAcceptEnterpriseAdministratorInvitationArgs = {\n  input: AcceptEnterpriseAdministratorInvitationInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAcceptTopicSuggestionArgs = {\n  input: AcceptTopicSuggestionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddAssigneesToAssignableArgs = {\n  input: AddAssigneesToAssignableInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddCommentArgs = {\n  input: AddCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddDiscussionCommentArgs = {\n  input: AddDiscussionCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddEnterpriseSupportEntitlementArgs = {\n  input: AddEnterpriseSupportEntitlementInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddLabelsToLabelableArgs = {\n  input: AddLabelsToLabelableInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectCardArgs = {\n  input: AddProjectCardInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectColumnArgs = {\n  input: AddProjectColumnInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectNextItemArgs = {\n  input: AddProjectNextItemInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewArgs = {\n  input: AddPullRequestReviewInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewCommentArgs = {\n  input: AddPullRequestReviewCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewThreadArgs = {\n  input: AddPullRequestReviewThreadInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddReactionArgs = {\n  input: AddReactionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddStarArgs = {\n  input: AddStarInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddUpvoteArgs = {\n  input: AddUpvoteInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddVerifiableDomainArgs = {\n  input: AddVerifiableDomainInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationApproveDeploymentsArgs = {\n  input: ApproveDeploymentsInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationApproveVerifiableDomainArgs = {\n  input: ApproveVerifiableDomainInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationArchiveRepositoryArgs = {\n  input: ArchiveRepositoryInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCancelEnterpriseAdminInvitationArgs = {\n  input: CancelEnterpriseAdminInvitationInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCancelSponsorshipArgs = {\n  input: CancelSponsorshipInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationChangeUserStatusArgs = {\n  input: ChangeUserStatusInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationClearLabelsFromLabelableArgs = {\n  input: ClearLabelsFromLabelableInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloneProjectArgs = {\n  input: CloneProjectInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloneTemplateRepositoryArgs = {\n  input: CloneTemplateRepositoryInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloseIssueArgs = {\n  input: CloseIssueInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationClosePullRequestArgs = {\n  input: ClosePullRequestInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationConvertProjectCardNoteToIssueArgs = {\n  input: ConvertProjectCardNoteToIssueInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationConvertPullRequestToDraftArgs = {\n  input: ConvertPullRequestToDraftInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateBranchProtectionRuleArgs = {\n  input: CreateBranchProtectionRuleInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCheckRunArgs = {\n  input: CreateCheckRunInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCheckSuiteArgs = {\n  input: CreateCheckSuiteInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCommitOnBranchArgs = {\n  input: CreateCommitOnBranchInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateContentAttachmentArgs = {\n  input: CreateContentAttachmentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateDeploymentArgs = {\n  input: CreateDeploymentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateDeploymentStatusArgs = {\n  input: CreateDeploymentStatusInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateDiscussionArgs = {\n  input: CreateDiscussionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateEnterpriseOrganizationArgs = {\n  input: CreateEnterpriseOrganizationInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateEnvironmentArgs = {\n  input: CreateEnvironmentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateIpAllowListEntryArgs = {\n  input: CreateIpAllowListEntryInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateIssueArgs = {\n  input: CreateIssueInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateLabelArgs = {\n  input: CreateLabelInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateProjectArgs = {\n  input: CreateProjectInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreatePullRequestArgs = {\n  input: CreatePullRequestInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateRefArgs = {\n  input: CreateRefInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateRepositoryArgs = {\n  input: CreateRepositoryInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorshipArgs = {\n  input: CreateSponsorshipInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateTeamDiscussionArgs = {\n  input: CreateTeamDiscussionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateTeamDiscussionCommentArgs = {\n  input: CreateTeamDiscussionCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeclineTopicSuggestionArgs = {\n  input: DeclineTopicSuggestionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteBranchProtectionRuleArgs = {\n  input: DeleteBranchProtectionRuleInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDeploymentArgs = {\n  input: DeleteDeploymentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDiscussionArgs = {\n  input: DeleteDiscussionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDiscussionCommentArgs = {\n  input: DeleteDiscussionCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteEnvironmentArgs = {\n  input: DeleteEnvironmentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIpAllowListEntryArgs = {\n  input: DeleteIpAllowListEntryInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIssueArgs = {\n  input: DeleteIssueInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIssueCommentArgs = {\n  input: DeleteIssueCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteLabelArgs = {\n  input: DeleteLabelInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePackageVersionArgs = {\n  input: DeletePackageVersionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectArgs = {\n  input: DeleteProjectInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectCardArgs = {\n  input: DeleteProjectCardInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectColumnArgs = {\n  input: DeleteProjectColumnInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectNextItemArgs = {\n  input: DeleteProjectNextItemInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePullRequestReviewArgs = {\n  input: DeletePullRequestReviewInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePullRequestReviewCommentArgs = {\n  input: DeletePullRequestReviewCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteRefArgs = {\n  input: DeleteRefInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteTeamDiscussionArgs = {\n  input: DeleteTeamDiscussionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteTeamDiscussionCommentArgs = {\n  input: DeleteTeamDiscussionCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteVerifiableDomainArgs = {\n  input: DeleteVerifiableDomainInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDisablePullRequestAutoMergeArgs = {\n  input: DisablePullRequestAutoMergeInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDismissPullRequestReviewArgs = {\n  input: DismissPullRequestReviewInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDismissRepositoryVulnerabilityAlertArgs = {\n  input: DismissRepositoryVulnerabilityAlertInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationEnablePullRequestAutoMergeArgs = {\n  input: EnablePullRequestAutoMergeInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationFollowUserArgs = {\n  input: FollowUserInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationImportProjectArgs = {\n  input: ImportProjectInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationInviteEnterpriseAdminArgs = {\n  input: InviteEnterpriseAdminInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLinkRepositoryToProjectArgs = {\n  input: LinkRepositoryToProjectInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLockLockableArgs = {\n  input: LockLockableInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkDiscussionCommentAsAnswerArgs = {\n  input: MarkDiscussionCommentAsAnswerInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkFileAsViewedArgs = {\n  input: MarkFileAsViewedInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkPullRequestReadyForReviewArgs = {\n  input: MarkPullRequestReadyForReviewInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMergeBranchArgs = {\n  input: MergeBranchInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMergePullRequestArgs = {\n  input: MergePullRequestInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMinimizeCommentArgs = {\n  input: MinimizeCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMoveProjectCardArgs = {\n  input: MoveProjectCardInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMoveProjectColumnArgs = {\n  input: MoveProjectColumnInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationPinIssueArgs = {\n  input: PinIssueInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs = {\n  input: RegenerateEnterpriseIdentityProviderRecoveryCodesInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRegenerateVerifiableDomainTokenArgs = {\n  input: RegenerateVerifiableDomainTokenInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRejectDeploymentsArgs = {\n  input: RejectDeploymentsInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveAssigneesFromAssignableArgs = {\n  input: RemoveAssigneesFromAssignableInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseAdminArgs = {\n  input: RemoveEnterpriseAdminInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseIdentityProviderArgs = {\n  input: RemoveEnterpriseIdentityProviderInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseOrganizationArgs = {\n  input: RemoveEnterpriseOrganizationInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseSupportEntitlementArgs = {\n  input: RemoveEnterpriseSupportEntitlementInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveLabelsFromLabelableArgs = {\n  input: RemoveLabelsFromLabelableInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveOutsideCollaboratorArgs = {\n  input: RemoveOutsideCollaboratorInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveReactionArgs = {\n  input: RemoveReactionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveStarArgs = {\n  input: RemoveStarInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveUpvoteArgs = {\n  input: RemoveUpvoteInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationReopenIssueArgs = {\n  input: ReopenIssueInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationReopenPullRequestArgs = {\n  input: ReopenPullRequestInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRequestReviewsArgs = {\n  input: RequestReviewsInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRerequestCheckSuiteArgs = {\n  input: RerequestCheckSuiteInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationResolveReviewThreadArgs = {\n  input: ResolveReviewThreadInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetEnterpriseIdentityProviderArgs = {\n  input: SetEnterpriseIdentityProviderInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetOrganizationInteractionLimitArgs = {\n  input: SetOrganizationInteractionLimitInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetRepositoryInteractionLimitArgs = {\n  input: SetRepositoryInteractionLimitInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetUserInteractionLimitArgs = {\n  input: SetUserInteractionLimitInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSubmitPullRequestReviewArgs = {\n  input: SubmitPullRequestReviewInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationTransferIssueArgs = {\n  input: TransferIssueInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnarchiveRepositoryArgs = {\n  input: UnarchiveRepositoryInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnfollowUserArgs = {\n  input: UnfollowUserInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlinkRepositoryFromProjectArgs = {\n  input: UnlinkRepositoryFromProjectInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlockLockableArgs = {\n  input: UnlockLockableInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkDiscussionCommentAsAnswerArgs = {\n  input: UnmarkDiscussionCommentAsAnswerInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkFileAsViewedArgs = {\n  input: UnmarkFileAsViewedInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkIssueAsDuplicateArgs = {\n  input: UnmarkIssueAsDuplicateInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnminimizeCommentArgs = {\n  input: UnminimizeCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnpinIssueArgs = {\n  input: UnpinIssueInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnresolveReviewThreadArgs = {\n  input: UnresolveReviewThreadInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateBranchProtectionRuleArgs = {\n  input: UpdateBranchProtectionRuleInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateCheckRunArgs = {\n  input: UpdateCheckRunInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateCheckSuitePreferencesArgs = {\n  input: UpdateCheckSuitePreferencesInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateDiscussionArgs = {\n  input: UpdateDiscussionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateDiscussionCommentArgs = {\n  input: UpdateDiscussionCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseAdministratorRoleArgs = {\n  input: UpdateEnterpriseAdministratorRoleInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {\n  input: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs = {\n  input: UpdateEnterpriseDefaultRepositoryPermissionSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {\n  input: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {\n  input: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs = {\n  input: UpdateEnterpriseMembersCanDeleteIssuesSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {\n  input: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {\n  input: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs = {\n  input: UpdateEnterpriseMembersCanMakePurchasesSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {\n  input: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {\n  input: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseOrganizationProjectsSettingArgs = {\n  input: UpdateEnterpriseOrganizationProjectsSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseProfileArgs = {\n  input: UpdateEnterpriseProfileInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseRepositoryProjectsSettingArgs = {\n  input: UpdateEnterpriseRepositoryProjectsSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseTeamDiscussionsSettingArgs = {\n  input: UpdateEnterpriseTeamDiscussionsSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {\n  input: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnvironmentArgs = {\n  input: UpdateEnvironmentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListEnabledSettingArgs = {\n  input: UpdateIpAllowListEnabledSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListEntryArgs = {\n  input: UpdateIpAllowListEntryInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListForInstalledAppsEnabledSettingArgs = {\n  input: UpdateIpAllowListForInstalledAppsEnabledSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIssueArgs = {\n  input: UpdateIssueInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIssueCommentArgs = {\n  input: UpdateIssueCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateLabelArgs = {\n  input: UpdateLabelInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateNotificationRestrictionSettingArgs = {\n  input: UpdateNotificationRestrictionSettingInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectArgs = {\n  input: UpdateProjectInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectCardArgs = {\n  input: UpdateProjectCardInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectColumnArgs = {\n  input: UpdateProjectColumnInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectNextItemFieldArgs = {\n  input: UpdateProjectNextItemFieldInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestArgs = {\n  input: UpdatePullRequestInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestReviewArgs = {\n  input: UpdatePullRequestReviewInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestReviewCommentArgs = {\n  input: UpdatePullRequestReviewCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRefArgs = {\n  input: UpdateRefInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRefsArgs = {\n  input: UpdateRefsInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRepositoryArgs = {\n  input: UpdateRepositoryInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateSponsorshipPreferencesArgs = {\n  input: UpdateSponsorshipPreferencesInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateSubscriptionArgs = {\n  input: UpdateSubscriptionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamDiscussionArgs = {\n  input: UpdateTeamDiscussionInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamDiscussionCommentArgs = {\n  input: UpdateTeamDiscussionCommentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamReviewAssignmentArgs = {\n  input: UpdateTeamReviewAssignmentInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTopicsArgs = {\n  input: UpdateTopicsInput\n}\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationVerifyVerifiableDomainArgs = {\n  input: VerifyVerifiableDomainInput\n}\n\n/** An object with an ID. */\nexport type Node = {\n  /** ID of the object. */\n  id: Scalars['ID']\n}\n\n/** The possible values for the notification restriction setting. */\nexport enum NotificationRestrictionSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED',\n}\n\n/** An OIDC identity provider configured to provision identities for an enterprise. */\nexport type OidcProvider = Node & {\n  /** The enterprise this identity provider belongs to. */\n  enterprise?: Maybe<Enterprise>\n  /** ExternalIdentities provisioned by this identity provider. */\n  externalIdentities: ExternalIdentityConnection\n  id: Scalars['ID']\n  /** The OIDC identity provider type */\n  providerType: OidcProviderType\n  /** The id of the tenant this provider is attached to */\n  tenantId: Scalars['String']\n}\n\n/** An OIDC identity provider configured to provision identities for an enterprise. */\nexport type OidcProviderExternalIdentitiesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  membersOnly?: Maybe<Scalars['Boolean']>\n}\n\n/** The OIDC identity provider type */\nexport enum OidcProviderType {\n  /** Azure Active Directory */\n  Aad = 'AAD',\n}\n\n/** Metadata for an audit entry with action oauth_application.* */\nexport type OauthApplicationAuditEntryData = {\n  /** The name of the OAuth Application. */\n  oauthApplicationName?: Maybe<Scalars['String']>\n  /** The HTTP path for the OAuth Application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']>\n  /** The HTTP URL for the OAuth Application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']>\n}\n\n/** Audit log entry for a oauth_application.create event. */\nexport type OauthApplicationCreateAuditEntry = AuditEntry &\n  Node &\n  OauthApplicationAuditEntryData &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The application URL of the OAuth Application. */\n    applicationUrl?: Maybe<Scalars['URI']>\n    /** The callback URL of the OAuth Application. */\n    callbackUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The name of the OAuth Application. */\n    oauthApplicationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the OAuth Application */\n    oauthApplicationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the OAuth Application */\n    oauthApplicationUrl?: Maybe<Scalars['URI']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The rate limit of the OAuth Application. */\n    rateLimit?: Maybe<Scalars['Int']>\n    /** The state of the OAuth Application. */\n    state?: Maybe<OauthApplicationCreateAuditEntryState>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The state of an OAuth Application when it was created. */\nexport enum OauthApplicationCreateAuditEntryState {\n  /** The OAuth Application was active and allowed to have OAuth Accesses. */\n  Active = 'ACTIVE',\n  /** The OAuth Application was in the process of being deleted. */\n  PendingDeletion = 'PENDING_DELETION',\n  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */\n  Suspended = 'SUSPENDED',\n}\n\n/** The corresponding operation type for the action */\nexport enum OperationType {\n  /** An existing resource was accessed */\n  Access = 'ACCESS',\n  /** A resource performed an authentication event */\n  Authentication = 'AUTHENTICATION',\n  /** A new resource was created */\n  Create = 'CREATE',\n  /** An existing resource was modified */\n  Modify = 'MODIFY',\n  /** An existing resource was removed */\n  Remove = 'REMOVE',\n  /** An existing resource was restored */\n  Restore = 'RESTORE',\n  /** An existing resource was transferred between multiple resources */\n  Transfer = 'TRANSFER',\n}\n\n/** Possible directions in which to order a list of items when provided an `orderBy` argument. */\nexport enum OrderDirection {\n  /** Specifies an ascending order for a given `orderBy` argument. */\n  Asc = 'ASC',\n  /** Specifies a descending order for a given `orderBy` argument. */\n  Desc = 'DESC',\n}\n\n/** Audit log entry for a org.add_billing_manager */\nexport type OrgAddBillingManagerAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The email address used to invite a billing manager for the organization. */\n    invitationEmail?: Maybe<Scalars['String']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.add_member */\nexport type OrgAddMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The permission level of the member added to the organization. */\n    permission?: Maybe<OrgAddMemberAuditEntryPermission>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The permissions available to members on an Organization. */\nexport enum OrgAddMemberAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** Can read and clone repositories. */\n  Read = 'READ',\n}\n\n/** Audit log entry for a org.block_user */\nexport type OrgBlockUserAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The blocked user. */\n    blockedUser?: Maybe<User>\n    /** The username of the blocked user. */\n    blockedUserName?: Maybe<Scalars['String']>\n    /** The HTTP path for the blocked user. */\n    blockedUserResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the blocked user. */\n    blockedUserUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.config.disable_collaborators_only event. */\nexport type OrgConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.config.enable_collaborators_only event. */\nexport type OrgConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.create event. */\nexport type OrgCreateAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The billing plan for the Organization. */\n    billingPlan?: Maybe<OrgCreateAuditEntryBillingPlan>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The billing plans available for organizations. */\nexport enum OrgCreateAuditEntryBillingPlan {\n  /** Team Plan */\n  Business = 'BUSINESS',\n  /** Enterprise Cloud Plan */\n  BusinessPlus = 'BUSINESS_PLUS',\n  /** Free Plan */\n  Free = 'FREE',\n  /** Tiered Per Seat Plan */\n  TieredPerSeat = 'TIERED_PER_SEAT',\n  /** Legacy Unlimited Plan */\n  Unlimited = 'UNLIMITED',\n}\n\n/** Audit log entry for a org.disable_oauth_app_restrictions event. */\nexport type OrgDisableOauthAppRestrictionsAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.disable_saml event. */\nexport type OrgDisableSamlAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The SAML provider's digest algorithm URL. */\n    digestMethodUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The SAML provider's issuer URL. */\n    issuerUrl?: Maybe<Scalars['URI']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The SAML provider's signature algorithm URL. */\n    signatureMethodUrl?: Maybe<Scalars['URI']>\n    /** The SAML provider's single sign-on URL. */\n    singleSignOnUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.disable_two_factor_requirement event. */\nexport type OrgDisableTwoFactorRequirementAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.enable_oauth_app_restrictions event. */\nexport type OrgEnableOauthAppRestrictionsAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.enable_saml event. */\nexport type OrgEnableSamlAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The SAML provider's digest algorithm URL. */\n    digestMethodUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The SAML provider's issuer URL. */\n    issuerUrl?: Maybe<Scalars['URI']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The SAML provider's signature algorithm URL. */\n    signatureMethodUrl?: Maybe<Scalars['URI']>\n    /** The SAML provider's single sign-on URL. */\n    singleSignOnUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.enable_two_factor_requirement event. */\nexport type OrgEnableTwoFactorRequirementAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.invite_member event. */\nexport type OrgInviteMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The email address of the organization invitation. */\n    email?: Maybe<Scalars['String']>\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The organization invitation. */\n    organizationInvitation?: Maybe<OrganizationInvitation>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.invite_to_business event. */\nexport type OrgInviteToBusinessAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars['URI']>\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars['String']>\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.oauth_app_access_approved event. */\nexport type OrgOauthAppAccessApprovedAuditEntry = AuditEntry &\n  Node &\n  OauthApplicationAuditEntryData &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The name of the OAuth Application. */\n    oauthApplicationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the OAuth Application */\n    oauthApplicationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the OAuth Application */\n    oauthApplicationUrl?: Maybe<Scalars['URI']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.oauth_app_access_denied event. */\nexport type OrgOauthAppAccessDeniedAuditEntry = AuditEntry &\n  Node &\n  OauthApplicationAuditEntryData &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The name of the OAuth Application. */\n    oauthApplicationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the OAuth Application */\n    oauthApplicationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the OAuth Application */\n    oauthApplicationUrl?: Maybe<Scalars['URI']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.oauth_app_access_requested event. */\nexport type OrgOauthAppAccessRequestedAuditEntry = AuditEntry &\n  Node &\n  OauthApplicationAuditEntryData &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The name of the OAuth Application. */\n    oauthApplicationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the OAuth Application */\n    oauthApplicationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the OAuth Application */\n    oauthApplicationUrl?: Maybe<Scalars['URI']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.remove_billing_manager event. */\nexport type OrgRemoveBillingManagerAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The reason for the billing manager being removed. */\n    reason?: Maybe<OrgRemoveBillingManagerAuditEntryReason>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The reason a billing manager was removed from an Organization. */\nexport enum OrgRemoveBillingManagerAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** SAML SSO enforcement requires an external identity */\n  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',\n}\n\n/** Audit log entry for a org.remove_member event. */\nexport type OrgRemoveMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The types of membership the member has with the organization. */\n    membershipTypes?: Maybe<Array<OrgRemoveMemberAuditEntryMembershipType>>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The reason for the member being removed. */\n    reason?: Maybe<OrgRemoveMemberAuditEntryReason>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The type of membership a user has with an Organization. */\nexport enum OrgRemoveMemberAuditEntryMembershipType {\n  /**\n   * Organization administrators have full access and can change several settings,\n   * including the names of repositories that belong to the Organization and Owners\n   * team membership. In addition, organization admins can delete the organization\n   * and all of its repositories.\n   */\n  Admin = 'ADMIN',\n  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */\n  BillingManager = 'BILLING_MANAGER',\n  /** A direct member is a user that is a member of the Organization. */\n  DirectMember = 'DIRECT_MEMBER',\n  /**\n   * An outside collaborator is a person who isn't explicitly a member of the\n   * Organization, but who has Read, Write, or Admin permissions to one or more\n   * repositories in the organization.\n   */\n  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',\n  /**\n   * An unaffiliated collaborator is a person who is not a member of the\n   * Organization and does not have access to any repositories in the Organization.\n   */\n  Unaffiliated = 'UNAFFILIATED',\n}\n\n/** The reason a member was removed from an Organization. */\nexport enum OrgRemoveMemberAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** SAML SSO enforcement requires an external identity */\n  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',\n  /** User was removed from organization during account recovery */\n  TwoFactorAccountRecovery = 'TWO_FACTOR_ACCOUNT_RECOVERY',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',\n  /** User account has been deleted */\n  UserAccountDeleted = 'USER_ACCOUNT_DELETED',\n}\n\n/** Audit log entry for a org.remove_outside_collaborator event. */\nexport type OrgRemoveOutsideCollaboratorAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The types of membership the outside collaborator has with the organization. */\n    membershipTypes?: Maybe<Array<OrgRemoveOutsideCollaboratorAuditEntryMembershipType>>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The reason for the outside collaborator being removed from the Organization. */\n    reason?: Maybe<OrgRemoveOutsideCollaboratorAuditEntryReason>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The type of membership a user has with an Organization. */\nexport enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {\n  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */\n  BillingManager = 'BILLING_MANAGER',\n  /**\n   * An outside collaborator is a person who isn't explicitly a member of the\n   * Organization, but who has Read, Write, or Admin permissions to one or more\n   * repositories in the organization.\n   */\n  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',\n  /**\n   * An unaffiliated collaborator is a person who is not a member of the\n   * Organization and does not have access to any repositories in the organization.\n   */\n  Unaffiliated = 'UNAFFILIATED',\n}\n\n/** The reason an outside collaborator was removed from an Organization. */\nexport enum OrgRemoveOutsideCollaboratorAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',\n}\n\n/** Audit log entry for a org.restore_member event. */\nexport type OrgRestoreMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The number of custom email routings for the restored member. */\n    restoredCustomEmailRoutingsCount?: Maybe<Scalars['Int']>\n    /** The number of issue assignments for the restored member. */\n    restoredIssueAssignmentsCount?: Maybe<Scalars['Int']>\n    /** Restored organization membership objects. */\n    restoredMemberships?: Maybe<Array<OrgRestoreMemberAuditEntryMembership>>\n    /** The number of restored memberships. */\n    restoredMembershipsCount?: Maybe<Scalars['Int']>\n    /** The number of repositories of the restored member. */\n    restoredRepositoriesCount?: Maybe<Scalars['Int']>\n    /** The number of starred repositories for the restored member. */\n    restoredRepositoryStarsCount?: Maybe<Scalars['Int']>\n    /** The number of watched repositories for the restored member. */\n    restoredRepositoryWatchesCount?: Maybe<Scalars['Int']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Types of memberships that can be restored for an Organization member. */\nexport type OrgRestoreMemberAuditEntryMembership =\n  | OrgRestoreMemberMembershipOrganizationAuditEntryData\n  | OrgRestoreMemberMembershipRepositoryAuditEntryData\n  | OrgRestoreMemberMembershipTeamAuditEntryData\n\n/** Metadata for an organization membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipOrganizationAuditEntryData = OrganizationAuditEntryData & {\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>\n}\n\n/** Metadata for a repository membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipRepositoryAuditEntryData = RepositoryAuditEntryData & {\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>\n}\n\n/** Metadata for a team membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipTeamAuditEntryData = TeamAuditEntryData & {\n  /** The team associated with the action */\n  team?: Maybe<Team>\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']>\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']>\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']>\n}\n\n/** Audit log entry for a org.unblock_user */\nexport type OrgUnblockUserAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The user being unblocked by the organization. */\n    blockedUser?: Maybe<User>\n    /** The username of the blocked user. */\n    blockedUserName?: Maybe<Scalars['String']>\n    /** The HTTP path for the blocked user. */\n    blockedUserResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the blocked user. */\n    blockedUserUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a org.update_default_repository_permission */\nexport type OrgUpdateDefaultRepositoryPermissionAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The new base repository permission level for the organization. */\n    permission?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>\n    /** The former base repository permission level for the organization. */\n    permissionWas?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The default permission a repository can have in an Organization. */\nexport enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** No default permission value. */\n  None = 'NONE',\n  /** Can read and clone repositories. */\n  Read = 'READ',\n  /** Can read, clone and push to repositories. */\n  Write = 'WRITE',\n}\n\n/** Audit log entry for a org.update_member event. */\nexport type OrgUpdateMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The new member permission level for the organization. */\n    permission?: Maybe<OrgUpdateMemberAuditEntryPermission>\n    /** The former member permission level for the organization. */\n    permissionWas?: Maybe<OrgUpdateMemberAuditEntryPermission>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The permissions available to members on an Organization. */\nexport enum OrgUpdateMemberAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** Can read and clone repositories. */\n  Read = 'READ',\n}\n\n/** Audit log entry for a org.update_member_repository_creation_permission event. */\nexport type OrgUpdateMemberRepositoryCreationPermissionAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** Can members create repositories in the organization. */\n    canCreateRepositories?: Maybe<Scalars['Boolean']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n    /** The permission for visibility level of repositories for this organization. */\n    visibility?: Maybe<OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>\n  }\n\n/** The permissions available for repository creation on an Organization. */\nexport enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {\n  /** All organization members are restricted from creating any repositories. */\n  All = 'ALL',\n  /** All organization members are restricted from creating internal repositories. */\n  Internal = 'INTERNAL',\n  /** All organization members are allowed to create any repositories. */\n  None = 'NONE',\n  /** All organization members are restricted from creating private repositories. */\n  Private = 'PRIVATE',\n  /** All organization members are restricted from creating private or internal repositories. */\n  PrivateInternal = 'PRIVATE_INTERNAL',\n  /** All organization members are restricted from creating public repositories. */\n  Public = 'PUBLIC',\n  /** All organization members are restricted from creating public or internal repositories. */\n  PublicInternal = 'PUBLIC_INTERNAL',\n  /** All organization members are restricted from creating public or private repositories. */\n  PublicPrivate = 'PUBLIC_PRIVATE',\n}\n\n/** Audit log entry for a org.update_member_repository_invitation_permission event. */\nexport type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** Can outside collaborators be invited to repositories in the organization. */\n    canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars['Boolean']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type Organization = Actor &\n  MemberStatusable &\n  Node &\n  PackageOwner &\n  ProfileOwner &\n  ProjectNextOwner &\n  ProjectOwner &\n  RepositoryDiscussionAuthor &\n  RepositoryDiscussionCommentAuthor &\n  RepositoryOwner &\n  Sponsorable &\n  UniformResourceLocatable & {\n    /** Determine if this repository owner has any items that can be pinned to their profile. */\n    anyPinnableItems: Scalars['Boolean']\n    /** Audit log entries of the organization */\n    auditLog: OrganizationAuditEntryConnection\n    /** A URL pointing to the organization's public avatar. */\n    avatarUrl: Scalars['URI']\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The organization's public profile description. */\n    description?: Maybe<Scalars['String']>\n    /** The organization's public profile description rendered to HTML. */\n    descriptionHTML?: Maybe<Scalars['String']>\n    /** A list of domains owned by the organization. */\n    domains?: Maybe<VerifiableDomainConnection>\n    /** The organization's public email. */\n    email?: Maybe<Scalars['String']>\n    /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n    estimatedNextSponsorsPayoutInCents: Scalars['Int']\n    /** True if this user/organization has a GitHub Sponsors listing. */\n    hasSponsorsListing: Scalars['Boolean']\n    id: Scalars['ID']\n    /** The interaction ability settings for this organization. */\n    interactionAbility?: Maybe<RepositoryInteractionAbility>\n    /** The setting value for whether the organization has an IP allow list enabled. */\n    ipAllowListEnabledSetting: IpAllowListEnabledSettingValue\n    /** The IP addresses that are allowed to access resources owned by the organization. */\n    ipAllowListEntries: IpAllowListEntryConnection\n    /** The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled. */\n    ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue\n    /** Check if the given account is sponsoring this user/organization. */\n    isSponsoredBy: Scalars['Boolean']\n    /** True if the viewer is sponsored by this user/organization. */\n    isSponsoringViewer: Scalars['Boolean']\n    /** Whether the organization has verified its profile email and website. */\n    isVerified: Scalars['Boolean']\n    /**\n     * Showcases a selection of repositories and gists that the profile owner has\n     * either curated or that have been selected automatically based on popularity.\n     */\n    itemShowcase: ProfileItemShowcase\n    /** The organization's public profile location. */\n    location?: Maybe<Scalars['String']>\n    /** The organization's login name. */\n    login: Scalars['String']\n    /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n    memberStatuses: UserStatusConnection\n    /** A list of users who are members of this organization. */\n    membersWithRole: OrganizationMemberConnection\n    /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n    monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']\n    /** The organization's public profile name. */\n    name?: Maybe<Scalars['String']>\n    /** The HTTP path creating a new team */\n    newTeamResourcePath: Scalars['URI']\n    /** The HTTP URL creating a new team */\n    newTeamUrl: Scalars['URI']\n    /** Indicates if email notification delivery for this organization is restricted to verified or approved domains. */\n    notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue\n    /** The billing email for the organization. */\n    organizationBillingEmail?: Maybe<Scalars['String']>\n    /** A list of packages under the owner. */\n    packages: PackageConnection\n    /** A list of users who have been invited to join this organization. */\n    pendingMembers: UserConnection\n    /** A list of repositories and gists this profile owner can pin to their profile. */\n    pinnableItems: PinnableItemConnection\n    /** A list of repositories and gists this profile owner has pinned to their profile */\n    pinnedItems: PinnableItemConnection\n    /** Returns how many more items this profile owner can pin to their profile. */\n    pinnedItemsRemaining: Scalars['Int']\n    /** Find project by number. */\n    project?: Maybe<Project>\n    /** Find project by project next number. */\n    projectNext?: Maybe<ProjectNext>\n    /** A list of projects under the owner. */\n    projects: ProjectConnection\n    /** A list of project next items under the owner. */\n    projectsNext: ProjectNextConnection\n    /** The HTTP path listing organization's projects */\n    projectsResourcePath: Scalars['URI']\n    /** The HTTP URL listing organization's projects */\n    projectsUrl: Scalars['URI']\n    /** A list of repositories that the user owns. */\n    repositories: RepositoryConnection\n    /** Find Repository. */\n    repository?: Maybe<Repository>\n    /** Discussion comments this user has authored. */\n    repositoryDiscussionComments: DiscussionCommentConnection\n    /** Discussions this user has started. */\n    repositoryDiscussions: DiscussionConnection\n    /**\n     * When true the organization requires all members, billing managers, and outside\n     * collaborators to enable two-factor authentication.\n     */\n    requiresTwoFactorAuthentication?: Maybe<Scalars['Boolean']>\n    /** The HTTP path for this organization. */\n    resourcePath: Scalars['URI']\n    /** The Organization's SAML identity providers */\n    samlIdentityProvider?: Maybe<OrganizationIdentityProvider>\n    /** List of users and organizations this entity is sponsoring. */\n    sponsoring: SponsorConnection\n    /** List of sponsors for this user or organization. */\n    sponsors: SponsorConnection\n    /** Events involving this sponsorable, such as new sponsorships. */\n    sponsorsActivities: SponsorsActivityConnection\n    /** The GitHub Sponsors listing for this user or organization. */\n    sponsorsListing?: Maybe<SponsorsListing>\n    /**\n     * The sponsorship from the viewer to this user/organization; that is, the\n     * sponsorship where you're the sponsor. Only returns a sponsorship if it is active.\n     */\n    sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>\n    /**\n     * The sponsorship from this user/organization to the viewer; that is, the\n     * sponsorship you're receiving. Only returns a sponsorship if it is active.\n     */\n    sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>\n    /** List of sponsorship updates sent from this sponsorable to sponsors. */\n    sponsorshipNewsletters: SponsorshipNewsletterConnection\n    /** This object's sponsorships as the maintainer. */\n    sponsorshipsAsMaintainer: SponsorshipConnection\n    /** This object's sponsorships as the sponsor. */\n    sponsorshipsAsSponsor: SponsorshipConnection\n    /** Find an organization's team by its slug. */\n    team?: Maybe<Team>\n    /** A list of teams in this organization. */\n    teams: TeamConnection\n    /** The HTTP path listing organization's teams */\n    teamsResourcePath: Scalars['URI']\n    /** The HTTP URL listing organization's teams */\n    teamsUrl: Scalars['URI']\n    /** The organization's Twitter username. */\n    twitterUsername?: Maybe<Scalars['String']>\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this organization. */\n    url: Scalars['URI']\n    /** Organization is adminable by the viewer. */\n    viewerCanAdminister: Scalars['Boolean']\n    /** Can the viewer pin repositories and gists to the profile? */\n    viewerCanChangePinnedItems: Scalars['Boolean']\n    /** Can the current viewer create new projects on this owner. */\n    viewerCanCreateProjects: Scalars['Boolean']\n    /** Viewer can create repositories on this organization */\n    viewerCanCreateRepositories: Scalars['Boolean']\n    /** Viewer can create teams on this organization. */\n    viewerCanCreateTeams: Scalars['Boolean']\n    /** Whether or not the viewer is able to sponsor this user/organization. */\n    viewerCanSponsor: Scalars['Boolean']\n    /** Viewer is an active member of this organization. */\n    viewerIsAMember: Scalars['Boolean']\n    /** True if the viewer is sponsoring this user/organization. */\n    viewerIsSponsoring: Scalars['Boolean']\n    /** The organization's public profile URL. */\n    websiteUrl?: Maybe<Scalars['URI']>\n  }\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAnyPinnableItemsArgs = {\n  type?: Maybe<PinnableItemType>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAuditLogArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<AuditLogOrder>\n  query?: Maybe<Scalars['String']>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationDomainsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  isApproved?: Maybe<Scalars['Boolean']>\n  isVerified?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<VerifiableDomainOrder>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationIpAllowListEntriesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IpAllowListEntryOrder>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationIsSponsoredByArgs = {\n  accountLogin: Scalars['String']\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationMemberStatusesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<UserStatusOrder>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationMembersWithRoleArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPackagesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  names?: Maybe<Array<Maybe<Scalars['String']>>>\n  orderBy?: Maybe<PackageOrder>\n  packageType?: Maybe<PackageType>\n  repositoryId?: Maybe<Scalars['ID']>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPendingMembersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPinnableItemsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  types?: Maybe<Array<PinnableItemType>>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPinnedItemsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  types?: Maybe<Array<PinnableItemType>>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectArgs = {\n  number: Scalars['Int']\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectNextArgs = {\n  number: Scalars['Int']\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ProjectOrder>\n  search?: Maybe<Scalars['String']>\n  states?: Maybe<Array<ProjectState>>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectsNextArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoriesArgs = {\n  affiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  isFork?: Maybe<Scalars['Boolean']>\n  isLocked?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryOrder>\n  ownerAffiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  privacy?: Maybe<RepositoryPrivacy>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryArgs = {\n  name: Scalars['String']\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryDiscussionCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  onlyAnswers?: Maybe<Scalars['Boolean']>\n  repositoryId?: Maybe<Scalars['ID']>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryDiscussionsArgs = {\n  after?: Maybe<Scalars['String']>\n  answered?: Maybe<Scalars['Boolean']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<DiscussionOrder>\n  repositoryId?: Maybe<Scalars['ID']>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsoringArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorOrder>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorOrder>\n  tierId?: Maybe<Scalars['ID']>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorsActivitiesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorsActivityOrder>\n  period?: Maybe<SponsorsActivityPeriod>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipNewslettersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorshipNewsletterOrder>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipsAsMaintainerArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  includePrivate?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorshipOrder>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipsAsSponsorArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorshipOrder>\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationTeamArgs = {\n  slug: Scalars['String']\n}\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationTeamsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  ldapMapped?: Maybe<Scalars['Boolean']>\n  orderBy?: Maybe<TeamOrder>\n  privacy?: Maybe<TeamPrivacy>\n  query?: Maybe<Scalars['String']>\n  role?: Maybe<TeamRole>\n  rootTeamsOnly?: Maybe<Scalars['Boolean']>\n  userLogins?: Maybe<Array<Scalars['String']>>\n}\n\n/** An audit entry in an organization audit log. */\nexport type OrganizationAuditEntry =\n  | MembersCanDeleteReposClearAuditEntry\n  | MembersCanDeleteReposDisableAuditEntry\n  | MembersCanDeleteReposEnableAuditEntry\n  | OauthApplicationCreateAuditEntry\n  | OrgAddBillingManagerAuditEntry\n  | OrgAddMemberAuditEntry\n  | OrgBlockUserAuditEntry\n  | OrgConfigDisableCollaboratorsOnlyAuditEntry\n  | OrgConfigEnableCollaboratorsOnlyAuditEntry\n  | OrgCreateAuditEntry\n  | OrgDisableOauthAppRestrictionsAuditEntry\n  | OrgDisableSamlAuditEntry\n  | OrgDisableTwoFactorRequirementAuditEntry\n  | OrgEnableOauthAppRestrictionsAuditEntry\n  | OrgEnableSamlAuditEntry\n  | OrgEnableTwoFactorRequirementAuditEntry\n  | OrgInviteMemberAuditEntry\n  | OrgInviteToBusinessAuditEntry\n  | OrgOauthAppAccessApprovedAuditEntry\n  | OrgOauthAppAccessDeniedAuditEntry\n  | OrgOauthAppAccessRequestedAuditEntry\n  | OrgRemoveBillingManagerAuditEntry\n  | OrgRemoveMemberAuditEntry\n  | OrgRemoveOutsideCollaboratorAuditEntry\n  | OrgRestoreMemberAuditEntry\n  | OrgUnblockUserAuditEntry\n  | OrgUpdateDefaultRepositoryPermissionAuditEntry\n  | OrgUpdateMemberAuditEntry\n  | OrgUpdateMemberRepositoryCreationPermissionAuditEntry\n  | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry\n  | PrivateRepositoryForkingDisableAuditEntry\n  | PrivateRepositoryForkingEnableAuditEntry\n  | RepoAccessAuditEntry\n  | RepoAddMemberAuditEntry\n  | RepoAddTopicAuditEntry\n  | RepoArchivedAuditEntry\n  | RepoChangeMergeSettingAuditEntry\n  | RepoConfigDisableAnonymousGitAccessAuditEntry\n  | RepoConfigDisableCollaboratorsOnlyAuditEntry\n  | RepoConfigDisableContributorsOnlyAuditEntry\n  | RepoConfigDisableSockpuppetDisallowedAuditEntry\n  | RepoConfigEnableAnonymousGitAccessAuditEntry\n  | RepoConfigEnableCollaboratorsOnlyAuditEntry\n  | RepoConfigEnableContributorsOnlyAuditEntry\n  | RepoConfigEnableSockpuppetDisallowedAuditEntry\n  | RepoConfigLockAnonymousGitAccessAuditEntry\n  | RepoConfigUnlockAnonymousGitAccessAuditEntry\n  | RepoCreateAuditEntry\n  | RepoDestroyAuditEntry\n  | RepoRemoveMemberAuditEntry\n  | RepoRemoveTopicAuditEntry\n  | RepositoryVisibilityChangeDisableAuditEntry\n  | RepositoryVisibilityChangeEnableAuditEntry\n  | TeamAddMemberAuditEntry\n  | TeamAddRepositoryAuditEntry\n  | TeamChangeParentTeamAuditEntry\n  | TeamRemoveMemberAuditEntry\n  | TeamRemoveRepositoryAuditEntry\n\n/** The connection type for OrganizationAuditEntry. */\nexport type OrganizationAuditEntryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationAuditEntryEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationAuditEntry>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Metadata for an audit entry with action org.* */\nexport type OrganizationAuditEntryData = {\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>\n}\n\n/** An edge in a connection. */\nexport type OrganizationAuditEntryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationAuditEntry>\n}\n\n/** The connection type for Organization. */\nexport type OrganizationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Organization>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type OrganizationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Organization>\n}\n\n/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */\nexport type OrganizationIdentityProvider = Node & {\n  /** The digest algorithm used to sign SAML requests for the Identity Provider. */\n  digestMethod?: Maybe<Scalars['URI']>\n  /** External Identities provisioned by this Identity Provider */\n  externalIdentities: ExternalIdentityConnection\n  id: Scalars['ID']\n  /** The x509 certificate used by the Identity Provider to sign assertions and responses. */\n  idpCertificate?: Maybe<Scalars['X509Certificate']>\n  /** The Issuer Entity ID for the SAML Identity Provider */\n  issuer?: Maybe<Scalars['String']>\n  /** Organization this Identity Provider belongs to */\n  organization?: Maybe<Organization>\n  /** The signature algorithm used to sign SAML requests for the Identity Provider. */\n  signatureMethod?: Maybe<Scalars['URI']>\n  /** The URL endpoint for the Identity Provider's SAML SSO. */\n  ssoUrl?: Maybe<Scalars['URI']>\n}\n\n/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */\nexport type OrganizationIdentityProviderExternalIdentitiesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  membersOnly?: Maybe<Scalars['Boolean']>\n}\n\n/** An Invitation for a user to an organization. */\nexport type OrganizationInvitation = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The email address of the user invited to the organization. */\n  email?: Maybe<Scalars['String']>\n  id: Scalars['ID']\n  /** The type of invitation that was sent (e.g. email, user). */\n  invitationType: OrganizationInvitationType\n  /** The user who was invited to the organization. */\n  invitee?: Maybe<User>\n  /** The user who created the invitation. */\n  inviter: User\n  /** The organization the invite is for */\n  organization: Organization\n  /** The user's pending role in the organization (e.g. member, owner). */\n  role: OrganizationInvitationRole\n}\n\n/** The connection type for OrganizationInvitation. */\nexport type OrganizationInvitationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationInvitationEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type OrganizationInvitationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationInvitation>\n}\n\n/** The possible organization invitation roles. */\nexport enum OrganizationInvitationRole {\n  /** The user is invited to be an admin of the organization. */\n  Admin = 'ADMIN',\n  /** The user is invited to be a billing manager of the organization. */\n  BillingManager = 'BILLING_MANAGER',\n  /** The user is invited to be a direct member of the organization. */\n  DirectMember = 'DIRECT_MEMBER',\n  /** The user's previous role will be reinstated. */\n  Reinstate = 'REINSTATE',\n}\n\n/** The possible organization invitation types. */\nexport enum OrganizationInvitationType {\n  /** The invitation was to an email address. */\n  Email = 'EMAIL',\n  /** The invitation was to an existing user. */\n  User = 'USER',\n}\n\n/** The connection type for User. */\nexport type OrganizationMemberConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationMemberEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Represents a user within an organization. */\nexport type OrganizationMemberEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */\n  hasTwoFactorEnabled?: Maybe<Scalars['Boolean']>\n  /** The item at the end of the edge. */\n  node?: Maybe<User>\n  /** The role this user has in the organization. */\n  role?: Maybe<OrganizationMemberRole>\n}\n\n/** The possible roles within an organization for its members. */\nexport enum OrganizationMemberRole {\n  /** The user is an administrator of the organization. */\n  Admin = 'ADMIN',\n  /** The user is a member of the organization. */\n  Member = 'MEMBER',\n}\n\n/** The possible values for the members can create repositories setting on an organization. */\nexport enum OrganizationMembersCanCreateRepositoriesSettingValue {\n  /** Members will be able to create public and private repositories. */\n  All = 'ALL',\n  /** Members will not be able to create public or private repositories. */\n  Disabled = 'DISABLED',\n  /** Members will be able to create only internal repositories. */\n  Internal = 'INTERNAL',\n  /** Members will be able to create only private repositories. */\n  Private = 'PRIVATE',\n}\n\n/** Ordering options for organization connections. */\nexport type OrganizationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order organizations by. */\n  field: OrganizationOrderField\n}\n\n/** Properties by which organization connections can be ordered. */\nexport enum OrganizationOrderField {\n  /** Order organizations by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order organizations by login */\n  Login = 'LOGIN',\n}\n\n/** An organization teams hovercard context */\nexport type OrganizationTeamsHovercardContext = HovercardContext & {\n  /** A string describing this context */\n  message: Scalars['String']\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']\n  /** Teams in this organization the user is a member of that are relevant */\n  relevantTeams: TeamConnection\n  /** The path for the full team list for this user */\n  teamsResourcePath: Scalars['URI']\n  /** The URL for the full team list for this user */\n  teamsUrl: Scalars['URI']\n  /** The total number of teams the user is on in the organization */\n  totalTeamCount: Scalars['Int']\n}\n\n/** An organization teams hovercard context */\nexport type OrganizationTeamsHovercardContextRelevantTeamsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** An organization list hovercard context */\nexport type OrganizationsHovercardContext = HovercardContext & {\n  /** A string describing this context */\n  message: Scalars['String']\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']\n  /** Organizations this user is a member of that are relevant */\n  relevantOrganizations: OrganizationConnection\n  /** The total number of organizations this user is in */\n  totalOrganizationCount: Scalars['Int']\n}\n\n/** An organization list hovercard context */\nexport type OrganizationsHovercardContextRelevantOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Information for an uploaded package. */\nexport type Package = Node & {\n  id: Scalars['ID']\n  /** Find the latest version for the package. */\n  latestVersion?: Maybe<PackageVersion>\n  /** Identifies the name of the package. */\n  name: Scalars['String']\n  /** Identifies the type of the package. */\n  packageType: PackageType\n  /** The repository this package belongs to. */\n  repository?: Maybe<Repository>\n  /** Statistics about package activity. */\n  statistics?: Maybe<PackageStatistics>\n  /** Find package version by version string. */\n  version?: Maybe<PackageVersion>\n  /** list of versions for this package */\n  versions: PackageVersionConnection\n}\n\n/** Information for an uploaded package. */\nexport type PackageVersionArgs = {\n  version: Scalars['String']\n}\n\n/** Information for an uploaded package. */\nexport type PackageVersionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<PackageVersionOrder>\n}\n\n/** The connection type for Package. */\nexport type PackageConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Package>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PackageEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Package>\n}\n\n/** A file in a package version. */\nexport type PackageFile = Node & {\n  id: Scalars['ID']\n  /** MD5 hash of the file. */\n  md5?: Maybe<Scalars['String']>\n  /** Name of the file. */\n  name: Scalars['String']\n  /** The package version this file belongs to. */\n  packageVersion?: Maybe<PackageVersion>\n  /** SHA1 hash of the file. */\n  sha1?: Maybe<Scalars['String']>\n  /** SHA256 hash of the file. */\n  sha256?: Maybe<Scalars['String']>\n  /** Size of the file in bytes. */\n  size?: Maybe<Scalars['Int']>\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** URL to download the asset. */\n  url?: Maybe<Scalars['URI']>\n}\n\n/** The connection type for PackageFile. */\nexport type PackageFileConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageFileEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PackageFile>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PackageFileEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PackageFile>\n}\n\n/** Ways in which lists of package files can be ordered upon return. */\nexport type PackageFileOrder = {\n  /** The direction in which to order package files by the specified field. */\n  direction?: Maybe<OrderDirection>\n  /** The field in which to order package files by. */\n  field?: Maybe<PackageFileOrderField>\n}\n\n/** Properties by which package file connections can be ordered. */\nexport enum PackageFileOrderField {\n  /** Order package files by creation time */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** Ways in which lists of packages can be ordered upon return. */\nexport type PackageOrder = {\n  /** The direction in which to order packages by the specified field. */\n  direction?: Maybe<OrderDirection>\n  /** The field in which to order packages by. */\n  field?: Maybe<PackageOrderField>\n}\n\n/** Properties by which package connections can be ordered. */\nexport enum PackageOrderField {\n  /** Order packages by creation time */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** Represents an owner of a package. */\nexport type PackageOwner = {\n  id: Scalars['ID']\n  /** A list of packages under the owner. */\n  packages: PackageConnection\n}\n\n/** Represents an owner of a package. */\nexport type PackageOwnerPackagesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  names?: Maybe<Array<Maybe<Scalars['String']>>>\n  orderBy?: Maybe<PackageOrder>\n  packageType?: Maybe<PackageType>\n  repositoryId?: Maybe<Scalars['ID']>\n}\n\n/** Represents a object that contains package activity statistics such as downloads. */\nexport type PackageStatistics = {\n  /** Number of times the package was downloaded since it was created. */\n  downloadsTotalCount: Scalars['Int']\n}\n\n/** A version tag contains the mapping between a tag name and a version. */\nexport type PackageTag = Node & {\n  id: Scalars['ID']\n  /** Identifies the tag name of the version. */\n  name: Scalars['String']\n  /** Version that the tag is associated with. */\n  version?: Maybe<PackageVersion>\n}\n\n/** The possible types of a package. */\nexport enum PackageType {\n  /** A debian package. */\n  Debian = 'DEBIAN',\n  /** A docker image. */\n  Docker = 'DOCKER',\n  /** A maven package. */\n  Maven = 'MAVEN',\n  /** An npm package. */\n  Npm = 'NPM',\n  /** A nuget package. */\n  Nuget = 'NUGET',\n  /** A python package. */\n  Pypi = 'PYPI',\n  /** A rubygems package. */\n  Rubygems = 'RUBYGEMS',\n}\n\n/** Information about a specific package version. */\nexport type PackageVersion = Node & {\n  /** List of files associated with this package version */\n  files: PackageFileConnection\n  id: Scalars['ID']\n  /** The package associated with this version. */\n  package?: Maybe<Package>\n  /** The platform this version was built for. */\n  platform?: Maybe<Scalars['String']>\n  /** Whether or not this version is a pre-release. */\n  preRelease: Scalars['Boolean']\n  /** The README of this package version. */\n  readme?: Maybe<Scalars['String']>\n  /** The release associated with this package version. */\n  release?: Maybe<Release>\n  /** Statistics about package activity. */\n  statistics?: Maybe<PackageVersionStatistics>\n  /** The package version summary. */\n  summary?: Maybe<Scalars['String']>\n  /** The version string. */\n  version: Scalars['String']\n}\n\n/** Information about a specific package version. */\nexport type PackageVersionFilesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<PackageFileOrder>\n}\n\n/** The connection type for PackageVersion. */\nexport type PackageVersionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageVersionEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PackageVersion>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PackageVersionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PackageVersion>\n}\n\n/** Ways in which lists of package versions can be ordered upon return. */\nexport type PackageVersionOrder = {\n  /** The direction in which to order package versions by the specified field. */\n  direction?: Maybe<OrderDirection>\n  /** The field in which to order package versions by. */\n  field?: Maybe<PackageVersionOrderField>\n}\n\n/** Properties by which package version connections can be ordered. */\nexport enum PackageVersionOrderField {\n  /** Order package versions by creation time */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** Represents a object that contains package version activity statistics such as downloads. */\nexport type PackageVersionStatistics = {\n  /** Number of times the package was downloaded since it was created. */\n  downloadsTotalCount: Scalars['Int']\n}\n\n/** Information about pagination in a connection. */\nexport type PageInfo = {\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['String']>\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean']\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean']\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['String']>\n}\n\n/** Types that can grant permissions on a repository to a user */\nexport type PermissionGranter = Organization | Repository | Team\n\n/** A level of permission and source for a user's access to a repository. */\nexport type PermissionSource = {\n  /** The organization the repository belongs to. */\n  organization: Organization\n  /** The level of access this source has granted to the user. */\n  permission: DefaultRepositoryPermissionField\n  /** The source of this permission. */\n  source: PermissionGranter\n}\n\n/** Autogenerated input type of PinIssue */\nexport type PinIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the issue to be pinned */\n  issueId: Scalars['ID']\n}\n\n/** Autogenerated return type of PinIssue */\nexport type PinIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The issue that was pinned */\n  issue?: Maybe<Issue>\n}\n\n/** Types that can be pinned to a profile page. */\nexport type PinnableItem = Gist | Repository\n\n/** The connection type for PinnableItem. */\nexport type PinnableItemConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnableItemEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnableItem>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PinnableItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnableItem>\n}\n\n/** Represents items that can be pinned to a profile page or dashboard. */\nexport enum PinnableItemType {\n  /** A gist. */\n  Gist = 'GIST',\n  /** An issue. */\n  Issue = 'ISSUE',\n  /** An organization. */\n  Organization = 'ORGANIZATION',\n  /** A project. */\n  Project = 'PROJECT',\n  /** A pull request. */\n  PullRequest = 'PULL_REQUEST',\n  /** A repository. */\n  Repository = 'REPOSITORY',\n  /** A team. */\n  Team = 'TEAM',\n  /** A user. */\n  User = 'USER',\n}\n\n/** A Pinned Discussion is a discussion pinned to a repository's index page. */\nexport type PinnedDiscussion = Node &\n  RepositoryNode & {\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The discussion that was pinned. */\n    discussion: Discussion\n    /** Color stops of the chosen gradient */\n    gradientStopColors: Array<Scalars['String']>\n    id: Scalars['ID']\n    /** Background texture pattern */\n    pattern: PinnedDiscussionPattern\n    /** The actor that pinned this discussion. */\n    pinnedBy: Actor\n    /** Preconfigured background gradient option */\n    preconfiguredGradient?: Maybe<PinnedDiscussionGradient>\n    /** The repository associated with this node. */\n    repository: Repository\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n  }\n\n/** The connection type for PinnedDiscussion. */\nexport type PinnedDiscussionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnedDiscussionEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnedDiscussion>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PinnedDiscussionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnedDiscussion>\n}\n\n/** Preconfigured gradients that may be used to style discussions pinned within a repository. */\nexport enum PinnedDiscussionGradient {\n  /** A gradient of blue to mint */\n  BlueMint = 'BLUE_MINT',\n  /** A gradient of blue to purple */\n  BluePurple = 'BLUE_PURPLE',\n  /** A gradient of pink to blue */\n  PinkBlue = 'PINK_BLUE',\n  /** A gradient of purple to coral */\n  PurpleCoral = 'PURPLE_CORAL',\n  /** A gradient of red to orange */\n  RedOrange = 'RED_ORANGE',\n}\n\n/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */\nexport enum PinnedDiscussionPattern {\n  /** An upward-facing chevron pattern */\n  ChevronUp = 'CHEVRON_UP',\n  /** A hollow dot pattern */\n  Dot = 'DOT',\n  /** A solid dot pattern */\n  DotFill = 'DOT_FILL',\n  /** A heart pattern */\n  HeartFill = 'HEART_FILL',\n  /** A plus sign pattern */\n  Plus = 'PLUS',\n  /** A lightning bolt pattern */\n  Zap = 'ZAP',\n}\n\n/** Represents a 'pinned' event on a given issue or pull request. */\nexport type PinnedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Identifies the issue associated with the event. */\n  issue: Issue\n}\n\n/** A Pinned Issue is a issue pinned to a repository's index page. */\nexport type PinnedIssue = Node & {\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** The issue that was pinned. */\n  issue: Issue\n  /** The actor that pinned this issue. */\n  pinnedBy: Actor\n  /** The repository that this issue was pinned to. */\n  repository: Repository\n}\n\n/** The connection type for PinnedIssue. */\nexport type PinnedIssueConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnedIssueEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnedIssue>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PinnedIssueEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnedIssue>\n}\n\n/** Audit log entry for a private_repository_forking.disable event. */\nexport type PrivateRepositoryForkingDisableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars['URI']>\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars['String']>\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a private_repository_forking.enable event. */\nexport type PrivateRepositoryForkingEnableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars['URI']>\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars['String']>\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/**\n * A curatable list of repositories relating to a repository owner, which defaults\n * to showing the most popular repositories they own.\n */\nexport type ProfileItemShowcase = {\n  /** Whether or not the owner has pinned any repositories or gists. */\n  hasPinnedItems: Scalars['Boolean']\n  /**\n   * The repositories and gists in the showcase. If the profile owner has any\n   * pinned items, those will be returned. Otherwise, the profile owner's popular\n   * repositories will be returned.\n   */\n  items: PinnableItemConnection\n}\n\n/**\n * A curatable list of repositories relating to a repository owner, which defaults\n * to showing the most popular repositories they own.\n */\nexport type ProfileItemShowcaseItemsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwner = {\n  /** Determine if this repository owner has any items that can be pinned to their profile. */\n  anyPinnableItems: Scalars['Boolean']\n  /** The public profile email. */\n  email?: Maybe<Scalars['String']>\n  id: Scalars['ID']\n  /**\n   * Showcases a selection of repositories and gists that the profile owner has\n   * either curated or that have been selected automatically based on popularity.\n   */\n  itemShowcase: ProfileItemShowcase\n  /** The public profile location. */\n  location?: Maybe<Scalars['String']>\n  /** The username used to login. */\n  login: Scalars['String']\n  /** The public profile name. */\n  name?: Maybe<Scalars['String']>\n  /** A list of repositories and gists this profile owner can pin to their profile. */\n  pinnableItems: PinnableItemConnection\n  /** A list of repositories and gists this profile owner has pinned to their profile */\n  pinnedItems: PinnableItemConnection\n  /** Returns how many more items this profile owner can pin to their profile. */\n  pinnedItemsRemaining: Scalars['Int']\n  /** Can the viewer pin repositories and gists to the profile? */\n  viewerCanChangePinnedItems: Scalars['Boolean']\n  /** The public profile website URL. */\n  websiteUrl?: Maybe<Scalars['URI']>\n}\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerAnyPinnableItemsArgs = {\n  type?: Maybe<PinnableItemType>\n}\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerPinnableItemsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  types?: Maybe<Array<PinnableItemType>>\n}\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerPinnedItemsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  types?: Maybe<Array<PinnableItemType>>\n}\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type Project = Closable &\n  Node &\n  Updatable & {\n    /** The project's description body. */\n    body?: Maybe<Scalars['String']>\n    /** The projects description body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** `true` if the object is closed (definition of closed may depend on type) */\n    closed: Scalars['Boolean']\n    /** Identifies the date and time when the object was closed. */\n    closedAt?: Maybe<Scalars['DateTime']>\n    /** List of columns in the project */\n    columns: ProjectColumnConnection\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** The actor who originally created the project. */\n    creator?: Maybe<Actor>\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    id: Scalars['ID']\n    /** The project's name. */\n    name: Scalars['String']\n    /** The project's number. */\n    number: Scalars['Int']\n    /** The project's owner. Currently limited to repositories, organizations, and users. */\n    owner: ProjectOwner\n    /** List of pending cards in this project */\n    pendingCards: ProjectCardConnection\n    /** Project progress details. */\n    progress: ProjectProgress\n    /** The HTTP path for this project */\n    resourcePath: Scalars['URI']\n    /** Whether the project is open or closed. */\n    state: ProjectState\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this project */\n    url: Scalars['URI']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n  }\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type ProjectColumnsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type ProjectPendingCardsArgs = {\n  after?: Maybe<Scalars['String']>\n  archivedStates?: Maybe<Array<Maybe<ProjectCardArchivedState>>>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A card in a project. */\nexport type ProjectCard = Node & {\n  /**\n   * The project column this card is associated under. A card may only belong to one\n   * project column at a time. The column field will be null if the card is created\n   * in a pending state and has yet to be associated with a column. Once cards are\n   * associated with a column, they will not become pending in the future.\n   */\n  column?: Maybe<ProjectColumn>\n  /** The card content item */\n  content?: Maybe<ProjectCardItem>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The actor who created this card */\n  creator?: Maybe<Actor>\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** Whether the card is archived */\n  isArchived: Scalars['Boolean']\n  /** The card note */\n  note?: Maybe<Scalars['String']>\n  /** The project that contains this card. */\n  project: Project\n  /** The HTTP path for this card */\n  resourcePath: Scalars['URI']\n  /** The state of ProjectCard */\n  state?: Maybe<ProjectCardState>\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The HTTP URL for this card */\n  url: Scalars['URI']\n}\n\n/** The possible archived states of a project card. */\nexport enum ProjectCardArchivedState {\n  /** A project card that is archived */\n  Archived = 'ARCHIVED',\n  /** A project card that is not archived */\n  NotArchived = 'NOT_ARCHIVED',\n}\n\n/** The connection type for ProjectCard. */\nexport type ProjectCardConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectCardEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectCard>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ProjectCardEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectCard>\n}\n\n/** An issue or PR and its owning repository to be used in a project card. */\nexport type ProjectCardImport = {\n  /** The issue or pull request number. */\n  number: Scalars['Int']\n  /** Repository name with owner (owner/repository). */\n  repository: Scalars['String']\n}\n\n/** Types that can be inside Project Cards. */\nexport type ProjectCardItem = Issue | PullRequest\n\n/** Various content states of a ProjectCard */\nexport enum ProjectCardState {\n  /** The card has content only. */\n  ContentOnly = 'CONTENT_ONLY',\n  /** The card has a note only. */\n  NoteOnly = 'NOTE_ONLY',\n  /** The card is redacted. */\n  Redacted = 'REDACTED',\n}\n\n/** A column inside a project. */\nexport type ProjectColumn = Node & {\n  /** List of cards in the column */\n  cards: ProjectCardConnection\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** The project column's name. */\n  name: Scalars['String']\n  /** The project that contains this column. */\n  project: Project\n  /** The semantic purpose of the column */\n  purpose?: Maybe<ProjectColumnPurpose>\n  /** The HTTP path for this project column */\n  resourcePath: Scalars['URI']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The HTTP URL for this project column */\n  url: Scalars['URI']\n}\n\n/** A column inside a project. */\nexport type ProjectColumnCardsArgs = {\n  after?: Maybe<Scalars['String']>\n  archivedStates?: Maybe<Array<Maybe<ProjectCardArchivedState>>>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for ProjectColumn. */\nexport type ProjectColumnConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectColumnEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectColumn>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ProjectColumnEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectColumn>\n}\n\n/** A project column and a list of its issues and PRs. */\nexport type ProjectColumnImport = {\n  /** The name of the column. */\n  columnName: Scalars['String']\n  /** A list of issues and pull requests in the column. */\n  issues?: Maybe<Array<ProjectCardImport>>\n  /** The position of the column, starting from 0. */\n  position: Scalars['Int']\n}\n\n/** The semantic purpose of the column - todo, in progress, or done. */\nexport enum ProjectColumnPurpose {\n  /** The column contains cards which are complete */\n  Done = 'DONE',\n  /** The column contains cards which are currently being worked on */\n  InProgress = 'IN_PROGRESS',\n  /** The column contains cards still to be worked on */\n  Todo = 'TODO',\n}\n\n/** A list of projects associated with the owner. */\nexport type ProjectConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Project>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ProjectEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Project>\n}\n\n/** New projects that manage issues, pull requests and drafts with tables and. */\nexport type ProjectNext = Closable &\n  Node &\n  Updatable & {\n    /** Returns true if the project is closed. */\n    closed: Scalars['Boolean']\n    /** Identifies the date and time when the object was closed. */\n    closedAt?: Maybe<Scalars['DateTime']>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** The actor who originally created the project. */\n    creator?: Maybe<Actor>\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The project's description. */\n    description?: Maybe<Scalars['String']>\n    /** List of fields in the project */\n    fields: ProjectNextFieldConnection\n    id: Scalars['ID']\n    /** List of items in the project */\n    items: ProjectNextItemConnection\n    /** The project's number. */\n    number: Scalars['Int']\n    /** The project's owner. Currently limited to organizations and users. */\n    owner: ProjectNextOwner\n    /** The HTTP path for this project */\n    resourcePath: Scalars['URI']\n    /** The project's name. */\n    title?: Maybe<Scalars['String']>\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this project */\n    url: Scalars['URI']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n  }\n\n/** New projects that manage issues, pull requests and drafts with tables and. */\nexport type ProjectNextFieldsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** New projects that manage issues, pull requests and drafts with tables and. */\nexport type ProjectNextItemsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for ProjectNext. */\nexport type ProjectNextConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectNextEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectNext>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ProjectNextEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectNext>\n}\n\n/** A field inside a project. */\nexport type ProjectNextField = {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** The project field's name. */\n  name: Scalars['String']\n  /** The project that contains this column. */\n  project: ProjectNext\n  /** The field's settings. */\n  settings?: Maybe<Scalars['String']>\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** The connection type for ProjectNextField. */\nexport type ProjectNextFieldConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectNextFieldEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectNextField>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ProjectNextFieldEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectNextField>\n}\n\n/** An item in a Memex project. */\nexport type ProjectNextItem = Node & {\n  /** The content of the referenced issue or pull request */\n  content?: Maybe<ProjectNextItemContent>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** List of field values */\n  fieldValues: ProjectNextItemFieldValueConnection\n  id: Scalars['ID']\n  /** The project that contains this item. */\n  project: ProjectNext\n  /** The title of the item */\n  title?: Maybe<Scalars['String']>\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** An item in a Memex project. */\nexport type ProjectNextItemFieldValuesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for ProjectNextItem. */\nexport type ProjectNextItemConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectNextItemEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectNextItem>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Types that can be inside Project Items. */\nexport type ProjectNextItemContent = Issue | PullRequest\n\n/** An edge in a connection. */\nexport type ProjectNextItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectNextItem>\n}\n\n/** An value of a field in an item of Memex project. */\nexport type ProjectNextItemFieldValue = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** The project field that contains this value. */\n  projectField: ProjectNextField\n  /** The project item that contains this value. */\n  projectItem: ProjectNextItem\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The value of a field */\n  value?: Maybe<Scalars['String']>\n}\n\n/** The connection type for ProjectNextItemFieldValue. */\nexport type ProjectNextItemFieldValueConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectNextItemFieldValueEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectNextItemFieldValue>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ProjectNextItemFieldValueEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectNextItemFieldValue>\n}\n\n/** Represents an owner of a Project. */\nexport type ProjectNextOwner = {\n  id: Scalars['ID']\n  /** Find project by project next number. */\n  projectNext?: Maybe<ProjectNext>\n  /** A list of project next items under the owner. */\n  projectsNext: ProjectNextConnection\n}\n\n/** Represents an owner of a Project. */\nexport type ProjectNextOwnerProjectNextArgs = {\n  number: Scalars['Int']\n}\n\n/** Represents an owner of a Project. */\nexport type ProjectNextOwnerProjectsNextArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Ways in which lists of projects can be ordered upon return. */\nexport type ProjectOrder = {\n  /** The direction in which to order projects by the specified field. */\n  direction: OrderDirection\n  /** The field in which to order projects by. */\n  field: ProjectOrderField\n}\n\n/** Properties by which project connections can be ordered. */\nexport enum ProjectOrderField {\n  /** Order projects by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order projects by name */\n  Name = 'NAME',\n  /** Order projects by update time */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** Represents an owner of a Project. */\nexport type ProjectOwner = {\n  id: Scalars['ID']\n  /** Find project by number. */\n  project?: Maybe<Project>\n  /** A list of projects under the owner. */\n  projects: ProjectConnection\n  /** The HTTP path listing owners projects */\n  projectsResourcePath: Scalars['URI']\n  /** The HTTP URL listing owners projects */\n  projectsUrl: Scalars['URI']\n  /** Can the current viewer create new projects on this owner. */\n  viewerCanCreateProjects: Scalars['Boolean']\n}\n\n/** Represents an owner of a Project. */\nexport type ProjectOwnerProjectArgs = {\n  number: Scalars['Int']\n}\n\n/** Represents an owner of a Project. */\nexport type ProjectOwnerProjectsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ProjectOrder>\n  search?: Maybe<Scalars['String']>\n  states?: Maybe<Array<ProjectState>>\n}\n\n/** Project progress stats. */\nexport type ProjectProgress = {\n  /** The number of done cards. */\n  doneCount: Scalars['Int']\n  /** The percentage of done cards. */\n  donePercentage: Scalars['Float']\n  /** Whether progress tracking is enabled and cards with purpose exist for this project */\n  enabled: Scalars['Boolean']\n  /** The number of in-progress cards. */\n  inProgressCount: Scalars['Int']\n  /** The percentage of in-progress cards. */\n  inProgressPercentage: Scalars['Float']\n  /** The number of to do cards. */\n  todoCount: Scalars['Int']\n  /** The percentage of to do cards. */\n  todoPercentage: Scalars['Float']\n}\n\n/** State of the project; either 'open' or 'closed' */\nexport enum ProjectState {\n  /** The project is closed. */\n  Closed = 'CLOSED',\n  /** The project is open. */\n  Open = 'OPEN',\n}\n\n/** GitHub-provided templates for Projects */\nexport enum ProjectTemplate {\n  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */\n  AutomatedKanbanV2 = 'AUTOMATED_KANBAN_V2',\n  /** Create a board with triggers to automatically move cards across columns with review automation. */\n  AutomatedReviewsKanban = 'AUTOMATED_REVIEWS_KANBAN',\n  /** Create a board with columns for To do, In progress and Done. */\n  BasicKanban = 'BASIC_KANBAN',\n  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */\n  BugTriage = 'BUG_TRIAGE',\n}\n\n/** A user's public key. */\nexport type PublicKey = Node & {\n  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */\n  accessedAt?: Maybe<Scalars['DateTime']>\n  /**\n   * Identifies the date and time when the key was created. Keys created before\n   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.\n   */\n  createdAt?: Maybe<Scalars['DateTime']>\n  /** The fingerprint for this PublicKey. */\n  fingerprint: Scalars['String']\n  id: Scalars['ID']\n  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */\n  isReadOnly?: Maybe<Scalars['Boolean']>\n  /** The public key string. */\n  key: Scalars['String']\n  /**\n   * Identifies the date and time when the key was updated. Keys created before\n   * March 5th, 2014 may have inaccurate values. Values will be null for keys not\n   * owned by the user.\n   */\n  updatedAt?: Maybe<Scalars['DateTime']>\n}\n\n/** The connection type for PublicKey. */\nexport type PublicKeyConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PublicKeyEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PublicKey>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PublicKeyEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PublicKey>\n}\n\n/** A repository pull request. */\nexport type PullRequest = Assignable &\n  Closable &\n  Comment &\n  Labelable &\n  Lockable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Subscribable &\n  UniformResourceLocatable &\n  Updatable &\n  UpdatableComment & {\n    /** Reason that the conversation was locked. */\n    activeLockReason?: Maybe<LockReason>\n    /** The number of additions in this pull request. */\n    additions: Scalars['Int']\n    /** A list of Users assigned to this object. */\n    assignees: UserConnection\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation\n    /** Returns the auto-merge request object if one exists for this pull request. */\n    autoMergeRequest?: Maybe<AutoMergeRequest>\n    /** Identifies the base Ref associated with the pull request. */\n    baseRef?: Maybe<Ref>\n    /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */\n    baseRefName: Scalars['String']\n    /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */\n    baseRefOid: Scalars['GitObjectID']\n    /** The repository associated with this pull request's base Ref. */\n    baseRepository?: Maybe<Repository>\n    /** The body as Markdown. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The body rendered to text. */\n    bodyText: Scalars['String']\n    /** Whether or not the pull request is rebaseable. */\n    canBeRebased: Scalars['Boolean']\n    /** The number of changed files in this pull request. */\n    changedFiles: Scalars['Int']\n    /** The HTTP path for the checks of this pull request. */\n    checksResourcePath: Scalars['URI']\n    /** The HTTP URL for the checks of this pull request. */\n    checksUrl: Scalars['URI']\n    /** `true` if the pull request is closed */\n    closed: Scalars['Boolean']\n    /** Identifies the date and time when the object was closed. */\n    closedAt?: Maybe<Scalars['DateTime']>\n    /** List of issues that were may be closed by this pull request */\n    closingIssuesReferences?: Maybe<IssueConnection>\n    /** A list of comments associated with the pull request. */\n    comments: IssueCommentConnection\n    /** A list of commits present in this pull request's head branch not present in the base branch. */\n    commits: PullRequestCommitConnection\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The number of deletions in this pull request. */\n    deletions: Scalars['Int']\n    /** The actor who edited this pull request's body. */\n    editor?: Maybe<Actor>\n    /** Lists the files changed within this pull request. */\n    files?: Maybe<PullRequestChangedFileConnection>\n    /** Identifies the head Ref associated with the pull request. */\n    headRef?: Maybe<Ref>\n    /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */\n    headRefName: Scalars['String']\n    /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */\n    headRefOid: Scalars['GitObjectID']\n    /** The repository associated with this pull request's head Ref. */\n    headRepository?: Maybe<Repository>\n    /** The owner of the repository associated with this pull request's head Ref. */\n    headRepositoryOwner?: Maybe<RepositoryOwner>\n    /** The hovercard information for this issue */\n    hovercard: Hovercard\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** The head and base repositories are different. */\n    isCrossRepository: Scalars['Boolean']\n    /** Identifies if the pull request is a draft. */\n    isDraft: Scalars['Boolean']\n    /** Is this pull request read by the viewer */\n    isReadByViewer?: Maybe<Scalars['Boolean']>\n    /** A list of labels associated with the object. */\n    labels?: Maybe<LabelConnection>\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** A list of latest reviews per user associated with the pull request. */\n    latestOpinionatedReviews?: Maybe<PullRequestReviewConnection>\n    /** A list of latest reviews per user associated with the pull request that are not also pending review. */\n    latestReviews?: Maybe<PullRequestReviewConnection>\n    /** `true` if the pull request is locked */\n    locked: Scalars['Boolean']\n    /** Indicates whether maintainers can modify the pull request. */\n    maintainerCanModify: Scalars['Boolean']\n    /** The commit that was created when this pull request was merged. */\n    mergeCommit?: Maybe<Commit>\n    /** Detailed information about the current pull request merge state status. */\n    mergeStateStatus: MergeStateStatus\n    /** Whether or not the pull request can be merged based on the existence of merge conflicts. */\n    mergeable: MergeableState\n    /** Whether or not the pull request was merged. */\n    merged: Scalars['Boolean']\n    /** The date and time that the pull request was merged. */\n    mergedAt?: Maybe<Scalars['DateTime']>\n    /** The actor who merged the pull request. */\n    mergedBy?: Maybe<Actor>\n    /** Identifies the milestone associated with the pull request. */\n    milestone?: Maybe<Milestone>\n    /** Identifies the pull request number. */\n    number: Scalars['Int']\n    /** A list of Users that are participating in the Pull Request conversation. */\n    participants: UserConnection\n    /** The permalink to the pull request. */\n    permalink: Scalars['URI']\n    /**\n     * The commit that GitHub automatically generated to test if this pull request\n     * could be merged. This field will not return a value if the pull request is\n     * merged, or if the test merge commit is still being generated. See the\n     * `mergeable` field for more details on the mergeability of the pull request.\n     */\n    potentialMergeCommit?: Maybe<Commit>\n    /** List of project cards associated with this pull request. */\n    projectCards: ProjectCardConnection\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** The repository associated with this node. */\n    repository: Repository\n    /** The HTTP path for this pull request. */\n    resourcePath: Scalars['URI']\n    /** The HTTP path for reverting this pull request. */\n    revertResourcePath: Scalars['URI']\n    /** The HTTP URL for reverting this pull request. */\n    revertUrl: Scalars['URI']\n    /** The current status of this pull request with respect to code review. */\n    reviewDecision?: Maybe<PullRequestReviewDecision>\n    /** A list of review requests associated with the pull request. */\n    reviewRequests?: Maybe<ReviewRequestConnection>\n    /** The list of all review threads for this pull request. */\n    reviewThreads: PullRequestReviewThreadConnection\n    /** A list of reviews associated with the pull request. */\n    reviews?: Maybe<PullRequestReviewConnection>\n    /** Identifies the state of the pull request. */\n    state: PullRequestState\n    /** A list of reviewer suggestions based on commit history and past review comments. */\n    suggestedReviewers: Array<Maybe<SuggestedReviewer>>\n    /**\n     * A list of events, comments, commits, etc. associated with the pull request.\n     * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.\n     */\n    timeline: PullRequestTimelineConnection\n    /** A list of events, comments, commits, etc. associated with the pull request. */\n    timelineItems: PullRequestTimelineItemsConnection\n    /** Identifies the pull request title. */\n    title: Scalars['String']\n    /** Identifies the pull request title rendered to HTML. */\n    titleHTML: Scalars['HTML']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this pull request. */\n    url: Scalars['URI']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Whether or not the viewer can apply suggestion. */\n    viewerCanApplySuggestion: Scalars['Boolean']\n    /** Check if the viewer can restore the deleted head ref. */\n    viewerCanDeleteHeadRef: Scalars['Boolean']\n    /** Whether or not the viewer can disable auto-merge */\n    viewerCanDisableAutoMerge: Scalars['Boolean']\n    /** Whether or not the viewer can enable auto-merge */\n    viewerCanEnableAutoMerge: Scalars['Boolean']\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n    /** The latest review given from the viewer. */\n    viewerLatestReview?: Maybe<PullRequestReview>\n    /** The person who has requested the viewer for review on this pull request. */\n    viewerLatestReviewRequest?: Maybe<ReviewRequest>\n    /** The merge body text for the viewer and method. */\n    viewerMergeBodyText: Scalars['String']\n    /** The merge headline text for the viewer and method. */\n    viewerMergeHeadlineText: Scalars['String']\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>\n  }\n\n/** A repository pull request. */\nexport type PullRequestAssigneesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository pull request. */\nexport type PullRequestClosingIssuesReferencesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n}\n\n/** A repository pull request. */\nexport type PullRequestCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueCommentOrder>\n}\n\n/** A repository pull request. */\nexport type PullRequestCommitsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository pull request. */\nexport type PullRequestFilesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository pull request. */\nexport type PullRequestHovercardArgs = {\n  includeNotificationContexts?: Maybe<Scalars['Boolean']>\n}\n\n/** A repository pull request. */\nexport type PullRequestLabelsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<LabelOrder>\n}\n\n/** A repository pull request. */\nexport type PullRequestLatestOpinionatedReviewsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  writersOnly?: Maybe<Scalars['Boolean']>\n}\n\n/** A repository pull request. */\nexport type PullRequestLatestReviewsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository pull request. */\nexport type PullRequestParticipantsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository pull request. */\nexport type PullRequestProjectCardsArgs = {\n  after?: Maybe<Scalars['String']>\n  archivedStates?: Maybe<Array<Maybe<ProjectCardArchivedState>>>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository pull request. */\nexport type PullRequestReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** A repository pull request. */\nexport type PullRequestReviewRequestsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository pull request. */\nexport type PullRequestReviewThreadsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository pull request. */\nexport type PullRequestReviewsArgs = {\n  after?: Maybe<Scalars['String']>\n  author?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  states?: Maybe<Array<PullRequestReviewState>>\n}\n\n/** A repository pull request. */\nexport type PullRequestTimelineArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  since?: Maybe<Scalars['DateTime']>\n}\n\n/** A repository pull request. */\nexport type PullRequestTimelineItemsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  itemTypes?: Maybe<Array<PullRequestTimelineItemsItemType>>\n  last?: Maybe<Scalars['Int']>\n  since?: Maybe<Scalars['DateTime']>\n  skip?: Maybe<Scalars['Int']>\n}\n\n/** A repository pull request. */\nexport type PullRequestUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository pull request. */\nexport type PullRequestViewerMergeBodyTextArgs = {\n  mergeType?: Maybe<PullRequestMergeMethod>\n}\n\n/** A repository pull request. */\nexport type PullRequestViewerMergeHeadlineTextArgs = {\n  mergeType?: Maybe<PullRequestMergeMethod>\n}\n\n/** A file changed in a pull request. */\nexport type PullRequestChangedFile = {\n  /** The number of additions to the file. */\n  additions: Scalars['Int']\n  /** The number of deletions to the file. */\n  deletions: Scalars['Int']\n  /** The path of the file. */\n  path: Scalars['String']\n  /** The state of the file for the viewer. */\n  viewerViewedState: FileViewedState\n}\n\n/** The connection type for PullRequestChangedFile. */\nexport type PullRequestChangedFileConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestChangedFileEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestChangedFile>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PullRequestChangedFileEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestChangedFile>\n}\n\n/** Represents a Git commit part of a pull request. */\nexport type PullRequestCommit = Node &\n  UniformResourceLocatable & {\n    /** The Git commit object */\n    commit: Commit\n    id: Scalars['ID']\n    /** The pull request this commit belongs to */\n    pullRequest: PullRequest\n    /** The HTTP path for this pull request commit */\n    resourcePath: Scalars['URI']\n    /** The HTTP URL for this pull request commit */\n    url: Scalars['URI']\n  }\n\n/** Represents a commit comment thread part of a pull request. */\nexport type PullRequestCommitCommentThread = Node &\n  RepositoryNode & {\n    /** The comments that exist in this thread. */\n    comments: CommitCommentConnection\n    /** The commit the comments were made on. */\n    commit: Commit\n    id: Scalars['ID']\n    /** The file the comments were made on. */\n    path?: Maybe<Scalars['String']>\n    /** The position in the diff for the commit that the comment was made on. */\n    position?: Maybe<Scalars['Int']>\n    /** The pull request this commit comment thread belongs to */\n    pullRequest: PullRequest\n    /** The repository associated with this node. */\n    repository: Repository\n  }\n\n/** Represents a commit comment thread part of a pull request. */\nexport type PullRequestCommitCommentThreadCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for PullRequestCommit. */\nexport type PullRequestCommitConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestCommitEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestCommit>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PullRequestCommitEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestCommit>\n}\n\n/** The connection type for PullRequest. */\nexport type PullRequestConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequest>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** This aggregates pull requests opened by a user within one repository. */\nexport type PullRequestContributionsByRepository = {\n  /** The pull request contributions. */\n  contributions: CreatedPullRequestContributionConnection\n  /** The repository in which the pull requests were opened. */\n  repository: Repository\n}\n\n/** This aggregates pull requests opened by a user within one repository. */\nexport type PullRequestContributionsByRepositoryContributionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ContributionOrder>\n}\n\n/** An edge in a connection. */\nexport type PullRequestEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequest>\n}\n\n/** Represents available types of methods to use when merging a pull request. */\nexport enum PullRequestMergeMethod {\n  /** Add all commits from the head branch to the base branch with a merge commit. */\n  Merge = 'MERGE',\n  /** Add all commits from the head branch onto the base branch individually. */\n  Rebase = 'REBASE',\n  /** Combine all commits from the head branch into a single commit in the base branch. */\n  Squash = 'SQUASH',\n}\n\n/** Ways in which lists of issues can be ordered upon return. */\nexport type PullRequestOrder = {\n  /** The direction in which to order pull requests by the specified field. */\n  direction: OrderDirection\n  /** The field in which to order pull requests by. */\n  field: PullRequestOrderField\n}\n\n/** Properties by which pull_requests connections can be ordered. */\nexport enum PullRequestOrderField {\n  /** Order pull_requests by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order pull_requests by update time */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** A review object for a given pull request. */\nexport type PullRequestReview = Comment &\n  Deletable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Updatable &\n  UpdatableComment & {\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation\n    /** Indicates whether the author of this review has push access to the repository. */\n    authorCanPushToRepository: Scalars['Boolean']\n    /** Identifies the pull request review body. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The body of this review rendered as plain text. */\n    bodyText: Scalars['String']\n    /** A list of review comments for the current pull request review. */\n    comments: PullRequestReviewCommentConnection\n    /** Identifies the commit associated with this pull request review. */\n    commit?: Maybe<Commit>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** A list of teams that this review was made on behalf of. */\n    onBehalfOf: TeamConnection\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** Identifies the pull request associated with this pull request review. */\n    pullRequest: PullRequest\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** The repository associated with this node. */\n    repository: Repository\n    /** The HTTP path permalink for this PullRequestReview. */\n    resourcePath: Scalars['URI']\n    /** Identifies the current state of the pull request review. */\n    state: PullRequestReviewState\n    /** Identifies when the Pull Request Review was submitted */\n    submittedAt?: Maybe<Scalars['DateTime']>\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL permalink for this PullRequestReview. */\n    url: Scalars['URI']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars['Boolean']\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n  }\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewOnBehalfOfArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewComment = Comment &\n  Deletable &\n  Minimizable &\n  Node &\n  Reactable &\n  RepositoryNode &\n  Updatable &\n  UpdatableComment & {\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the subject of the comment. */\n    authorAssociation: CommentAuthorAssociation\n    /** The comment body of this review comment. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The comment body of this review comment rendered as plain text. */\n    bodyText: Scalars['String']\n    /** Identifies the commit associated with the comment. */\n    commit?: Maybe<Commit>\n    /** Identifies when the comment was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The diff hunk to which the comment applies. */\n    diffHunk: Scalars['String']\n    /** Identifies when the comment was created in a draft state. */\n    draftedAt: Scalars['DateTime']\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** Returns whether or not a comment has been minimized. */\n    isMinimized: Scalars['Boolean']\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** Returns why the comment was minimized. */\n    minimizedReason?: Maybe<Scalars['String']>\n    /** Identifies the original commit associated with the comment. */\n    originalCommit?: Maybe<Commit>\n    /** The original line index in the diff to which the comment applies. */\n    originalPosition: Scalars['Int']\n    /** Identifies when the comment body is outdated */\n    outdated: Scalars['Boolean']\n    /** The path to which the comment applies. */\n    path: Scalars['String']\n    /** The line index in the diff to which the comment applies. */\n    position?: Maybe<Scalars['Int']>\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** The pull request associated with this review comment. */\n    pullRequest: PullRequest\n    /** The pull request review associated with this review comment. */\n    pullRequestReview?: Maybe<PullRequestReview>\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** The comment this is a reply to. */\n    replyTo?: Maybe<PullRequestReviewComment>\n    /** The repository associated with this node. */\n    repository: Repository\n    /** The HTTP path permalink for this review comment. */\n    resourcePath: Scalars['URI']\n    /** Identifies the state of the comment. */\n    state: PullRequestReviewCommentState\n    /** Identifies when the comment was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL permalink for this review comment. */\n    url: Scalars['URI']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars['Boolean']\n    /** Check if the current viewer can minimize this object. */\n    viewerCanMinimize: Scalars['Boolean']\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n  }\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewCommentReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewCommentUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for PullRequestReviewComment. */\nexport type PullRequestReviewCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewCommentEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReviewComment>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PullRequestReviewCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReviewComment>\n}\n\n/** The possible states of a pull request review comment. */\nexport enum PullRequestReviewCommentState {\n  /** A comment that is part of a pending review */\n  Pending = 'PENDING',\n  /** A comment that is part of a submitted review */\n  Submitted = 'SUBMITTED',\n}\n\n/** The connection type for PullRequestReview. */\nexport type PullRequestReviewConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReview>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** This aggregates pull request reviews made by a user within one repository. */\nexport type PullRequestReviewContributionsByRepository = {\n  /** The pull request review contributions. */\n  contributions: CreatedPullRequestReviewContributionConnection\n  /** The repository in which the pull request reviews were made. */\n  repository: Repository\n}\n\n/** This aggregates pull request reviews made by a user within one repository. */\nexport type PullRequestReviewContributionsByRepositoryContributionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ContributionOrder>\n}\n\n/** The review status of a pull request. */\nexport enum PullRequestReviewDecision {\n  /** The pull request has received an approving review. */\n  Approved = 'APPROVED',\n  /** Changes have been requested on the pull request. */\n  ChangesRequested = 'CHANGES_REQUESTED',\n  /** A review is required before the pull request can be merged. */\n  ReviewRequired = 'REVIEW_REQUIRED',\n}\n\n/** An edge in a connection. */\nexport type PullRequestReviewEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReview>\n}\n\n/** The possible events to perform on a pull request review. */\nexport enum PullRequestReviewEvent {\n  /** Submit feedback and approve merging these changes. */\n  Approve = 'APPROVE',\n  /** Submit general feedback without explicit approval. */\n  Comment = 'COMMENT',\n  /** Dismiss review so it now longer effects merging. */\n  Dismiss = 'DISMISS',\n  /** Submit feedback that must be addressed before merging. */\n  RequestChanges = 'REQUEST_CHANGES',\n}\n\n/** The possible states of a pull request review. */\nexport enum PullRequestReviewState {\n  /** A review allowing the pull request to merge. */\n  Approved = 'APPROVED',\n  /** A review blocking the pull request from merging. */\n  ChangesRequested = 'CHANGES_REQUESTED',\n  /** An informational review. */\n  Commented = 'COMMENTED',\n  /** A review that has been dismissed. */\n  Dismissed = 'DISMISSED',\n  /** A review that has not yet been submitted. */\n  Pending = 'PENDING',\n}\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestReviewThread = Node & {\n  /** A list of pull request comments associated with the thread. */\n  comments: PullRequestReviewCommentConnection\n  /** The side of the diff on which this thread was placed. */\n  diffSide: DiffSide\n  id: Scalars['ID']\n  /** Whether or not the thread has been collapsed (resolved) */\n  isCollapsed: Scalars['Boolean']\n  /** Indicates whether this thread was outdated by newer changes. */\n  isOutdated: Scalars['Boolean']\n  /** Whether this thread has been resolved */\n  isResolved: Scalars['Boolean']\n  /** The line in the file to which this thread refers */\n  line?: Maybe<Scalars['Int']>\n  /** The original line in the file to which this thread refers. */\n  originalLine?: Maybe<Scalars['Int']>\n  /** The original start line in the file to which this thread refers (multi-line only). */\n  originalStartLine?: Maybe<Scalars['Int']>\n  /** Identifies the file path of this thread. */\n  path: Scalars['String']\n  /** Identifies the pull request associated with this thread. */\n  pullRequest: PullRequest\n  /** Identifies the repository associated with this thread. */\n  repository: Repository\n  /** The user who resolved this thread */\n  resolvedBy?: Maybe<User>\n  /** The side of the diff that the first line of the thread starts on (multi-line only) */\n  startDiffSide?: Maybe<DiffSide>\n  /** The start line in the file to which this thread refers (multi-line only) */\n  startLine?: Maybe<Scalars['Int']>\n  /** Indicates whether the current viewer can reply to this thread. */\n  viewerCanReply: Scalars['Boolean']\n  /** Whether or not the viewer can resolve this thread */\n  viewerCanResolve: Scalars['Boolean']\n  /** Whether or not the viewer can unresolve this thread */\n  viewerCanUnresolve: Scalars['Boolean']\n}\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestReviewThreadCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  skip?: Maybe<Scalars['Int']>\n}\n\n/** Review comment threads for a pull request review. */\nexport type PullRequestReviewThreadConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewThreadEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReviewThread>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PullRequestReviewThreadEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReviewThread>\n}\n\n/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */\nexport type PullRequestRevisionMarker = {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The last commit the viewer has seen. */\n  lastSeenCommit: Commit\n  /** The pull request to which the marker belongs. */\n  pullRequest: PullRequest\n}\n\n/** The possible states of a pull request. */\nexport enum PullRequestState {\n  /** A pull request that has been closed without being merged. */\n  Closed = 'CLOSED',\n  /** A pull request that has been closed by being merged. */\n  Merged = 'MERGED',\n  /** A pull request that is still open. */\n  Open = 'OPEN',\n}\n\n/** A repository pull request template. */\nexport type PullRequestTemplate = {\n  /** The body of the template */\n  body?: Maybe<Scalars['String']>\n  /** The filename of the template */\n  filename?: Maybe<Scalars['String']>\n  /** The repository the template belongs to */\n  repository: Repository\n}\n\n/** The connection type for PullRequestTimelineItem. */\nexport type PullRequestTimelineConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestTimelineItemEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestTimelineItem>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An item in a pull request timeline */\nexport type PullRequestTimelineItem =\n  | AssignedEvent\n  | BaseRefDeletedEvent\n  | BaseRefForcePushedEvent\n  | ClosedEvent\n  | Commit\n  | CommitCommentThread\n  | CrossReferencedEvent\n  | DemilestonedEvent\n  | DeployedEvent\n  | DeploymentEnvironmentChangedEvent\n  | HeadRefDeletedEvent\n  | HeadRefForcePushedEvent\n  | HeadRefRestoredEvent\n  | IssueComment\n  | LabeledEvent\n  | LockedEvent\n  | MergedEvent\n  | MilestonedEvent\n  | PullRequestReview\n  | PullRequestReviewComment\n  | PullRequestReviewThread\n  | ReferencedEvent\n  | RenamedTitleEvent\n  | ReopenedEvent\n  | ReviewDismissedEvent\n  | ReviewRequestRemovedEvent\n  | ReviewRequestedEvent\n  | SubscribedEvent\n  | UnassignedEvent\n  | UnlabeledEvent\n  | UnlockedEvent\n  | UnsubscribedEvent\n  | UserBlockedEvent\n\n/** An edge in a connection. */\nexport type PullRequestTimelineItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestTimelineItem>\n}\n\n/** An item in a pull request timeline */\nexport type PullRequestTimelineItems =\n  | AddedToProjectEvent\n  | AssignedEvent\n  | AutoMergeDisabledEvent\n  | AutoMergeEnabledEvent\n  | AutoRebaseEnabledEvent\n  | AutoSquashEnabledEvent\n  | AutomaticBaseChangeFailedEvent\n  | AutomaticBaseChangeSucceededEvent\n  | BaseRefChangedEvent\n  | BaseRefDeletedEvent\n  | BaseRefForcePushedEvent\n  | ClosedEvent\n  | CommentDeletedEvent\n  | ConnectedEvent\n  | ConvertToDraftEvent\n  | ConvertedNoteToIssueEvent\n  | CrossReferencedEvent\n  | DemilestonedEvent\n  | DeployedEvent\n  | DeploymentEnvironmentChangedEvent\n  | DisconnectedEvent\n  | HeadRefDeletedEvent\n  | HeadRefForcePushedEvent\n  | HeadRefRestoredEvent\n  | IssueComment\n  | LabeledEvent\n  | LockedEvent\n  | MarkedAsDuplicateEvent\n  | MentionedEvent\n  | MergedEvent\n  | MilestonedEvent\n  | MovedColumnsInProjectEvent\n  | PinnedEvent\n  | PullRequestCommit\n  | PullRequestCommitCommentThread\n  | PullRequestReview\n  | PullRequestReviewThread\n  | PullRequestRevisionMarker\n  | ReadyForReviewEvent\n  | ReferencedEvent\n  | RemovedFromProjectEvent\n  | RenamedTitleEvent\n  | ReopenedEvent\n  | ReviewDismissedEvent\n  | ReviewRequestRemovedEvent\n  | ReviewRequestedEvent\n  | SubscribedEvent\n  | TransferredEvent\n  | UnassignedEvent\n  | UnlabeledEvent\n  | UnlockedEvent\n  | UnmarkedAsDuplicateEvent\n  | UnpinnedEvent\n  | UnsubscribedEvent\n  | UserBlockedEvent\n\n/** The connection type for PullRequestTimelineItems. */\nexport type PullRequestTimelineItemsConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestTimelineItemsEdge>>>\n  /** Identifies the count of items after applying `before` and `after` filters. */\n  filteredCount: Scalars['Int']\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestTimelineItems>>>\n  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */\n  pageCount: Scalars['Int']\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n  /** Identifies the date and time when the timeline was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** An edge in a connection. */\nexport type PullRequestTimelineItemsEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestTimelineItems>\n}\n\n/** The possible item types found in a timeline. */\nexport enum PullRequestTimelineItemsItemType {\n  /** Represents a 'added_to_project' event on a given issue or pull request. */\n  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',\n  /** Represents an 'assigned' event on any assignable object. */\n  AssignedEvent = 'ASSIGNED_EVENT',\n  /** Represents a 'automatic_base_change_failed' event on a given pull request. */\n  AutomaticBaseChangeFailedEvent = 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT',\n  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */\n  AutomaticBaseChangeSucceededEvent = 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT',\n  /** Represents a 'auto_merge_disabled' event on a given pull request. */\n  AutoMergeDisabledEvent = 'AUTO_MERGE_DISABLED_EVENT',\n  /** Represents a 'auto_merge_enabled' event on a given pull request. */\n  AutoMergeEnabledEvent = 'AUTO_MERGE_ENABLED_EVENT',\n  /** Represents a 'auto_rebase_enabled' event on a given pull request. */\n  AutoRebaseEnabledEvent = 'AUTO_REBASE_ENABLED_EVENT',\n  /** Represents a 'auto_squash_enabled' event on a given pull request. */\n  AutoSquashEnabledEvent = 'AUTO_SQUASH_ENABLED_EVENT',\n  /** Represents a 'base_ref_changed' event on a given issue or pull request. */\n  BaseRefChangedEvent = 'BASE_REF_CHANGED_EVENT',\n  /** Represents a 'base_ref_deleted' event on a given pull request. */\n  BaseRefDeletedEvent = 'BASE_REF_DELETED_EVENT',\n  /** Represents a 'base_ref_force_pushed' event on a given pull request. */\n  BaseRefForcePushedEvent = 'BASE_REF_FORCE_PUSHED_EVENT',\n  /** Represents a 'closed' event on any `Closable`. */\n  ClosedEvent = 'CLOSED_EVENT',\n  /** Represents a 'comment_deleted' event on a given issue or pull request. */\n  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',\n  /** Represents a 'connected' event on a given issue or pull request. */\n  ConnectedEvent = 'CONNECTED_EVENT',\n  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\n  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',\n  /** Represents a 'convert_to_draft' event on a given pull request. */\n  ConvertToDraftEvent = 'CONVERT_TO_DRAFT_EVENT',\n  /** Represents a mention made by one issue or pull request to another. */\n  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',\n  /** Represents a 'demilestoned' event on a given issue or pull request. */\n  DemilestonedEvent = 'DEMILESTONED_EVENT',\n  /** Represents a 'deployed' event on a given pull request. */\n  DeployedEvent = 'DEPLOYED_EVENT',\n  /** Represents a 'deployment_environment_changed' event on a given pull request. */\n  DeploymentEnvironmentChangedEvent = 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT',\n  /** Represents a 'disconnected' event on a given issue or pull request. */\n  DisconnectedEvent = 'DISCONNECTED_EVENT',\n  /** Represents a 'head_ref_deleted' event on a given pull request. */\n  HeadRefDeletedEvent = 'HEAD_REF_DELETED_EVENT',\n  /** Represents a 'head_ref_force_pushed' event on a given pull request. */\n  HeadRefForcePushedEvent = 'HEAD_REF_FORCE_PUSHED_EVENT',\n  /** Represents a 'head_ref_restored' event on a given pull request. */\n  HeadRefRestoredEvent = 'HEAD_REF_RESTORED_EVENT',\n  /** Represents a comment on an Issue. */\n  IssueComment = 'ISSUE_COMMENT',\n  /** Represents a 'labeled' event on a given issue or pull request. */\n  LabeledEvent = 'LABELED_EVENT',\n  /** Represents a 'locked' event on a given issue or pull request. */\n  LockedEvent = 'LOCKED_EVENT',\n  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\n  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',\n  /** Represents a 'mentioned' event on a given issue or pull request. */\n  MentionedEvent = 'MENTIONED_EVENT',\n  /** Represents a 'merged' event on a given pull request. */\n  MergedEvent = 'MERGED_EVENT',\n  /** Represents a 'milestoned' event on a given issue or pull request. */\n  MilestonedEvent = 'MILESTONED_EVENT',\n  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\n  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',\n  /** Represents a 'pinned' event on a given issue or pull request. */\n  PinnedEvent = 'PINNED_EVENT',\n  /** Represents a Git commit part of a pull request. */\n  PullRequestCommit = 'PULL_REQUEST_COMMIT',\n  /** Represents a commit comment thread part of a pull request. */\n  PullRequestCommitCommentThread = 'PULL_REQUEST_COMMIT_COMMENT_THREAD',\n  /** A review object for a given pull request. */\n  PullRequestReview = 'PULL_REQUEST_REVIEW',\n  /** A threaded list of comments for a given pull request. */\n  PullRequestReviewThread = 'PULL_REQUEST_REVIEW_THREAD',\n  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */\n  PullRequestRevisionMarker = 'PULL_REQUEST_REVISION_MARKER',\n  /** Represents a 'ready_for_review' event on a given pull request. */\n  ReadyForReviewEvent = 'READY_FOR_REVIEW_EVENT',\n  /** Represents a 'referenced' event on a given `ReferencedSubject`. */\n  ReferencedEvent = 'REFERENCED_EVENT',\n  /** Represents a 'removed_from_project' event on a given issue or pull request. */\n  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',\n  /** Represents a 'renamed' event on a given issue or pull request */\n  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',\n  /** Represents a 'reopened' event on any `Closable`. */\n  ReopenedEvent = 'REOPENED_EVENT',\n  /** Represents a 'review_dismissed' event on a given issue or pull request. */\n  ReviewDismissedEvent = 'REVIEW_DISMISSED_EVENT',\n  /** Represents an 'review_requested' event on a given pull request. */\n  ReviewRequestedEvent = 'REVIEW_REQUESTED_EVENT',\n  /** Represents an 'review_request_removed' event on a given pull request. */\n  ReviewRequestRemovedEvent = 'REVIEW_REQUEST_REMOVED_EVENT',\n  /** Represents a 'subscribed' event on a given `Subscribable`. */\n  SubscribedEvent = 'SUBSCRIBED_EVENT',\n  /** Represents a 'transferred' event on a given issue or pull request. */\n  TransferredEvent = 'TRANSFERRED_EVENT',\n  /** Represents an 'unassigned' event on any assignable object. */\n  UnassignedEvent = 'UNASSIGNED_EVENT',\n  /** Represents an 'unlabeled' event on a given issue or pull request. */\n  UnlabeledEvent = 'UNLABELED_EVENT',\n  /** Represents an 'unlocked' event on a given issue or pull request. */\n  UnlockedEvent = 'UNLOCKED_EVENT',\n  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\n  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',\n  /** Represents an 'unpinned' event on a given issue or pull request. */\n  UnpinnedEvent = 'UNPINNED_EVENT',\n  /** Represents an 'unsubscribed' event on a given `Subscribable`. */\n  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',\n  /** Represents a 'user_blocked' event on a given user. */\n  UserBlockedEvent = 'USER_BLOCKED_EVENT',\n}\n\n/** The possible target states when updating a pull request. */\nexport enum PullRequestUpdateState {\n  /** A pull request that has been closed without being merged. */\n  Closed = 'CLOSED',\n  /** A pull request that is still open. */\n  Open = 'OPEN',\n}\n\n/** A Git push. */\nexport type Push = Node & {\n  id: Scalars['ID']\n  /** The SHA after the push */\n  nextSha?: Maybe<Scalars['GitObjectID']>\n  /** The permalink for this push. */\n  permalink: Scalars['URI']\n  /** The SHA before the push */\n  previousSha?: Maybe<Scalars['GitObjectID']>\n  /** The user who pushed */\n  pusher: User\n  /** The repository that was pushed to */\n  repository: Repository\n}\n\n/** A team, user or app who has the ability to push to a protected branch. */\nexport type PushAllowance = Node & {\n  /** The actor that can push. */\n  actor?: Maybe<PushAllowanceActor>\n  /** Identifies the branch protection rule associated with the allowed user or team. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>\n  id: Scalars['ID']\n}\n\n/** Types that can be an actor. */\nexport type PushAllowanceActor = App | Team | User\n\n/** The connection type for PushAllowance. */\nexport type PushAllowanceConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PushAllowanceEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PushAllowance>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type PushAllowanceEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<PushAllowance>\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type Query = {\n  /** Look up a code of conduct by its key */\n  codeOfConduct?: Maybe<CodeOfConduct>\n  /** Look up a code of conduct by its key */\n  codesOfConduct?: Maybe<Array<Maybe<CodeOfConduct>>>\n  /** Look up an enterprise by URL slug. */\n  enterprise?: Maybe<Enterprise>\n  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */\n  enterpriseAdministratorInvitation?: Maybe<EnterpriseAdministratorInvitation>\n  /** Look up a pending enterprise administrator invitation by invitation token. */\n  enterpriseAdministratorInvitationByToken?: Maybe<EnterpriseAdministratorInvitation>\n  /** Look up an open source license by its key */\n  license?: Maybe<License>\n  /** Return a list of known open source licenses */\n  licenses: Array<Maybe<License>>\n  /** Get alphabetically sorted list of Marketplace categories */\n  marketplaceCategories: Array<MarketplaceCategory>\n  /** Look up a Marketplace category by its slug. */\n  marketplaceCategory?: Maybe<MarketplaceCategory>\n  /** Look up a single Marketplace listing */\n  marketplaceListing?: Maybe<MarketplaceListing>\n  /** Look up Marketplace listings */\n  marketplaceListings: MarketplaceListingConnection\n  /** Return information about the GitHub instance */\n  meta: GitHubMetadata\n  /** Fetches an object given its ID. */\n  node?: Maybe<Node>\n  /** Lookup nodes by a list of IDs. */\n  nodes: Array<Maybe<Node>>\n  /** Lookup a organization by login. */\n  organization?: Maybe<Organization>\n  /** The client's rate limit information. */\n  rateLimit?: Maybe<RateLimit>\n  /** Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object */\n  relay: Query\n  /** Lookup a given repository by the owner and repository name. */\n  repository?: Maybe<Repository>\n  /** Lookup a repository owner (ie. either a User or an Organization) by login. */\n  repositoryOwner?: Maybe<RepositoryOwner>\n  /** Lookup resource by a URL. */\n  resource?: Maybe<UniformResourceLocatable>\n  /** Perform a search across resources. */\n  search: SearchResultItemConnection\n  /** GitHub Security Advisories */\n  securityAdvisories: SecurityAdvisoryConnection\n  /** Fetch a Security Advisory by its GHSA ID */\n  securityAdvisory?: Maybe<SecurityAdvisory>\n  /** Software Vulnerabilities documented by GitHub Security Advisories */\n  securityVulnerabilities: SecurityVulnerabilityConnection\n  /** Users and organizations who can be sponsored via GitHub Sponsors. */\n  sponsorables: SponsorableItemConnection\n  /** Look up a topic by name. */\n  topic?: Maybe<Topic>\n  /** Lookup a user by login. */\n  user?: Maybe<User>\n  /** The currently authenticated user. */\n  viewer: User\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryCodeOfConductArgs = {\n  key: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseArgs = {\n  invitationToken?: Maybe<Scalars['String']>\n  slug: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseAdministratorInvitationArgs = {\n  enterpriseSlug: Scalars['String']\n  role: EnterpriseAdministratorRole\n  userLogin: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseAdministratorInvitationByTokenArgs = {\n  invitationToken: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryLicenseArgs = {\n  key: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceCategoriesArgs = {\n  excludeEmpty?: Maybe<Scalars['Boolean']>\n  excludeSubcategories?: Maybe<Scalars['Boolean']>\n  includeCategories?: Maybe<Array<Scalars['String']>>\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceCategoryArgs = {\n  slug: Scalars['String']\n  useTopicAliases?: Maybe<Scalars['Boolean']>\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceListingArgs = {\n  slug: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceListingsArgs = {\n  adminId?: Maybe<Scalars['ID']>\n  after?: Maybe<Scalars['String']>\n  allStates?: Maybe<Scalars['Boolean']>\n  before?: Maybe<Scalars['String']>\n  categorySlug?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  organizationId?: Maybe<Scalars['ID']>\n  primaryCategoryOnly?: Maybe<Scalars['Boolean']>\n  slugs?: Maybe<Array<Maybe<Scalars['String']>>>\n  useTopicAliases?: Maybe<Scalars['Boolean']>\n  viewerCanAdmin?: Maybe<Scalars['Boolean']>\n  withFreeTrialsOnly?: Maybe<Scalars['Boolean']>\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryNodeArgs = {\n  id: Scalars['ID']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryNodesArgs = {\n  ids: Array<Scalars['ID']>\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryOrganizationArgs = {\n  login: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRateLimitArgs = {\n  dryRun?: Maybe<Scalars['Boolean']>\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRepositoryArgs = {\n  name: Scalars['String']\n  owner: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRepositoryOwnerArgs = {\n  login: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryResourceArgs = {\n  url: Scalars['URI']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySearchArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  query: Scalars['String']\n  type: SearchType\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityAdvisoriesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  identifier?: Maybe<SecurityAdvisoryIdentifierFilter>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SecurityAdvisoryOrder>\n  publishedSince?: Maybe<Scalars['DateTime']>\n  updatedSince?: Maybe<Scalars['DateTime']>\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityAdvisoryArgs = {\n  ghsaId: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityVulnerabilitiesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  ecosystem?: Maybe<SecurityAdvisoryEcosystem>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SecurityVulnerabilityOrder>\n  package?: Maybe<Scalars['String']>\n  severities?: Maybe<Array<SecurityAdvisorySeverity>>\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySponsorablesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  dependencyEcosystem?: Maybe<SecurityAdvisoryEcosystem>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  onlyDependencies?: Maybe<Scalars['Boolean']>\n  orderBy?: Maybe<SponsorableOrder>\n  orgLoginForDependencies?: Maybe<Scalars['String']>\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryTopicArgs = {\n  name: Scalars['String']\n}\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryUserArgs = {\n  login: Scalars['String']\n}\n\n/** Represents the client's rate limit. */\nexport type RateLimit = {\n  /** The point cost for the current query counting against the rate limit. */\n  cost: Scalars['Int']\n  /** The maximum number of points the client is permitted to consume in a 60 minute window. */\n  limit: Scalars['Int']\n  /** The maximum number of nodes this query may return */\n  nodeCount: Scalars['Int']\n  /** The number of points remaining in the current rate limit window. */\n  remaining: Scalars['Int']\n  /** The time at which the current rate limit window resets in UTC epoch seconds. */\n  resetAt: Scalars['DateTime']\n  /** The number of points used in the current rate limit window. */\n  used: Scalars['Int']\n}\n\n/** Represents a subject that can be reacted on. */\nexport type Reactable = {\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean']\n}\n\n/** Represents a subject that can be reacted on. */\nexport type ReactableReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** The connection type for User. */\nexport type ReactingUserConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactingUserEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Represents a user that's made a reaction. */\nexport type ReactingUserEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  node: User\n  /** The moment when the user made the reaction. */\n  reactedAt: Scalars['DateTime']\n}\n\n/** An emoji reaction to a particular piece of content. */\nexport type Reaction = Node & {\n  /** Identifies the emoji reaction. */\n  content: ReactionContent\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** The reactable piece of content */\n  reactable: Reactable\n  /** Identifies the user who created this reaction. */\n  user?: Maybe<User>\n}\n\n/** A list of reactions that have been left on the subject. */\nexport type ReactionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactionEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Reaction>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n  /** Whether or not the authenticated user has left a reaction on the subject. */\n  viewerHasReacted: Scalars['Boolean']\n}\n\n/** Emojis that can be attached to Issues, Pull Requests and Comments. */\nexport enum ReactionContent {\n  /** Represents the `:confused:` emoji. */\n  Confused = 'CONFUSED',\n  /** Represents the `:eyes:` emoji. */\n  Eyes = 'EYES',\n  /** Represents the `:heart:` emoji. */\n  Heart = 'HEART',\n  /** Represents the `:hooray:` emoji. */\n  Hooray = 'HOORAY',\n  /** Represents the `:laugh:` emoji. */\n  Laugh = 'LAUGH',\n  /** Represents the `:rocket:` emoji. */\n  Rocket = 'ROCKET',\n  /** Represents the `:-1:` emoji. */\n  ThumbsDown = 'THUMBS_DOWN',\n  /** Represents the `:+1:` emoji. */\n  ThumbsUp = 'THUMBS_UP',\n}\n\n/** An edge in a connection. */\nexport type ReactionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Reaction>\n}\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroup = {\n  /** Identifies the emoji reaction. */\n  content: ReactionContent\n  /** Identifies when the reaction was created. */\n  createdAt?: Maybe<Scalars['DateTime']>\n  /** Reactors to the reaction subject with the emotion represented by this reaction group. */\n  reactors: ReactorConnection\n  /** The subject that was reacted to. */\n  subject: Reactable\n  /**\n   * Users who have reacted to the reaction subject with the emotion represented by this reaction group\n   * @deprecated Reactors can now be mannequins, bots, and organizations. Use the `reactors` field instead. Removal on 2021-10-01 UTC.\n   */\n  users: ReactingUserConnection\n  /** Whether or not the authenticated user has left a reaction on the subject. */\n  viewerHasReacted: Scalars['Boolean']\n}\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroupReactorsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroupUsersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Ways in which lists of reactions can be ordered upon return. */\nexport type ReactionOrder = {\n  /** The direction in which to order reactions by the specified field. */\n  direction: OrderDirection\n  /** The field in which to order reactions by. */\n  field: ReactionOrderField\n}\n\n/** A list of fields that reactions can be ordered by. */\nexport enum ReactionOrderField {\n  /** Allows ordering a list of reactions by when they were created. */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** Types that can be assigned to reactions. */\nexport type Reactor = Bot | Mannequin | Organization | User\n\n/** The connection type for Reactor. */\nexport type ReactorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactorEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Reactor>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Represents an author of a reaction. */\nexport type ReactorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The author of the reaction. */\n  node: Reactor\n  /** The moment when the user made the reaction. */\n  reactedAt: Scalars['DateTime']\n}\n\n/** Represents a 'ready_for_review' event on a given pull request. */\nexport type ReadyForReviewEvent = Node &\n  UniformResourceLocatable & {\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    id: Scalars['ID']\n    /** PullRequest referenced by event. */\n    pullRequest: PullRequest\n    /** The HTTP path for this ready for review event. */\n    resourcePath: Scalars['URI']\n    /** The HTTP URL for this ready for review event. */\n    url: Scalars['URI']\n  }\n\n/** Represents a Git reference. */\nexport type Ref = Node & {\n  /** A list of pull requests with this ref as the head ref. */\n  associatedPullRequests: PullRequestConnection\n  /** Branch protection rules for this ref */\n  branchProtectionRule?: Maybe<BranchProtectionRule>\n  id: Scalars['ID']\n  /** The ref name. */\n  name: Scalars['String']\n  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */\n  prefix: Scalars['String']\n  /** Branch protection rules that are viewable by non-admins */\n  refUpdateRule?: Maybe<RefUpdateRule>\n  /** The repository the ref belongs to. */\n  repository: Repository\n  /** The object the ref points to. Returns null when object does not exist. */\n  target?: Maybe<GitObject>\n}\n\n/** Represents a Git reference. */\nexport type RefAssociatedPullRequestsArgs = {\n  after?: Maybe<Scalars['String']>\n  baseRefName?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  headRefName?: Maybe<Scalars['String']>\n  labels?: Maybe<Array<Scalars['String']>>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n  states?: Maybe<Array<PullRequestState>>\n}\n\n/** The connection type for Ref. */\nexport type RefConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RefEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Ref>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type RefEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Ref>\n}\n\n/** Ways in which lists of git refs can be ordered upon return. */\nexport type RefOrder = {\n  /** The direction in which to order refs by the specified field. */\n  direction: OrderDirection\n  /** The field in which to order refs by. */\n  field: RefOrderField\n}\n\n/** Properties by which ref connections can be ordered. */\nexport enum RefOrderField {\n  /** Order refs by their alphanumeric name */\n  Alphabetical = 'ALPHABETICAL',\n  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */\n  TagCommitDate = 'TAG_COMMIT_DATE',\n}\n\n/** A ref update */\nexport type RefUpdate = {\n  /** The value this ref should be updated to. */\n  afterOid: Scalars['GitObjectID']\n  /** The value this ref needs to point to before the update. */\n  beforeOid?: Maybe<Scalars['GitObjectID']>\n  /** Force a non fast-forward update. */\n  force?: Maybe<Scalars['Boolean']>\n  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */\n  name: Scalars['GitRefname']\n}\n\n/** A ref update rules for a viewer. */\nexport type RefUpdateRule = {\n  /** Can this branch be deleted. */\n  allowsDeletions: Scalars['Boolean']\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes: Scalars['Boolean']\n  /** Identifies the protection rule pattern. */\n  pattern: Scalars['String']\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars['Int']>\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']>>>\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews: Scalars['Boolean']\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution: Scalars['Boolean']\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory: Scalars['Boolean']\n  /** Are commits required to be signed. */\n  requiresSignatures: Scalars['Boolean']\n  /** Is the viewer allowed to dismiss reviews. */\n  viewerAllowedToDismissReviews: Scalars['Boolean']\n  /** Can the viewer push to the branch */\n  viewerCanPush: Scalars['Boolean']\n}\n\n/** Represents a 'referenced' event on a given `ReferencedSubject`. */\nexport type ReferencedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the commit associated with the 'referenced' event. */\n  commit?: Maybe<Commit>\n  /** Identifies the repository associated with the 'referenced' event. */\n  commitRepository: Repository\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean']\n  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */\n  isDirectReference: Scalars['Boolean']\n  /** Object referenced by event. */\n  subject: ReferencedSubject\n}\n\n/** Any referencable object */\nexport type ReferencedSubject = Issue | PullRequest\n\n/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */\nexport type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set an identity provider. */\n  enterpriseId: Scalars['ID']\n}\n\n/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */\nexport type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The identity provider for the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>\n}\n\n/** Autogenerated input type of RegenerateVerifiableDomainToken */\nexport type RegenerateVerifiableDomainTokenInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the verifiable domain to regenerate the verification token of. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of RegenerateVerifiableDomainToken */\nexport type RegenerateVerifiableDomainTokenPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The verification token that was generated. */\n  verificationToken?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of RejectDeployments */\nexport type RejectDeploymentsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Optional comment for rejecting deployments */\n  comment?: Maybe<Scalars['String']>\n  /** The ids of environments to reject deployments */\n  environmentIds: Array<Scalars['ID']>\n  /** The node ID of the workflow run containing the pending deployments. */\n  workflowRunId: Scalars['ID']\n}\n\n/** Autogenerated return type of RejectDeployments */\nexport type RejectDeploymentsPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The affected deployments. */\n  deployments?: Maybe<Array<Deployment>>\n}\n\n/** A release contains the content for a release. */\nexport type Release = Node &\n  Reactable &\n  UniformResourceLocatable & {\n    /** The author of the release */\n    author?: Maybe<User>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The description of the release. */\n    description?: Maybe<Scalars['String']>\n    /** The description of this release rendered to HTML. */\n    descriptionHTML?: Maybe<Scalars['HTML']>\n    id: Scalars['ID']\n    /** Whether or not the release is a draft */\n    isDraft: Scalars['Boolean']\n    /** Whether or not the release is the latest releast */\n    isLatest: Scalars['Boolean']\n    /** Whether or not the release is a prerelease */\n    isPrerelease: Scalars['Boolean']\n    /** A list of users mentioned in the release description */\n    mentions?: Maybe<UserConnection>\n    /** The title of the release. */\n    name?: Maybe<Scalars['String']>\n    /** Identifies the date and time when the release was created. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** List of releases assets which are dependent on this release. */\n    releaseAssets: ReleaseAssetConnection\n    /** The repository that the release belongs to. */\n    repository: Repository\n    /** The HTTP path for this issue */\n    resourcePath: Scalars['URI']\n    /** A description of the release, rendered to HTML without any links in it. */\n    shortDescriptionHTML?: Maybe<Scalars['HTML']>\n    /** The Git tag the release points to */\n    tag?: Maybe<Ref>\n    /** The tag commit for this release. */\n    tagCommit?: Maybe<Commit>\n    /** The name of the release's Git tag */\n    tagName: Scalars['String']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this issue */\n    url: Scalars['URI']\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n  }\n\n/** A release contains the content for a release. */\nexport type ReleaseMentionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A release contains the content for a release. */\nexport type ReleaseReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** A release contains the content for a release. */\nexport type ReleaseReleaseAssetsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  name?: Maybe<Scalars['String']>\n}\n\n/** A release contains the content for a release. */\nexport type ReleaseShortDescriptionHtmlArgs = {\n  limit?: Maybe<Scalars['Int']>\n}\n\n/** A release asset contains the content for a release asset. */\nexport type ReleaseAsset = Node & {\n  /** The asset's content-type */\n  contentType: Scalars['String']\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The number of times this asset was downloaded */\n  downloadCount: Scalars['Int']\n  /** Identifies the URL where you can download the release asset via the browser. */\n  downloadUrl: Scalars['URI']\n  id: Scalars['ID']\n  /** Identifies the title of the release asset. */\n  name: Scalars['String']\n  /** Release that the asset is associated with */\n  release?: Maybe<Release>\n  /** The size (in bytes) of the asset */\n  size: Scalars['Int']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The user that performed the upload */\n  uploadedBy: User\n  /** Identifies the URL of the release asset. */\n  url: Scalars['URI']\n}\n\n/** The connection type for ReleaseAsset. */\nexport type ReleaseAssetConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReleaseAssetEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReleaseAsset>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ReleaseAssetEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<ReleaseAsset>\n}\n\n/** The connection type for Release. */\nexport type ReleaseConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReleaseEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Release>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ReleaseEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Release>\n}\n\n/** Ways in which lists of releases can be ordered upon return. */\nexport type ReleaseOrder = {\n  /** The direction in which to order releases by the specified field. */\n  direction: OrderDirection\n  /** The field in which to order releases by. */\n  field: ReleaseOrderField\n}\n\n/** Properties by which release connections can be ordered. */\nexport enum ReleaseOrderField {\n  /** Order releases by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order releases alphabetically by name */\n  Name = 'NAME',\n}\n\n/** Autogenerated input type of RemoveAssigneesFromAssignable */\nexport type RemoveAssigneesFromAssignableInput = {\n  /** The id of the assignable object to remove assignees from. */\n  assignableId: Scalars['ID']\n  /** The id of users to remove as assignees. */\n  assigneeIds: Array<Scalars['ID']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of RemoveAssigneesFromAssignable */\nexport type RemoveAssigneesFromAssignablePayload = {\n  /** The item that was unassigned. */\n  assignable?: Maybe<Assignable>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of RemoveEnterpriseAdmin */\nexport type RemoveEnterpriseAdminInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Enterprise ID from which to remove the administrator. */\n  enterpriseId: Scalars['ID']\n  /** The login of the user to remove as an administrator. */\n  login: Scalars['String']\n}\n\n/** Autogenerated return type of RemoveEnterpriseAdmin */\nexport type RemoveEnterpriseAdminPayload = {\n  /** The user who was removed as an administrator. */\n  admin?: Maybe<User>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of removing an administrator. */\n  message?: Maybe<Scalars['String']>\n  /** The viewer performing the mutation. */\n  viewer?: Maybe<User>\n}\n\n/** Autogenerated input type of RemoveEnterpriseIdentityProvider */\nexport type RemoveEnterpriseIdentityProviderInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise from which to remove the identity provider. */\n  enterpriseId: Scalars['ID']\n}\n\n/** Autogenerated return type of RemoveEnterpriseIdentityProvider */\nexport type RemoveEnterpriseIdentityProviderPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The identity provider that was removed from the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>\n}\n\n/** Autogenerated input type of RemoveEnterpriseOrganization */\nexport type RemoveEnterpriseOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise from which the organization should be removed. */\n  enterpriseId: Scalars['ID']\n  /** The ID of the organization to remove from the enterprise. */\n  organizationId: Scalars['ID']\n}\n\n/** Autogenerated return type of RemoveEnterpriseOrganization */\nexport type RemoveEnterpriseOrganizationPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>\n  /** The organization that was removed from the enterprise. */\n  organization?: Maybe<Organization>\n  /** The viewer performing the mutation. */\n  viewer?: Maybe<User>\n}\n\n/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */\nexport type RemoveEnterpriseSupportEntitlementInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID']\n  /** The login of a member who will lose the support entitlement. */\n  login: Scalars['String']\n}\n\n/** Autogenerated return type of RemoveEnterpriseSupportEntitlement */\nexport type RemoveEnterpriseSupportEntitlementPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A message confirming the result of removing the support entitlement. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of RemoveLabelsFromLabelable */\nexport type RemoveLabelsFromLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ids of labels to remove. */\n  labelIds: Array<Scalars['ID']>\n  /** The id of the Labelable to remove labels from. */\n  labelableId: Scalars['ID']\n}\n\n/** Autogenerated return type of RemoveLabelsFromLabelable */\nexport type RemoveLabelsFromLabelablePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Labelable the labels were removed from. */\n  labelable?: Maybe<Labelable>\n}\n\n/** Autogenerated input type of RemoveOutsideCollaborator */\nexport type RemoveOutsideCollaboratorInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the organization to remove the outside collaborator from. */\n  organizationId: Scalars['ID']\n  /** The ID of the outside collaborator to remove. */\n  userId: Scalars['ID']\n}\n\n/** Autogenerated return type of RemoveOutsideCollaborator */\nexport type RemoveOutsideCollaboratorPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The user that was removed as an outside collaborator. */\n  removedUser?: Maybe<User>\n}\n\n/** Autogenerated input type of RemoveReaction */\nexport type RemoveReactionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The name of the emoji reaction to remove. */\n  content: ReactionContent\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID']\n}\n\n/** Autogenerated return type of RemoveReaction */\nexport type RemoveReactionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The reaction object. */\n  reaction?: Maybe<Reaction>\n  /** The reactable subject. */\n  subject?: Maybe<Reactable>\n}\n\n/** Autogenerated input type of RemoveStar */\nexport type RemoveStarInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Starrable ID to unstar. */\n  starrableId: Scalars['ID']\n}\n\n/** Autogenerated return type of RemoveStar */\nexport type RemoveStarPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The starrable. */\n  starrable?: Maybe<Starrable>\n}\n\n/** Autogenerated input type of RemoveUpvote */\nexport type RemoveUpvoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the discussion or comment to remove upvote. */\n  subjectId: Scalars['ID']\n}\n\n/** Autogenerated return type of RemoveUpvote */\nexport type RemoveUpvotePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The votable subject. */\n  subject?: Maybe<Votable>\n}\n\n/** Represents a 'removed_from_project' event on a given issue or pull request. */\nexport type RemovedFromProjectEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** Project referenced by event. */\n  project?: Maybe<Project>\n  /** Column name referenced by this project event. */\n  projectColumnName: Scalars['String']\n}\n\n/** Represents a 'renamed' event on a given issue or pull request */\nexport type RenamedTitleEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the current title of the issue or pull request. */\n  currentTitle: Scalars['String']\n  id: Scalars['ID']\n  /** Identifies the previous title of the issue or pull request. */\n  previousTitle: Scalars['String']\n  /** Subject that was renamed. */\n  subject: RenamedTitleSubject\n}\n\n/** An object which has a renamable title */\nexport type RenamedTitleSubject = Issue | PullRequest\n\n/** Autogenerated input type of ReopenIssue */\nexport type ReopenIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the issue to be opened. */\n  issueId: Scalars['ID']\n}\n\n/** Autogenerated return type of ReopenIssue */\nexport type ReopenIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The issue that was opened. */\n  issue?: Maybe<Issue>\n}\n\n/** Autogenerated input type of ReopenPullRequest */\nexport type ReopenPullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the pull request to be reopened. */\n  pullRequestId: Scalars['ID']\n}\n\n/** Autogenerated return type of ReopenPullRequest */\nexport type ReopenPullRequestPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The pull request that was reopened. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Represents a 'reopened' event on any `Closable`. */\nexport type ReopenedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Object that was reopened. */\n  closable: Closable\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n}\n\n/** Audit log entry for a repo.access event. */\nexport type RepoAccessAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoAccessAuditEntryVisibility>\n  }\n\n/** The privacy of a repository */\nexport enum RepoAccessAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC',\n}\n\n/** Audit log entry for a repo.add_member event. */\nexport type RepoAddMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoAddMemberAuditEntryVisibility>\n  }\n\n/** The privacy of a repository */\nexport enum RepoAddMemberAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC',\n}\n\n/** Audit log entry for a repo.add_topic event. */\nexport type RepoAddTopicAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData &\n  TopicAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The name of the topic added to the repository */\n    topic?: Maybe<Topic>\n    /** The name of the topic added to the repository */\n    topicName?: Maybe<Scalars['String']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.archived event. */\nexport type RepoArchivedAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoArchivedAuditEntryVisibility>\n  }\n\n/** The privacy of a repository */\nexport enum RepoArchivedAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC',\n}\n\n/** Audit log entry for a repo.change_merge_setting event. */\nexport type RepoChangeMergeSettingAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** Whether the change was to enable (true) or disable (false) the merge type */\n    isEnabled?: Maybe<Scalars['Boolean']>\n    /** The merge method affected by the change */\n    mergeType?: Maybe<RepoChangeMergeSettingAuditEntryMergeType>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The merge options available for pull requests to this repository. */\nexport enum RepoChangeMergeSettingAuditEntryMergeType {\n  /** The pull request is added to the base branch in a merge commit. */\n  Merge = 'MERGE',\n  /** Commits from the pull request are added onto the base branch individually without a merge commit. */\n  Rebase = 'REBASE',\n  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */\n  Squash = 'SQUASH',\n}\n\n/** Audit log entry for a repo.config.disable_anonymous_git_access event. */\nexport type RepoConfigDisableAnonymousGitAccessAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.config.disable_collaborators_only event. */\nexport type RepoConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.config.disable_contributors_only event. */\nexport type RepoConfigDisableContributorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */\nexport type RepoConfigDisableSockpuppetDisallowedAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.config.enable_anonymous_git_access event. */\nexport type RepoConfigEnableAnonymousGitAccessAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.config.enable_collaborators_only event. */\nexport type RepoConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.config.enable_contributors_only event. */\nexport type RepoConfigEnableContributorsOnlyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */\nexport type RepoConfigEnableSockpuppetDisallowedAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.config.lock_anonymous_git_access event. */\nexport type RepoConfigLockAnonymousGitAccessAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */\nexport type RepoConfigUnlockAnonymousGitAccessAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repo.create event. */\nexport type RepoCreateAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The name of the parent repository for this forked repository. */\n    forkParentName?: Maybe<Scalars['String']>\n    /** The name of the root repository for this network. */\n    forkSourceName?: Maybe<Scalars['String']>\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoCreateAuditEntryVisibility>\n  }\n\n/** The privacy of a repository */\nexport enum RepoCreateAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC',\n}\n\n/** Audit log entry for a repo.destroy event. */\nexport type RepoDestroyAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoDestroyAuditEntryVisibility>\n  }\n\n/** The privacy of a repository */\nexport enum RepoDestroyAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC',\n}\n\n/** Audit log entry for a repo.remove_member event. */\nexport type RepoRemoveMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n    /** The visibility of the repository */\n    visibility?: Maybe<RepoRemoveMemberAuditEntryVisibility>\n  }\n\n/** The privacy of a repository */\nexport enum RepoRemoveMemberAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC',\n}\n\n/** Audit log entry for a repo.remove_topic event. */\nexport type RepoRemoveTopicAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData &\n  TopicAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The name of the topic added to the repository */\n    topic?: Maybe<Topic>\n    /** The name of the topic added to the repository */\n    topicName?: Maybe<Scalars['String']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The reasons a piece of content can be reported or minimized. */\nexport enum ReportedContentClassifiers {\n  /** An abusive or harassing piece of content */\n  Abuse = 'ABUSE',\n  /** A duplicated piece of content */\n  Duplicate = 'DUPLICATE',\n  /** An irrelevant piece of content */\n  OffTopic = 'OFF_TOPIC',\n  /** An outdated piece of content */\n  Outdated = 'OUTDATED',\n  /** The content has been resolved */\n  Resolved = 'RESOLVED',\n  /** A spammy piece of content */\n  Spam = 'SPAM',\n}\n\n/** A repository contains the content for a project. */\nexport type Repository = Node &\n  PackageOwner &\n  ProjectOwner &\n  RepositoryInfo &\n  Starrable &\n  Subscribable &\n  UniformResourceLocatable & {\n    /** A list of users that can be assigned to issues in this repository. */\n    assignableUsers: UserConnection\n    /** Whether or not Auto-merge can be enabled on pull requests in this repository. */\n    autoMergeAllowed: Scalars['Boolean']\n    /** A list of branch protection rules for this repository. */\n    branchProtectionRules: BranchProtectionRuleConnection\n    /** Returns the code of conduct for this repository */\n    codeOfConduct?: Maybe<CodeOfConduct>\n    /** A list of collaborators associated with the repository. */\n    collaborators?: Maybe<RepositoryCollaboratorConnection>\n    /** A list of commit comments associated with the repository. */\n    commitComments: CommitCommentConnection\n    /** Returns a list of contact links associated to the repository */\n    contactLinks?: Maybe<Array<RepositoryContactLink>>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The Ref associated with the repository's default branch. */\n    defaultBranchRef?: Maybe<Ref>\n    /** Whether or not branches are automatically deleted when merged in this repository. */\n    deleteBranchOnMerge: Scalars['Boolean']\n    /** A list of dependency manifests contained in the repository */\n    dependencyGraphManifests?: Maybe<DependencyGraphManifestConnection>\n    /** A list of deploy keys that are on this repository. */\n    deployKeys: DeployKeyConnection\n    /** Deployments associated with the repository */\n    deployments: DeploymentConnection\n    /** The description of the repository. */\n    description?: Maybe<Scalars['String']>\n    /** The description of the repository rendered to HTML. */\n    descriptionHTML: Scalars['HTML']\n    /** Returns a single discussion from the current repository by number. */\n    discussion?: Maybe<Discussion>\n    /** A list of discussion categories that are available in the repository. */\n    discussionCategories: DiscussionCategoryConnection\n    /** A list of discussions that have been opened in the repository. */\n    discussions: DiscussionConnection\n    /** The number of kilobytes this repository occupies on disk. */\n    diskUsage?: Maybe<Scalars['Int']>\n    /** Returns a single active environment from the current repository by name. */\n    environment?: Maybe<Environment>\n    /** A list of environments that are in this repository. */\n    environments: EnvironmentConnection\n    /** Returns how many forks there are of this repository in the whole network. */\n    forkCount: Scalars['Int']\n    /** Whether this repository allows forks. */\n    forkingAllowed: Scalars['Boolean']\n    /** A list of direct forked repositories. */\n    forks: RepositoryConnection\n    /** The funding links for this repository */\n    fundingLinks: Array<FundingLink>\n    /** Indicates if the repository has issues feature enabled. */\n    hasIssuesEnabled: Scalars['Boolean']\n    /** Indicates if the repository has the Projects feature enabled. */\n    hasProjectsEnabled: Scalars['Boolean']\n    /** Indicates if the repository has wiki feature enabled. */\n    hasWikiEnabled: Scalars['Boolean']\n    /** The repository's URL. */\n    homepageUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The interaction ability settings for this repository. */\n    interactionAbility?: Maybe<RepositoryInteractionAbility>\n    /** Indicates if the repository is unmaintained. */\n    isArchived: Scalars['Boolean']\n    /** Returns true if blank issue creation is allowed */\n    isBlankIssuesEnabled: Scalars['Boolean']\n    /** Returns whether or not this repository disabled. */\n    isDisabled: Scalars['Boolean']\n    /** Returns whether or not this repository is empty. */\n    isEmpty: Scalars['Boolean']\n    /** Identifies if the repository is a fork. */\n    isFork: Scalars['Boolean']\n    /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */\n    isInOrganization: Scalars['Boolean']\n    /** Indicates if the repository has been locked or not. */\n    isLocked: Scalars['Boolean']\n    /** Identifies if the repository is a mirror. */\n    isMirror: Scalars['Boolean']\n    /** Identifies if the repository is private or internal. */\n    isPrivate: Scalars['Boolean']\n    /** Returns true if this repository has a security policy */\n    isSecurityPolicyEnabled?: Maybe<Scalars['Boolean']>\n    /** Identifies if the repository is a template that can be used to generate new repositories. */\n    isTemplate: Scalars['Boolean']\n    /** Is this repository a user configuration repository? */\n    isUserConfigurationRepository: Scalars['Boolean']\n    /** Returns a single issue from the current repository by number. */\n    issue?: Maybe<Issue>\n    /** Returns a single issue-like object from the current repository by number. */\n    issueOrPullRequest?: Maybe<IssueOrPullRequest>\n    /** Returns a list of issue templates associated to the repository */\n    issueTemplates?: Maybe<Array<IssueTemplate>>\n    /** A list of issues that have been opened in the repository. */\n    issues: IssueConnection\n    /** Returns a single label by name */\n    label?: Maybe<Label>\n    /** A list of labels associated with the repository. */\n    labels?: Maybe<LabelConnection>\n    /** A list containing a breakdown of the language composition of the repository. */\n    languages?: Maybe<LanguageConnection>\n    /** Get the latest release for the repository if one exists. */\n    latestRelease?: Maybe<Release>\n    /** The license associated with the repository */\n    licenseInfo?: Maybe<License>\n    /** The reason the repository has been locked. */\n    lockReason?: Maybe<RepositoryLockReason>\n    /** A list of Users that can be mentioned in the context of the repository. */\n    mentionableUsers: UserConnection\n    /** Whether or not PRs are merged with a merge commit on this repository. */\n    mergeCommitAllowed: Scalars['Boolean']\n    /** Returns a single milestone from the current repository by number. */\n    milestone?: Maybe<Milestone>\n    /** A list of milestones associated with the repository. */\n    milestones?: Maybe<MilestoneConnection>\n    /** The repository's original mirror URL. */\n    mirrorUrl?: Maybe<Scalars['URI']>\n    /** The name of the repository. */\n    name: Scalars['String']\n    /** The repository's name with owner. */\n    nameWithOwner: Scalars['String']\n    /** A Git object in the repository */\n    object?: Maybe<GitObject>\n    /** The image used to represent this repository in Open Graph data. */\n    openGraphImageUrl: Scalars['URI']\n    /** The User owner of the repository. */\n    owner: RepositoryOwner\n    /** A list of packages under the owner. */\n    packages: PackageConnection\n    /** The repository parent, if this is a fork. */\n    parent?: Maybe<Repository>\n    /** A list of discussions that have been pinned in this repository. */\n    pinnedDiscussions: PinnedDiscussionConnection\n    /** A list of pinned issues for this repository. */\n    pinnedIssues?: Maybe<PinnedIssueConnection>\n    /** The primary language of the repository's code. */\n    primaryLanguage?: Maybe<Language>\n    /** Find project by number. */\n    project?: Maybe<Project>\n    /** A list of projects under the owner. */\n    projects: ProjectConnection\n    /** The HTTP path listing the repository's projects */\n    projectsResourcePath: Scalars['URI']\n    /** The HTTP URL listing the repository's projects */\n    projectsUrl: Scalars['URI']\n    /** Returns a single pull request from the current repository by number. */\n    pullRequest?: Maybe<PullRequest>\n    /** Returns a list of pull request templates associated to the repository */\n    pullRequestTemplates?: Maybe<Array<PullRequestTemplate>>\n    /** A list of pull requests that have been opened in the repository. */\n    pullRequests: PullRequestConnection\n    /** Identifies when the repository was last pushed to. */\n    pushedAt?: Maybe<Scalars['DateTime']>\n    /** Whether or not rebase-merging is enabled on this repository. */\n    rebaseMergeAllowed: Scalars['Boolean']\n    /** Fetch a given ref from the repository */\n    ref?: Maybe<Ref>\n    /** Fetch a list of refs from the repository */\n    refs?: Maybe<RefConnection>\n    /** Lookup a single release given various criteria. */\n    release?: Maybe<Release>\n    /** List of releases which are dependent on this repository. */\n    releases: ReleaseConnection\n    /** A list of applied repository-topic associations for this repository. */\n    repositoryTopics: RepositoryTopicConnection\n    /** The HTTP path for this repository */\n    resourcePath: Scalars['URI']\n    /** The security policy URL. */\n    securityPolicyUrl?: Maybe<Scalars['URI']>\n    /** A description of the repository, rendered to HTML without any links in it. */\n    shortDescriptionHTML: Scalars['HTML']\n    /** Whether or not squash-merging is enabled on this repository. */\n    squashMergeAllowed: Scalars['Boolean']\n    /** The SSH URL to clone this repository */\n    sshUrl: Scalars['GitSSHRemote']\n    /** Returns a count of how many stargazers there are on this object */\n    stargazerCount: Scalars['Int']\n    /** A list of users who have starred this starrable. */\n    stargazers: StargazerConnection\n    /**\n     * Returns a list of all submodules in this repository parsed from the\n     * .gitmodules file as of the default branch's HEAD commit.\n     */\n    submodules: SubmoduleConnection\n    /** Temporary authentication token for cloning this repository. */\n    tempCloneToken?: Maybe<Scalars['String']>\n    /** The repository from which this repository was generated, if any. */\n    templateRepository?: Maybe<Repository>\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this repository */\n    url: Scalars['URI']\n    /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */\n    usesCustomOpenGraphImage: Scalars['Boolean']\n    /** Indicates whether the viewer has admin permissions on this repository. */\n    viewerCanAdminister: Scalars['Boolean']\n    /** Can the current viewer create new projects on this owner. */\n    viewerCanCreateProjects: Scalars['Boolean']\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars['Boolean']\n    /** Indicates whether the viewer can update the topics of this repository. */\n    viewerCanUpdateTopics: Scalars['Boolean']\n    /** The last commit email for the viewer. */\n    viewerDefaultCommitEmail?: Maybe<Scalars['String']>\n    /** The last used merge method by the viewer or the default for the repository. */\n    viewerDefaultMergeMethod: PullRequestMergeMethod\n    /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n    viewerHasStarred: Scalars['Boolean']\n    /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */\n    viewerPermission?: Maybe<RepositoryPermission>\n    /** A list of emails this viewer can commit with. */\n    viewerPossibleCommitEmails?: Maybe<Array<Scalars['String']>>\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>\n    /** Indicates the repository's visibility level. */\n    visibility: RepositoryVisibility\n    /** A list of vulnerability alerts that are on this repository. */\n    vulnerabilityAlerts?: Maybe<RepositoryVulnerabilityAlertConnection>\n    /** A list of users watching the repository. */\n    watchers: UserConnection\n  }\n\n/** A repository contains the content for a project. */\nexport type RepositoryAssignableUsersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  query?: Maybe<Scalars['String']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryBranchProtectionRulesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryCollaboratorsArgs = {\n  affiliation?: Maybe<CollaboratorAffiliation>\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  query?: Maybe<Scalars['String']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryCommitCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryDependencyGraphManifestsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  dependenciesAfter?: Maybe<Scalars['String']>\n  dependenciesFirst?: Maybe<Scalars['Int']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  withDependencies?: Maybe<Scalars['Boolean']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryDeployKeysArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryDeploymentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  environments?: Maybe<Array<Scalars['String']>>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<DeploymentOrder>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionArgs = {\n  number: Scalars['Int']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionCategoriesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  categoryId?: Maybe<Scalars['ID']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<DiscussionOrder>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryEnvironmentArgs = {\n  name: Scalars['String']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryEnvironmentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryForksArgs = {\n  affiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  isLocked?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryOrder>\n  ownerAffiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  privacy?: Maybe<RepositoryPrivacy>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssueArgs = {\n  number: Scalars['Int']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssueOrPullRequestArgs = {\n  number: Scalars['Int']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssuesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  filterBy?: Maybe<IssueFilters>\n  first?: Maybe<Scalars['Int']>\n  labels?: Maybe<Array<Scalars['String']>>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n  states?: Maybe<Array<IssueState>>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryLabelArgs = {\n  name: Scalars['String']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryLabelsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<LabelOrder>\n  query?: Maybe<Scalars['String']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryLanguagesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<LanguageOrder>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryMentionableUsersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  query?: Maybe<Scalars['String']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryMilestoneArgs = {\n  number: Scalars['Int']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryMilestonesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<MilestoneOrder>\n  query?: Maybe<Scalars['String']>\n  states?: Maybe<Array<MilestoneState>>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryObjectArgs = {\n  expression?: Maybe<Scalars['String']>\n  oid?: Maybe<Scalars['GitObjectID']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryPackagesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  names?: Maybe<Array<Maybe<Scalars['String']>>>\n  orderBy?: Maybe<PackageOrder>\n  packageType?: Maybe<PackageType>\n  repositoryId?: Maybe<Scalars['ID']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryPinnedDiscussionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryPinnedIssuesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectArgs = {\n  number: Scalars['Int']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ProjectOrder>\n  search?: Maybe<Scalars['String']>\n  states?: Maybe<Array<ProjectState>>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryPullRequestArgs = {\n  number: Scalars['Int']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryPullRequestsArgs = {\n  after?: Maybe<Scalars['String']>\n  baseRefName?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  headRefName?: Maybe<Scalars['String']>\n  labels?: Maybe<Array<Scalars['String']>>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n  states?: Maybe<Array<PullRequestState>>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryRefArgs = {\n  qualifiedName: Scalars['String']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryRefsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  direction?: Maybe<OrderDirection>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RefOrder>\n  query?: Maybe<Scalars['String']>\n  refPrefix: Scalars['String']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryReleaseArgs = {\n  tagName: Scalars['String']\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryReleasesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReleaseOrder>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryRepositoryTopicsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryShortDescriptionHtmlArgs = {\n  limit?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryStargazersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<StarOrder>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositorySubmodulesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryVulnerabilityAlertsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A repository contains the content for a project. */\nexport type RepositoryWatchersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The affiliation of a user to a repository */\nexport enum RepositoryAffiliation {\n  /** Repositories that the user has been added to as a collaborator. */\n  Collaborator = 'COLLABORATOR',\n  /**\n   * Repositories that the user has access to through being a member of an\n   * organization. This includes every repository on every team that the user is on.\n   */\n  OrganizationMember = 'ORGANIZATION_MEMBER',\n  /** Repositories that are owned by the authenticated user. */\n  Owner = 'OWNER',\n}\n\n/** Metadata for an audit entry with action repo.* */\nexport type RepositoryAuditEntryData = {\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>\n}\n\n/** The connection type for User. */\nexport type RepositoryCollaboratorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryCollaboratorEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Represents a user who is a collaborator of a repository. */\nexport type RepositoryCollaboratorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  node: User\n  /** The permission the user has on the repository. */\n  permission: RepositoryPermission\n  /** A list of sources for the user's access to the repository. */\n  permissionSources?: Maybe<Array<PermissionSource>>\n}\n\n/** A list of repositories owned by the subject. */\nexport type RepositoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n  /** The total size in kilobytes of all repositories in the connection. */\n  totalDiskUsage: Scalars['Int']\n}\n\n/** A repository contact link. */\nexport type RepositoryContactLink = {\n  /** The contact link purpose. */\n  about: Scalars['String']\n  /** The contact link name. */\n  name: Scalars['String']\n  /** The contact link URL. */\n  url: Scalars['URI']\n}\n\n/** The reason a repository is listed as 'contributed'. */\nexport enum RepositoryContributionType {\n  /** Created a commit */\n  Commit = 'COMMIT',\n  /** Created an issue */\n  Issue = 'ISSUE',\n  /** Created a pull request */\n  PullRequest = 'PULL_REQUEST',\n  /** Reviewed a pull request */\n  PullRequestReview = 'PULL_REQUEST_REVIEW',\n  /** Created the repository */\n  Repository = 'REPOSITORY',\n}\n\n/** Represents an author of discussions in repositories. */\nexport type RepositoryDiscussionAuthor = {\n  /** Discussions this user has started. */\n  repositoryDiscussions: DiscussionConnection\n}\n\n/** Represents an author of discussions in repositories. */\nexport type RepositoryDiscussionAuthorRepositoryDiscussionsArgs = {\n  after?: Maybe<Scalars['String']>\n  answered?: Maybe<Scalars['Boolean']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<DiscussionOrder>\n  repositoryId?: Maybe<Scalars['ID']>\n}\n\n/** Represents an author of discussion comments in repositories. */\nexport type RepositoryDiscussionCommentAuthor = {\n  /** Discussion comments this user has authored. */\n  repositoryDiscussionComments: DiscussionCommentConnection\n}\n\n/** Represents an author of discussion comments in repositories. */\nexport type RepositoryDiscussionCommentAuthorRepositoryDiscussionCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  onlyAnswers?: Maybe<Scalars['Boolean']>\n  repositoryId?: Maybe<Scalars['ID']>\n}\n\n/** An edge in a connection. */\nexport type RepositoryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Repository>\n}\n\n/** A subset of repository info. */\nexport type RepositoryInfo = {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The description of the repository. */\n  description?: Maybe<Scalars['String']>\n  /** The description of the repository rendered to HTML. */\n  descriptionHTML: Scalars['HTML']\n  /** Returns how many forks there are of this repository in the whole network. */\n  forkCount: Scalars['Int']\n  /** Indicates if the repository has issues feature enabled. */\n  hasIssuesEnabled: Scalars['Boolean']\n  /** Indicates if the repository has the Projects feature enabled. */\n  hasProjectsEnabled: Scalars['Boolean']\n  /** Indicates if the repository has wiki feature enabled. */\n  hasWikiEnabled: Scalars['Boolean']\n  /** The repository's URL. */\n  homepageUrl?: Maybe<Scalars['URI']>\n  /** Indicates if the repository is unmaintained. */\n  isArchived: Scalars['Boolean']\n  /** Identifies if the repository is a fork. */\n  isFork: Scalars['Boolean']\n  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */\n  isInOrganization: Scalars['Boolean']\n  /** Indicates if the repository has been locked or not. */\n  isLocked: Scalars['Boolean']\n  /** Identifies if the repository is a mirror. */\n  isMirror: Scalars['Boolean']\n  /** Identifies if the repository is private or internal. */\n  isPrivate: Scalars['Boolean']\n  /** Identifies if the repository is a template that can be used to generate new repositories. */\n  isTemplate: Scalars['Boolean']\n  /** The license associated with the repository */\n  licenseInfo?: Maybe<License>\n  /** The reason the repository has been locked. */\n  lockReason?: Maybe<RepositoryLockReason>\n  /** The repository's original mirror URL. */\n  mirrorUrl?: Maybe<Scalars['URI']>\n  /** The name of the repository. */\n  name: Scalars['String']\n  /** The repository's name with owner. */\n  nameWithOwner: Scalars['String']\n  /** The image used to represent this repository in Open Graph data. */\n  openGraphImageUrl: Scalars['URI']\n  /** The User owner of the repository. */\n  owner: RepositoryOwner\n  /** Identifies when the repository was last pushed to. */\n  pushedAt?: Maybe<Scalars['DateTime']>\n  /** The HTTP path for this repository */\n  resourcePath: Scalars['URI']\n  /** A description of the repository, rendered to HTML without any links in it. */\n  shortDescriptionHTML: Scalars['HTML']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The HTTP URL for this repository */\n  url: Scalars['URI']\n  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */\n  usesCustomOpenGraphImage: Scalars['Boolean']\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility\n}\n\n/** A subset of repository info. */\nexport type RepositoryInfoShortDescriptionHtmlArgs = {\n  limit?: Maybe<Scalars['Int']>\n}\n\n/** Repository interaction limit that applies to this object. */\nexport type RepositoryInteractionAbility = {\n  /** The time the currently active limit expires. */\n  expiresAt?: Maybe<Scalars['DateTime']>\n  /** The current limit that is enabled on this object. */\n  limit: RepositoryInteractionLimit\n  /** The origin of the currently active interaction limit. */\n  origin: RepositoryInteractionLimitOrigin\n}\n\n/** A repository interaction limit. */\nexport enum RepositoryInteractionLimit {\n  /** Users that are not collaborators will not be able to interact with the repository. */\n  CollaboratorsOnly = 'COLLABORATORS_ONLY',\n  /** Users that have not previously committed to a repository’s default branch will be unable to interact with the repository. */\n  ContributorsOnly = 'CONTRIBUTORS_ONLY',\n  /** Users that have recently created their account will be unable to interact with the repository. */\n  ExistingUsers = 'EXISTING_USERS',\n  /** No interaction limits are enabled. */\n  NoLimit = 'NO_LIMIT',\n}\n\n/** The length for a repository interaction limit to be enabled for. */\nexport enum RepositoryInteractionLimitExpiry {\n  /** The interaction limit will expire after 1 day. */\n  OneDay = 'ONE_DAY',\n  /** The interaction limit will expire after 1 month. */\n  OneMonth = 'ONE_MONTH',\n  /** The interaction limit will expire after 1 week. */\n  OneWeek = 'ONE_WEEK',\n  /** The interaction limit will expire after 6 months. */\n  SixMonths = 'SIX_MONTHS',\n  /** The interaction limit will expire after 3 days. */\n  ThreeDays = 'THREE_DAYS',\n}\n\n/** Indicates where an interaction limit is configured. */\nexport enum RepositoryInteractionLimitOrigin {\n  /** A limit that is configured at the organization level. */\n  Organization = 'ORGANIZATION',\n  /** A limit that is configured at the repository level. */\n  Repository = 'REPOSITORY',\n  /** A limit that is configured at the user-wide level. */\n  User = 'USER',\n}\n\n/** An invitation for a user to be added to a repository. */\nexport type RepositoryInvitation = Node & {\n  /** The email address that received the invitation. */\n  email?: Maybe<Scalars['String']>\n  id: Scalars['ID']\n  /** The user who received the invitation. */\n  invitee?: Maybe<User>\n  /** The user who created the invitation. */\n  inviter: User\n  /** The permalink for this repository invitation. */\n  permalink: Scalars['URI']\n  /** The permission granted on this repository by this invitation. */\n  permission: RepositoryPermission\n  /** The Repository the user is invited to. */\n  repository?: Maybe<RepositoryInfo>\n}\n\n/** The connection type for RepositoryInvitation. */\nexport type RepositoryInvitationConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryInvitationEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryInvitation>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type RepositoryInvitationEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryInvitation>\n}\n\n/** Ordering options for repository invitation connections. */\nexport type RepositoryInvitationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order repository invitations by. */\n  field: RepositoryInvitationOrderField\n}\n\n/** Properties by which repository invitation connections can be ordered. */\nexport enum RepositoryInvitationOrderField {\n  /** Order repository invitations by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order repository invitations by invitee login */\n  InviteeLogin = 'INVITEE_LOGIN',\n}\n\n/** The possible reasons a given repository could be in a locked state. */\nexport enum RepositoryLockReason {\n  /** The repository is locked due to a billing related reason. */\n  Billing = 'BILLING',\n  /** The repository is locked due to a migration. */\n  Migrating = 'MIGRATING',\n  /** The repository is locked due to a move. */\n  Moving = 'MOVING',\n  /** The repository is locked due to a rename. */\n  Rename = 'RENAME',\n}\n\n/** Represents a object that belongs to a repository. */\nexport type RepositoryNode = {\n  /** The repository associated with this node. */\n  repository: Repository\n}\n\n/** Ordering options for repository connections */\nexport type RepositoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order repositories by. */\n  field: RepositoryOrderField\n}\n\n/** Properties by which repository connections can be ordered. */\nexport enum RepositoryOrderField {\n  /** Order repositories by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order repositories by name */\n  Name = 'NAME',\n  /** Order repositories by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order repositories by number of stargazers */\n  Stargazers = 'STARGAZERS',\n  /** Order repositories by update time */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwner = {\n  /** A URL pointing to the owner's public avatar. */\n  avatarUrl: Scalars['URI']\n  id: Scalars['ID']\n  /** The username used to login. */\n  login: Scalars['String']\n  /** A list of repositories that the user owns. */\n  repositories: RepositoryConnection\n  /** Find Repository. */\n  repository?: Maybe<Repository>\n  /** The HTTP URL for the owner. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for the owner. */\n  url: Scalars['URI']\n}\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerRepositoriesArgs = {\n  affiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  isFork?: Maybe<Scalars['Boolean']>\n  isLocked?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryOrder>\n  ownerAffiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  privacy?: Maybe<RepositoryPrivacy>\n}\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerRepositoryArgs = {\n  name: Scalars['String']\n}\n\n/** The access level to a repository */\nexport enum RepositoryPermission {\n  /**\n   * Can read, clone, and push to this repository. Can also manage issues, pull\n   * requests, and repository settings, including adding collaborators\n   */\n  Admin = 'ADMIN',\n  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */\n  Maintain = 'MAINTAIN',\n  /** Can read and clone this repository. Can also open and comment on issues and pull requests */\n  Read = 'READ',\n  /** Can read and clone this repository. Can also manage issues and pull requests */\n  Triage = 'TRIAGE',\n  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */\n  Write = 'WRITE',\n}\n\n/** The privacy of a repository */\nexport enum RepositoryPrivacy {\n  /** Private */\n  Private = 'PRIVATE',\n  /** Public */\n  Public = 'PUBLIC',\n}\n\n/** A repository-topic connects a repository to a topic. */\nexport type RepositoryTopic = Node &\n  UniformResourceLocatable & {\n    id: Scalars['ID']\n    /** The HTTP path for this repository-topic. */\n    resourcePath: Scalars['URI']\n    /** The topic. */\n    topic: Topic\n    /** The HTTP URL for this repository-topic. */\n    url: Scalars['URI']\n  }\n\n/** The connection type for RepositoryTopic. */\nexport type RepositoryTopicConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryTopicEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryTopic>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type RepositoryTopicEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryTopic>\n}\n\n/** The repository's visibility level. */\nexport enum RepositoryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC',\n}\n\n/** Audit log entry for a repository_visibility_change.disable event. */\nexport type RepositoryVisibilityChangeDisableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars['URI']>\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars['String']>\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a repository_visibility_change.enable event. */\nexport type RepositoryVisibilityChangeEnableAuditEntry = AuditEntry &\n  EnterpriseAuditEntryData &\n  Node &\n  OrganizationAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    /** The HTTP path for this enterprise. */\n    enterpriseResourcePath?: Maybe<Scalars['URI']>\n    /** The slug of the enterprise. */\n    enterpriseSlug?: Maybe<Scalars['String']>\n    /** The HTTP URL for this enterprise. */\n    enterpriseUrl?: Maybe<Scalars['URI']>\n    id: Scalars['ID']\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** A Dependabot alert for a repository with a dependency affected by a security vulnerability. */\nexport type RepositoryVulnerabilityAlert = Node &\n  RepositoryNode & {\n    /** When was the alert created? */\n    createdAt: Scalars['DateTime']\n    /** The reason the alert was dismissed */\n    dismissReason?: Maybe<Scalars['String']>\n    /** When was the alert dismissed? */\n    dismissedAt?: Maybe<Scalars['DateTime']>\n    /** The user who dismissed the alert */\n    dismisser?: Maybe<User>\n    id: Scalars['ID']\n    /** The associated repository */\n    repository: Repository\n    /** The associated security advisory */\n    securityAdvisory?: Maybe<SecurityAdvisory>\n    /** The associated security vulnerability */\n    securityVulnerability?: Maybe<SecurityVulnerability>\n    /** The vulnerable manifest filename */\n    vulnerableManifestFilename: Scalars['String']\n    /** The vulnerable manifest path */\n    vulnerableManifestPath: Scalars['String']\n    /** The vulnerable requirements */\n    vulnerableRequirements?: Maybe<Scalars['String']>\n  }\n\n/** The connection type for RepositoryVulnerabilityAlert. */\nexport type RepositoryVulnerabilityAlertConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryVulnerabilityAlertEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryVulnerabilityAlert>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type RepositoryVulnerabilityAlertEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryVulnerabilityAlert>\n}\n\n/** Autogenerated input type of RequestReviews */\nexport type RequestReviewsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the pull request to modify. */\n  pullRequestId: Scalars['ID']\n  /** The Node IDs of the team to request. */\n  teamIds?: Maybe<Array<Scalars['ID']>>\n  /** Add users to the set rather than replace. */\n  union?: Maybe<Scalars['Boolean']>\n  /** The Node IDs of the user to request. */\n  userIds?: Maybe<Array<Scalars['ID']>>\n}\n\n/** Autogenerated return type of RequestReviews */\nexport type RequestReviewsPayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The pull request that is getting requests. */\n  pullRequest?: Maybe<PullRequest>\n  /** The edge from the pull request to the requested reviewers. */\n  requestedReviewersEdge?: Maybe<UserEdge>\n}\n\n/** The possible states that can be requested when creating a check run. */\nexport enum RequestableCheckStatusState {\n  /** The check suite or run has been completed. */\n  Completed = 'COMPLETED',\n  /** The check suite or run is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The check suite or run is in pending state. */\n  Pending = 'PENDING',\n  /** The check suite or run has been queued. */\n  Queued = 'QUEUED',\n  /** The check suite or run is in waiting state. */\n  Waiting = 'WAITING',\n}\n\n/** Types that can be requested reviewers. */\nexport type RequestedReviewer = Mannequin | Team | User\n\n/** Represents a type that can be required by a pull request for merging. */\nexport type RequirableByPullRequest = {\n  /** Whether this is required to pass before merging for a specific pull request. */\n  isRequired: Scalars['Boolean']\n}\n\n/** Represents a type that can be required by a pull request for merging. */\nexport type RequirableByPullRequestIsRequiredArgs = {\n  pullRequestId?: Maybe<Scalars['ID']>\n  pullRequestNumber?: Maybe<Scalars['Int']>\n}\n\n/** Autogenerated input type of RerequestCheckSuite */\nexport type RerequestCheckSuiteInput = {\n  /** The Node ID of the check suite. */\n  checkSuiteId: Scalars['ID']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of RerequestCheckSuite */\nexport type RerequestCheckSuitePayload = {\n  /** The requested check suite. */\n  checkSuite?: Maybe<CheckSuite>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of ResolveReviewThread */\nexport type ResolveReviewThreadInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the thread to resolve */\n  threadId: Scalars['ID']\n}\n\n/** Autogenerated return type of ResolveReviewThread */\nexport type ResolveReviewThreadPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The thread to resolve. */\n  thread?: Maybe<PullRequestReviewThread>\n}\n\n/** Represents a private contribution a user made on GitHub. */\nexport type RestrictedContribution = Contribution & {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean']\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime']\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI']\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI']\n  /** The user who made this contribution. */\n  user: User\n}\n\n/** A team or user who has the ability to dismiss a review on a protected branch. */\nexport type ReviewDismissalAllowance = Node & {\n  /** The actor that can dismiss. */\n  actor?: Maybe<ReviewDismissalAllowanceActor>\n  /** Identifies the branch protection rule associated with the allowed user or team. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>\n  id: Scalars['ID']\n}\n\n/** Types that can be an actor. */\nexport type ReviewDismissalAllowanceActor = Team | User\n\n/** The connection type for ReviewDismissalAllowance. */\nexport type ReviewDismissalAllowanceConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReviewDismissalAllowanceEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReviewDismissalAllowance>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ReviewDismissalAllowanceEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<ReviewDismissalAllowance>\n}\n\n/** Represents a 'review_dismissed' event on a given issue or pull request. */\nexport type ReviewDismissedEvent = Node &\n  UniformResourceLocatable & {\n    /** Identifies the actor who performed the event. */\n    actor?: Maybe<Actor>\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** Identifies the optional message associated with the 'review_dismissed' event. */\n    dismissalMessage?: Maybe<Scalars['String']>\n    /** Identifies the optional message associated with the event, rendered to HTML. */\n    dismissalMessageHTML?: Maybe<Scalars['String']>\n    id: Scalars['ID']\n    /** Identifies the previous state of the review with the 'review_dismissed' event. */\n    previousReviewState: PullRequestReviewState\n    /** PullRequest referenced by event. */\n    pullRequest: PullRequest\n    /** Identifies the commit which caused the review to become stale. */\n    pullRequestCommit?: Maybe<PullRequestCommit>\n    /** The HTTP path for this review dismissed event. */\n    resourcePath: Scalars['URI']\n    /** Identifies the review associated with the 'review_dismissed' event. */\n    review?: Maybe<PullRequestReview>\n    /** The HTTP URL for this review dismissed event. */\n    url: Scalars['URI']\n  }\n\n/** A request for a user to review a pull request. */\nexport type ReviewRequest = Node & {\n  /** Whether this request was created for a code owner */\n  asCodeOwner: Scalars['Boolean']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** Identifies the pull request associated with this review request. */\n  pullRequest: PullRequest\n  /** The reviewer that is requested. */\n  requestedReviewer?: Maybe<RequestedReviewer>\n}\n\n/** The connection type for ReviewRequest. */\nexport type ReviewRequestConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReviewRequestEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReviewRequest>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type ReviewRequestEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<ReviewRequest>\n}\n\n/** Represents an 'review_request_removed' event on a given pull request. */\nexport type ReviewRequestRemovedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n  /** Identifies the reviewer whose review request was removed. */\n  requestedReviewer?: Maybe<RequestedReviewer>\n}\n\n/** Represents an 'review_requested' event on a given pull request. */\nexport type ReviewRequestedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest\n  /** Identifies the reviewer whose review was requested. */\n  requestedReviewer?: Maybe<RequestedReviewer>\n}\n\n/**\n * A hovercard context with a message describing the current code review state of the pull\n * request.\n */\nexport type ReviewStatusHovercardContext = HovercardContext & {\n  /** A string describing this context */\n  message: Scalars['String']\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']\n  /** The current status of the pull request with respect to code review. */\n  reviewDecision?: Maybe<PullRequestReviewDecision>\n}\n\n/** The possible digest algorithms used to sign SAML requests for an identity provider. */\nexport enum SamlDigestAlgorithm {\n  /** SHA1 */\n  Sha1 = 'SHA1',\n  /** SHA256 */\n  Sha256 = 'SHA256',\n  /** SHA384 */\n  Sha384 = 'SHA384',\n  /** SHA512 */\n  Sha512 = 'SHA512',\n}\n\n/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */\nexport enum SamlSignatureAlgorithm {\n  /** RSA-SHA1 */\n  RsaSha1 = 'RSA_SHA1',\n  /** RSA-SHA256 */\n  RsaSha256 = 'RSA_SHA256',\n  /** RSA-SHA384 */\n  RsaSha384 = 'RSA_SHA384',\n  /** RSA-SHA512 */\n  RsaSha512 = 'RSA_SHA512',\n}\n\n/** A Saved Reply is text a user can use to reply quickly. */\nexport type SavedReply = Node & {\n  /** The body of the saved reply. */\n  body: Scalars['String']\n  /** The saved reply body rendered to HTML. */\n  bodyHTML: Scalars['HTML']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** The title of the saved reply. */\n  title: Scalars['String']\n  /** The user that saved this reply. */\n  user?: Maybe<Actor>\n}\n\n/** The connection type for SavedReply. */\nexport type SavedReplyConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SavedReplyEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SavedReply>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type SavedReplyEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<SavedReply>\n}\n\n/** Ordering options for saved reply connections. */\nexport type SavedReplyOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order saved replies by. */\n  field: SavedReplyOrderField\n}\n\n/** Properties by which saved reply connections can be ordered. */\nexport enum SavedReplyOrderField {\n  /** Order saved reply by when they were updated. */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** The results of a search. */\nexport type SearchResultItem =\n  | App\n  | Discussion\n  | Issue\n  | MarketplaceListing\n  | Organization\n  | PullRequest\n  | Repository\n  | User\n\n/** A list of results that matched against a search query. */\nexport type SearchResultItemConnection = {\n  /** The number of pieces of code that matched the search query. */\n  codeCount: Scalars['Int']\n  /** The number of discussions that matched the search query. */\n  discussionCount: Scalars['Int']\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SearchResultItemEdge>>>\n  /** The number of issues that matched the search query. */\n  issueCount: Scalars['Int']\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SearchResultItem>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** The number of repositories that matched the search query. */\n  repositoryCount: Scalars['Int']\n  /** The number of users that matched the search query. */\n  userCount: Scalars['Int']\n  /** The number of wiki pages that matched the search query. */\n  wikiCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type SearchResultItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<SearchResultItem>\n  /** Text matches on the result found. */\n  textMatches?: Maybe<Array<Maybe<TextMatch>>>\n}\n\n/** Represents the individual results of a search. */\nexport enum SearchType {\n  /** Returns matching discussions in repositories. */\n  Discussion = 'DISCUSSION',\n  /** Returns results matching issues in repositories. */\n  Issue = 'ISSUE',\n  /** Returns results matching repositories. */\n  Repository = 'REPOSITORY',\n  /** Returns results matching users and organizations on GitHub. */\n  User = 'USER',\n}\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisory = Node & {\n  /** The CVSS associated with this advisory */\n  cvss: Cvss\n  /** CWEs associated with this Advisory */\n  cwes: CweConnection\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** This is a long plaintext description of the advisory */\n  description: Scalars['String']\n  /** The GitHub Security Advisory ID */\n  ghsaId: Scalars['String']\n  id: Scalars['ID']\n  /** A list of identifiers for this advisory */\n  identifiers: Array<SecurityAdvisoryIdentifier>\n  /** The permalink for the advisory's dependabot alerts page */\n  notificationsPermalink?: Maybe<Scalars['URI']>\n  /** The organization that originated the advisory */\n  origin: Scalars['String']\n  /** The permalink for the advisory */\n  permalink?: Maybe<Scalars['URI']>\n  /** When the advisory was published */\n  publishedAt: Scalars['DateTime']\n  /** A list of references for this advisory */\n  references: Array<SecurityAdvisoryReference>\n  /** The severity of the advisory */\n  severity: SecurityAdvisorySeverity\n  /** A short plaintext summary of the advisory */\n  summary: Scalars['String']\n  /** When the advisory was last updated */\n  updatedAt: Scalars['DateTime']\n  /** Vulnerabilities associated with this Advisory */\n  vulnerabilities: SecurityVulnerabilityConnection\n  /** When the advisory was withdrawn, if it has been withdrawn */\n  withdrawnAt?: Maybe<Scalars['DateTime']>\n}\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisoryCwesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisoryVulnerabilitiesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  ecosystem?: Maybe<SecurityAdvisoryEcosystem>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SecurityVulnerabilityOrder>\n  package?: Maybe<Scalars['String']>\n  severities?: Maybe<Array<SecurityAdvisorySeverity>>\n}\n\n/** The connection type for SecurityAdvisory. */\nexport type SecurityAdvisoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SecurityAdvisoryEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SecurityAdvisory>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** The possible ecosystems of a security vulnerability's package. */\nexport enum SecurityAdvisoryEcosystem {\n  /** PHP packages hosted at packagist.org */\n  Composer = 'COMPOSER',\n  /** Go modules */\n  Go = 'GO',\n  /** Java artifacts hosted at the Maven central repository */\n  Maven = 'MAVEN',\n  /** JavaScript packages hosted at npmjs.com */\n  Npm = 'NPM',\n  /** .NET packages hosted at the NuGet Gallery */\n  Nuget = 'NUGET',\n  /** Python packages hosted at PyPI.org */\n  Pip = 'PIP',\n  /** Ruby gems hosted at RubyGems.org */\n  Rubygems = 'RUBYGEMS',\n  /** Rust crates */\n  Rust = 'RUST',\n}\n\n/** An edge in a connection. */\nexport type SecurityAdvisoryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<SecurityAdvisory>\n}\n\n/** A GitHub Security Advisory Identifier */\nexport type SecurityAdvisoryIdentifier = {\n  /** The identifier type, e.g. GHSA, CVE */\n  type: Scalars['String']\n  /** The identifier */\n  value: Scalars['String']\n}\n\n/** An advisory identifier to filter results on. */\nexport type SecurityAdvisoryIdentifierFilter = {\n  /** The identifier type. */\n  type: SecurityAdvisoryIdentifierType\n  /** The identifier string. Supports exact or partial matching. */\n  value: Scalars['String']\n}\n\n/** Identifier formats available for advisories. */\nexport enum SecurityAdvisoryIdentifierType {\n  /** Common Vulnerabilities and Exposures Identifier. */\n  Cve = 'CVE',\n  /** GitHub Security Advisory ID. */\n  Ghsa = 'GHSA',\n}\n\n/** Ordering options for security advisory connections */\nexport type SecurityAdvisoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order security advisories by. */\n  field: SecurityAdvisoryOrderField\n}\n\n/** Properties by which security advisory connections can be ordered. */\nexport enum SecurityAdvisoryOrderField {\n  /** Order advisories by publication time */\n  PublishedAt = 'PUBLISHED_AT',\n  /** Order advisories by update time */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** An individual package */\nexport type SecurityAdvisoryPackage = {\n  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */\n  ecosystem: SecurityAdvisoryEcosystem\n  /** The package name */\n  name: Scalars['String']\n}\n\n/** An individual package version */\nexport type SecurityAdvisoryPackageVersion = {\n  /** The package name or version */\n  identifier: Scalars['String']\n}\n\n/** A GitHub Security Advisory Reference */\nexport type SecurityAdvisoryReference = {\n  /** A publicly accessible reference */\n  url: Scalars['URI']\n}\n\n/** Severity of the vulnerability. */\nexport enum SecurityAdvisorySeverity {\n  /** Critical. */\n  Critical = 'CRITICAL',\n  /** High. */\n  High = 'HIGH',\n  /** Low. */\n  Low = 'LOW',\n  /** Moderate. */\n  Moderate = 'MODERATE',\n}\n\n/** An individual vulnerability within an Advisory */\nexport type SecurityVulnerability = {\n  /** The Advisory associated with this Vulnerability */\n  advisory: SecurityAdvisory\n  /** The first version containing a fix for the vulnerability */\n  firstPatchedVersion?: Maybe<SecurityAdvisoryPackageVersion>\n  /** A description of the vulnerable package */\n  package: SecurityAdvisoryPackage\n  /** The severity of the vulnerability within this package */\n  severity: SecurityAdvisorySeverity\n  /** When the vulnerability was last updated */\n  updatedAt: Scalars['DateTime']\n  /**\n   * A string that describes the vulnerable package versions.\n   * This string follows a basic syntax with a few forms.\n   * + `= 0.2.0` denotes a single vulnerable version.\n   * + `<= 1.0.8` denotes a version range up to and including the specified version\n   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version\n   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.\n   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum\n   */\n  vulnerableVersionRange: Scalars['String']\n}\n\n/** The connection type for SecurityVulnerability. */\nexport type SecurityVulnerabilityConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SecurityVulnerabilityEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SecurityVulnerability>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type SecurityVulnerabilityEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<SecurityVulnerability>\n}\n\n/** Ordering options for security vulnerability connections */\nexport type SecurityVulnerabilityOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order security vulnerabilities by. */\n  field: SecurityVulnerabilityOrderField\n}\n\n/** Properties by which security vulnerability connections can be ordered. */\nexport enum SecurityVulnerabilityOrderField {\n  /** Order vulnerability by update time */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** Autogenerated input type of SetEnterpriseIdentityProvider */\nexport type SetEnterpriseIdentityProviderInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The digest algorithm used to sign SAML requests for the identity provider. */\n  digestMethod: SamlDigestAlgorithm\n  /** The ID of the enterprise on which to set an identity provider. */\n  enterpriseId: Scalars['ID']\n  /** The x509 certificate used by the identity provider to sign assertions and responses. */\n  idpCertificate: Scalars['String']\n  /** The Issuer Entity ID for the SAML identity provider */\n  issuer?: Maybe<Scalars['String']>\n  /** The signature algorithm used to sign SAML requests for the identity provider. */\n  signatureMethod: SamlSignatureAlgorithm\n  /** The URL endpoint for the identity provider's SAML SSO. */\n  ssoUrl: Scalars['URI']\n}\n\n/** Autogenerated return type of SetEnterpriseIdentityProvider */\nexport type SetEnterpriseIdentityProviderPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The identity provider for the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>\n}\n\n/** Autogenerated input type of SetOrganizationInteractionLimit */\nexport type SetOrganizationInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** When this limit should expire. */\n  expiry?: Maybe<RepositoryInteractionLimitExpiry>\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit\n  /** The ID of the organization to set a limit for. */\n  organizationId: Scalars['ID']\n}\n\n/** Autogenerated return type of SetOrganizationInteractionLimit */\nexport type SetOrganizationInteractionLimitPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The organization that the interaction limit was set for. */\n  organization?: Maybe<Organization>\n}\n\n/** Autogenerated input type of SetRepositoryInteractionLimit */\nexport type SetRepositoryInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** When this limit should expire. */\n  expiry?: Maybe<RepositoryInteractionLimitExpiry>\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit\n  /** The ID of the repository to set a limit for. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of SetRepositoryInteractionLimit */\nexport type SetRepositoryInteractionLimitPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The repository that the interaction limit was set for. */\n  repository?: Maybe<Repository>\n}\n\n/** Autogenerated input type of SetUserInteractionLimit */\nexport type SetUserInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** When this limit should expire. */\n  expiry?: Maybe<RepositoryInteractionLimitExpiry>\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit\n  /** The ID of the user to set a limit for. */\n  userId: Scalars['ID']\n}\n\n/** Autogenerated return type of SetUserInteractionLimit */\nexport type SetUserInteractionLimitPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The user that the interaction limit was set for. */\n  user?: Maybe<User>\n}\n\n/** Represents an S/MIME signature on a Commit or Tag. */\nexport type SmimeSignature = GitSignature & {\n  /** Email used to sign this object. */\n  email: Scalars['String']\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean']\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String']\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String']\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean']\n}\n\n/** Entities that can sponsor others via GitHub Sponsors */\nexport type Sponsor = Organization | User\n\n/** The connection type for Sponsor. */\nexport type SponsorConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Sponsor>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Represents a user or organization who is sponsoring someone in GitHub Sponsors. */\nexport type SponsorEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Sponsor>\n}\n\n/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */\nexport type SponsorOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order sponsor entities by. */\n  field: SponsorOrderField\n}\n\n/** Properties by which sponsor connections can be ordered. */\nexport enum SponsorOrderField {\n  /** Order sponsorable entities by login (username). */\n  Login = 'LOGIN',\n  /** Order sponsors by their relevance to the viewer. */\n  Relevance = 'RELEVANCE',\n}\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type Sponsorable = {\n  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n  estimatedNextSponsorsPayoutInCents: Scalars['Int']\n  /** True if this user/organization has a GitHub Sponsors listing. */\n  hasSponsorsListing: Scalars['Boolean']\n  /** Check if the given account is sponsoring this user/organization. */\n  isSponsoredBy: Scalars['Boolean']\n  /** True if the viewer is sponsored by this user/organization. */\n  isSponsoringViewer: Scalars['Boolean']\n  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']\n  /** List of users and organizations this entity is sponsoring. */\n  sponsoring: SponsorConnection\n  /** List of sponsors for this user or organization. */\n  sponsors: SponsorConnection\n  /** Events involving this sponsorable, such as new sponsorships. */\n  sponsorsActivities: SponsorsActivityConnection\n  /** The GitHub Sponsors listing for this user or organization. */\n  sponsorsListing?: Maybe<SponsorsListing>\n  /**\n   * The sponsorship from the viewer to this user/organization; that is, the\n   * sponsorship where you're the sponsor. Only returns a sponsorship if it is active.\n   */\n  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>\n  /**\n   * The sponsorship from this user/organization to the viewer; that is, the\n   * sponsorship you're receiving. Only returns a sponsorship if it is active.\n   */\n  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>\n  /** List of sponsorship updates sent from this sponsorable to sponsors. */\n  sponsorshipNewsletters: SponsorshipNewsletterConnection\n  /** This object's sponsorships as the maintainer. */\n  sponsorshipsAsMaintainer: SponsorshipConnection\n  /** This object's sponsorships as the sponsor. */\n  sponsorshipsAsSponsor: SponsorshipConnection\n  /** Whether or not the viewer is able to sponsor this user/organization. */\n  viewerCanSponsor: Scalars['Boolean']\n  /** True if the viewer is sponsoring this user/organization. */\n  viewerIsSponsoring: Scalars['Boolean']\n}\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableIsSponsoredByArgs = {\n  accountLogin: Scalars['String']\n}\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsoringArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorOrder>\n}\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsorsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorOrder>\n  tierId?: Maybe<Scalars['ID']>\n}\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsorsActivitiesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorsActivityOrder>\n  period?: Maybe<SponsorsActivityPeriod>\n}\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsorshipNewslettersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorshipNewsletterOrder>\n}\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsorshipsAsMaintainerArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  includePrivate?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorshipOrder>\n}\n\n/** Entities that can be sponsored through GitHub Sponsors */\nexport type SponsorableSponsorshipsAsSponsorArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorshipOrder>\n}\n\n/** Entities that can be sponsored via GitHub Sponsors */\nexport type SponsorableItem = Organization | User\n\n/** The connection type for SponsorableItem. */\nexport type SponsorableItemConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorableItemEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorableItem>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type SponsorableItemEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorableItem>\n}\n\n/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */\nexport type SponsorableOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order sponsorable entities by. */\n  field: SponsorableOrderField\n}\n\n/** Properties by which sponsorable connections can be ordered. */\nexport enum SponsorableOrderField {\n  /** Order sponsorable entities by login (username). */\n  Login = 'LOGIN',\n}\n\n/** An event related to sponsorship activity. */\nexport type SponsorsActivity = Node & {\n  /** What action this activity indicates took place. */\n  action: SponsorsActivityAction\n  id: Scalars['ID']\n  /** The tier that the sponsorship used to use, for tier change events. */\n  previousSponsorsTier?: Maybe<SponsorsTier>\n  /** The user or organization who triggered this activity and was/is sponsoring the sponsorable. */\n  sponsor?: Maybe<Sponsor>\n  /** The user or organization that is being sponsored, the maintainer. */\n  sponsorable: Sponsorable\n  /** The associated sponsorship tier. */\n  sponsorsTier?: Maybe<SponsorsTier>\n  /** The timestamp of this event. */\n  timestamp?: Maybe<Scalars['DateTime']>\n}\n\n/** The possible actions that GitHub Sponsors activities can represent. */\nexport enum SponsorsActivityAction {\n  /** The activity was cancelling a sponsorship. */\n  CancelledSponsorship = 'CANCELLED_SPONSORSHIP',\n  /** The activity was starting a sponsorship. */\n  NewSponsorship = 'NEW_SPONSORSHIP',\n  /** The activity was scheduling a downgrade or cancellation. */\n  PendingChange = 'PENDING_CHANGE',\n  /** The activity was funds being refunded to the sponsor or GitHub. */\n  Refund = 'REFUND',\n  /** The activity was disabling matching for a previously matched sponsorship. */\n  SponsorMatchDisabled = 'SPONSOR_MATCH_DISABLED',\n  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */\n  TierChange = 'TIER_CHANGE',\n}\n\n/** The connection type for SponsorsActivity. */\nexport type SponsorsActivityConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorsActivityEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorsActivity>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type SponsorsActivityEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorsActivity>\n}\n\n/** Ordering options for GitHub Sponsors activity connections. */\nexport type SponsorsActivityOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order activity by. */\n  field: SponsorsActivityOrderField\n}\n\n/** Properties by which GitHub Sponsors activity connections can be ordered. */\nexport enum SponsorsActivityOrderField {\n  /** Order activities by when they happened. */\n  Timestamp = 'TIMESTAMP',\n}\n\n/** The possible time periods for which Sponsors activities can be requested. */\nexport enum SponsorsActivityPeriod {\n  /** Don't restrict the activity to any date range, include all activity. */\n  All = 'ALL',\n  /** The previous calendar day. */\n  Day = 'DAY',\n  /** The previous thirty days. */\n  Month = 'MONTH',\n  /** The previous seven days. */\n  Week = 'WEEK',\n}\n\n/** A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain. */\nexport type SponsorsGoal = {\n  /** A description of the goal from the maintainer. */\n  description?: Maybe<Scalars['String']>\n  /** What the objective of this goal is. */\n  kind: SponsorsGoalKind\n  /** The percentage representing how complete this goal is, between 0-100. */\n  percentComplete: Scalars['Int']\n  /**\n   * What the goal amount is. Represents an amount in USD for monthly sponsorship\n   * amount goals. Represents a count of unique sponsors for total sponsors count goals.\n   */\n  targetValue: Scalars['Int']\n  /** A brief summary of the kind and target value of this goal. */\n  title: Scalars['String']\n}\n\n/** The different kinds of goals a GitHub Sponsors member can have. */\nexport enum SponsorsGoalKind {\n  /** The goal is about getting a certain amount in USD from sponsorships each month. */\n  MonthlySponsorshipAmount = 'MONTHLY_SPONSORSHIP_AMOUNT',\n  /** The goal is about reaching a certain number of sponsors. */\n  TotalSponsorsCount = 'TOTAL_SPONSORS_COUNT',\n}\n\n/** A GitHub Sponsors listing. */\nexport type SponsorsListing = Node & {\n  /** The current goal the maintainer is trying to reach with GitHub Sponsors, if any. */\n  activeGoal?: Maybe<SponsorsGoal>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The full description of the listing. */\n  fullDescription: Scalars['String']\n  /** The full description of the listing rendered to HTML. */\n  fullDescriptionHTML: Scalars['HTML']\n  id: Scalars['ID']\n  /** Whether this listing is publicly visible. */\n  isPublic: Scalars['Boolean']\n  /** The listing's full name. */\n  name: Scalars['String']\n  /** A future date on which this listing is eligible to receive a payout. */\n  nextPayoutDate?: Maybe<Scalars['Date']>\n  /** The short description of the listing. */\n  shortDescription: Scalars['String']\n  /** The short name of the listing. */\n  slug: Scalars['String']\n  /** The entity this listing represents who can be sponsored on GitHub Sponsors. */\n  sponsorable: Sponsorable\n  /** The published tiers for this GitHub Sponsors listing. */\n  tiers?: Maybe<SponsorsTierConnection>\n}\n\n/** A GitHub Sponsors listing. */\nexport type SponsorsListingTiersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorsTierOrder>\n}\n\n/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */\nexport type SponsorsTier = Node & {\n  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\n  adminInfo?: Maybe<SponsorsTierAdminInfo>\n  /**\n   * Get a different tier for this tier's maintainer that is at the same frequency\n   * as this tier but with an equal or lesser cost. Returns the published tier with\n   * the monthly price closest to this tier's without going over.\n   */\n  closestLesserValueTier?: Maybe<SponsorsTier>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The description of the tier. */\n  description: Scalars['String']\n  /** The tier description rendered to HTML */\n  descriptionHTML: Scalars['HTML']\n  id: Scalars['ID']\n  /**\n   * Whether this tier was chosen at checkout time by the sponsor rather than\n   * defined ahead of time by the maintainer who manages the Sponsors listing.\n   */\n  isCustomAmount: Scalars['Boolean']\n  /** Whether this tier is only for use with one-time sponsorships. */\n  isOneTime: Scalars['Boolean']\n  /** How much this tier costs per month in cents. */\n  monthlyPriceInCents: Scalars['Int']\n  /** How much this tier costs per month in USD. */\n  monthlyPriceInDollars: Scalars['Int']\n  /** The name of the tier. */\n  name: Scalars['String']\n  /** The sponsors listing that this tier belongs to. */\n  sponsorsListing: SponsorsListing\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\nexport type SponsorsTierAdminInfo = {\n  /** The sponsorships associated with this tier. */\n  sponsorships: SponsorshipConnection\n}\n\n/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\nexport type SponsorsTierAdminInfoSponsorshipsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  includePrivate?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorshipOrder>\n}\n\n/** The connection type for SponsorsTier. */\nexport type SponsorsTierConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorsTierEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorsTier>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type SponsorsTierEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorsTier>\n}\n\n/** Ordering options for Sponsors tiers connections. */\nexport type SponsorsTierOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order tiers by. */\n  field: SponsorsTierOrderField\n}\n\n/** Properties by which Sponsors tiers connections can be ordered. */\nexport enum SponsorsTierOrderField {\n  /** Order tiers by creation time. */\n  CreatedAt = 'CREATED_AT',\n  /** Order tiers by their monthly price in cents */\n  MonthlyPriceInCents = 'MONTHLY_PRICE_IN_CENTS',\n}\n\n/** A sponsorship relationship between a sponsor and a maintainer */\nexport type Sponsorship = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Whether this sponsorship represents a one-time payment versus a recurring sponsorship. */\n  isOneTimePayment: Scalars['Boolean']\n  /**\n   * Check if the sponsor has chosen to receive sponsorship update emails sent from\n   * the sponsorable. Only returns a non-null value when the viewer has permission to know this.\n   */\n  isSponsorOptedIntoEmail?: Maybe<Scalars['Boolean']>\n  /**\n   * The entity that is being sponsored\n   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.\n   */\n  maintainer: User\n  /** The privacy level for this sponsorship. */\n  privacyLevel: SponsorshipPrivacy\n  /**\n   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.\n   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.\n   */\n  sponsor?: Maybe<User>\n  /** The user or organization that is sponsoring, if you have permission to view them. */\n  sponsorEntity?: Maybe<Sponsor>\n  /** The entity that is being sponsored */\n  sponsorable: Sponsorable\n  /** The associated sponsorship tier */\n  tier?: Maybe<SponsorsTier>\n  /** Identifies the date and time when the current tier was chosen for this sponsorship. */\n  tierSelectedAt?: Maybe<Scalars['DateTime']>\n}\n\n/** The connection type for Sponsorship. */\nexport type SponsorshipConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorshipEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Sponsorship>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n  /**\n   * The total amount in cents of all recurring sponsorships in the connection\n   * whose amount you can view. Does not include one-time sponsorships.\n   */\n  totalRecurringMonthlyPriceInCents: Scalars['Int']\n  /**\n   * The total amount in USD of all recurring sponsorships in the connection whose\n   * amount you can view. Does not include one-time sponsorships.\n   */\n  totalRecurringMonthlyPriceInDollars: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type SponsorshipEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Sponsorship>\n}\n\n/** An update sent to sponsors of a user or organization on GitHub Sponsors. */\nexport type SponsorshipNewsletter = Node & {\n  /** The contents of the newsletter, the message the sponsorable wanted to give. */\n  body: Scalars['String']\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Indicates if the newsletter has been made available to sponsors. */\n  isPublished: Scalars['Boolean']\n  /** The user or organization this newsletter is from. */\n  sponsorable: Sponsorable\n  /** The subject of the newsletter, what it's about. */\n  subject: Scalars['String']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** The connection type for SponsorshipNewsletter. */\nexport type SponsorshipNewsletterConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorshipNewsletterEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorshipNewsletter>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type SponsorshipNewsletterEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorshipNewsletter>\n}\n\n/** Ordering options for sponsorship newsletter connections. */\nexport type SponsorshipNewsletterOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order sponsorship newsletters by. */\n  field: SponsorshipNewsletterOrderField\n}\n\n/** Properties by which sponsorship update connections can be ordered. */\nexport enum SponsorshipNewsletterOrderField {\n  /** Order sponsorship newsletters by when they were created. */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** Ordering options for sponsorship connections. */\nexport type SponsorshipOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order sponsorship by. */\n  field: SponsorshipOrderField\n}\n\n/** Properties by which sponsorship connections can be ordered. */\nexport enum SponsorshipOrderField {\n  /** Order sponsorship by creation time. */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** The privacy of a sponsorship */\nexport enum SponsorshipPrivacy {\n  /** Private */\n  Private = 'PRIVATE',\n  /** Public */\n  Public = 'PUBLIC',\n}\n\n/** Ways in which star connections can be ordered. */\nexport type StarOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection\n  /** The field in which to order nodes by. */\n  field: StarOrderField\n}\n\n/** Properties by which star connections can be ordered. */\nexport enum StarOrderField {\n  /** Allows ordering a list of stars by when they were created. */\n  StarredAt = 'STARRED_AT',\n}\n\n/** The connection type for User. */\nexport type StargazerConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StargazerEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Represents a user that's starred a repository. */\nexport type StargazerEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  node: User\n  /** Identifies when the item was starred. */\n  starredAt: Scalars['DateTime']\n}\n\n/** Things that can be starred. */\nexport type Starrable = {\n  id: Scalars['ID']\n  /** Returns a count of how many stargazers there are on this object */\n  stargazerCount: Scalars['Int']\n  /** A list of users who have starred this starrable. */\n  stargazers: StargazerConnection\n  /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n  viewerHasStarred: Scalars['Boolean']\n}\n\n/** Things that can be starred. */\nexport type StarrableStargazersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<StarOrder>\n}\n\n/** The connection type for Repository. */\nexport type StarredRepositoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StarredRepositoryEdge>>>\n  /** Is the list of stars for this user truncated? This is true for users that have many stars. */\n  isOverLimit: Scalars['Boolean']\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Represents a starred repository. */\nexport type StarredRepositoryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  node: Repository\n  /** Identifies when the item was starred. */\n  starredAt: Scalars['DateTime']\n}\n\n/** Represents a commit status. */\nexport type Status = Node & {\n  /** A list of status contexts and check runs for this commit. */\n  combinedContexts: StatusCheckRollupContextConnection\n  /** The commit this status is attached to. */\n  commit?: Maybe<Commit>\n  /** Looks up an individual status context by context name. */\n  context?: Maybe<StatusContext>\n  /** The individual status contexts for this commit. */\n  contexts: Array<StatusContext>\n  id: Scalars['ID']\n  /** The combined commit status. */\n  state: StatusState\n}\n\n/** Represents a commit status. */\nexport type StatusCombinedContextsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Represents a commit status. */\nexport type StatusContextArgs = {\n  name: Scalars['String']\n}\n\n/** Represents the rollup for both the check runs and status for a commit. */\nexport type StatusCheckRollup = Node & {\n  /** The commit the status and check runs are attached to. */\n  commit?: Maybe<Commit>\n  /** A list of status contexts and check runs for this commit. */\n  contexts: StatusCheckRollupContextConnection\n  id: Scalars['ID']\n  /** The combined status for the commit. */\n  state: StatusState\n}\n\n/** Represents the rollup for both the check runs and status for a commit. */\nexport type StatusCheckRollupContextsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** Types that can be inside a StatusCheckRollup context. */\nexport type StatusCheckRollupContext = CheckRun | StatusContext\n\n/** The connection type for StatusCheckRollupContext. */\nexport type StatusCheckRollupContextConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StatusCheckRollupContextEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<StatusCheckRollupContext>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type StatusCheckRollupContextEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<StatusCheckRollupContext>\n}\n\n/** Represents an individual commit status context */\nexport type StatusContext = Node &\n  RequirableByPullRequest & {\n    /** The avatar of the OAuth application or the user that created the status */\n    avatarUrl?: Maybe<Scalars['URI']>\n    /** This commit this status context is attached to. */\n    commit?: Maybe<Commit>\n    /** The name of this status context. */\n    context: Scalars['String']\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** The actor who created this status context. */\n    creator?: Maybe<Actor>\n    /** The description for this status context. */\n    description?: Maybe<Scalars['String']>\n    id: Scalars['ID']\n    /** Whether this is required to pass before merging for a specific pull request. */\n    isRequired: Scalars['Boolean']\n    /** The state of this status context. */\n    state: StatusState\n    /** The URL for this status context. */\n    targetUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Represents an individual commit status context */\nexport type StatusContextAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** Represents an individual commit status context */\nexport type StatusContextIsRequiredArgs = {\n  pullRequestId?: Maybe<Scalars['ID']>\n  pullRequestNumber?: Maybe<Scalars['Int']>\n}\n\n/** The possible commit status states. */\nexport enum StatusState {\n  /** Status is errored. */\n  Error = 'ERROR',\n  /** Status is expected. */\n  Expected = 'EXPECTED',\n  /** Status is failing. */\n  Failure = 'FAILURE',\n  /** Status is pending. */\n  Pending = 'PENDING',\n  /** Status is successful. */\n  Success = 'SUCCESS',\n}\n\n/** Autogenerated input type of SubmitPullRequestReview */\nexport type SubmitPullRequestReviewInput = {\n  /** The text field to set on the Pull Request Review. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The event to send to the Pull Request Review. */\n  event: PullRequestReviewEvent\n  /** The Pull Request ID to submit any pending reviews. */\n  pullRequestId?: Maybe<Scalars['ID']>\n  /** The Pull Request Review ID to submit. */\n  pullRequestReviewId?: Maybe<Scalars['ID']>\n}\n\n/** Autogenerated return type of SubmitPullRequestReview */\nexport type SubmitPullRequestReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The submitted pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>\n}\n\n/** A pointer to a repository at a specific revision embedded inside another repository. */\nexport type Submodule = {\n  /** The branch of the upstream submodule for tracking updates */\n  branch?: Maybe<Scalars['String']>\n  /** The git URL of the submodule repository */\n  gitUrl: Scalars['URI']\n  /** The name of the submodule in .gitmodules */\n  name: Scalars['String']\n  /** The path in the superproject that this submodule is located in */\n  path: Scalars['String']\n  /** The commit revision of the subproject repository being tracked by the submodule */\n  subprojectCommitOid?: Maybe<Scalars['GitObjectID']>\n}\n\n/** The connection type for Submodule. */\nexport type SubmoduleConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SubmoduleEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Submodule>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type SubmoduleEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Submodule>\n}\n\n/** Entities that can be subscribed to for web and email notifications. */\nexport type Subscribable = {\n  id: Scalars['ID']\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean']\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>\n}\n\n/** Represents a 'subscribed' event on a given `Subscribable`. */\nexport type SubscribedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Object referenced by event. */\n  subscribable: Subscribable\n}\n\n/** The possible states of a subscription. */\nexport enum SubscriptionState {\n  /** The User is never notified. */\n  Ignored = 'IGNORED',\n  /** The User is notified of all conversations. */\n  Subscribed = 'SUBSCRIBED',\n  /** The User is only notified when participating or @mentioned. */\n  Unsubscribed = 'UNSUBSCRIBED',\n}\n\n/** A suggestion to review a pull request based on a user's commit history and review comments. */\nexport type SuggestedReviewer = {\n  /** Is this suggestion based on past commits? */\n  isAuthor: Scalars['Boolean']\n  /** Is this suggestion based on past review comments? */\n  isCommenter: Scalars['Boolean']\n  /** Identifies the user suggested to review the pull request. */\n  reviewer: User\n}\n\n/** Represents a Git tag. */\nexport type Tag = GitObject &\n  Node & {\n    /** An abbreviated version of the Git object ID */\n    abbreviatedOid: Scalars['String']\n    /** The HTTP path for this Git object */\n    commitResourcePath: Scalars['URI']\n    /** The HTTP URL for this Git object */\n    commitUrl: Scalars['URI']\n    id: Scalars['ID']\n    /** The Git tag message. */\n    message?: Maybe<Scalars['String']>\n    /** The Git tag name. */\n    name: Scalars['String']\n    /** The Git object ID */\n    oid: Scalars['GitObjectID']\n    /** The Repository the Git object belongs to */\n    repository: Repository\n    /** Details about the tag author. */\n    tagger?: Maybe<GitActor>\n    /** The Git object the tag points to. */\n    target: GitObject\n  }\n\n/** A team of users in an organization. */\nexport type Team = MemberStatusable &\n  Node &\n  Subscribable & {\n    /** A list of teams that are ancestors of this team. */\n    ancestors: TeamConnection\n    /** A URL pointing to the team's avatar. */\n    avatarUrl?: Maybe<Scalars['URI']>\n    /** List of child teams belonging to this team */\n    childTeams: TeamConnection\n    /** The slug corresponding to the organization and team. */\n    combinedSlug: Scalars['String']\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The description of the team. */\n    description?: Maybe<Scalars['String']>\n    /** Find a team discussion by its number. */\n    discussion?: Maybe<TeamDiscussion>\n    /** A list of team discussions. */\n    discussions: TeamDiscussionConnection\n    /** The HTTP path for team discussions */\n    discussionsResourcePath: Scalars['URI']\n    /** The HTTP URL for team discussions */\n    discussionsUrl: Scalars['URI']\n    /** The HTTP path for editing this team */\n    editTeamResourcePath: Scalars['URI']\n    /** The HTTP URL for editing this team */\n    editTeamUrl: Scalars['URI']\n    id: Scalars['ID']\n    /** A list of pending invitations for users to this team */\n    invitations?: Maybe<OrganizationInvitationConnection>\n    /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n    memberStatuses: UserStatusConnection\n    /** A list of users who are members of this team. */\n    members: TeamMemberConnection\n    /** The HTTP path for the team' members */\n    membersResourcePath: Scalars['URI']\n    /** The HTTP URL for the team' members */\n    membersUrl: Scalars['URI']\n    /** The name of the team. */\n    name: Scalars['String']\n    /** The HTTP path creating a new team */\n    newTeamResourcePath: Scalars['URI']\n    /** The HTTP URL creating a new team */\n    newTeamUrl: Scalars['URI']\n    /** The organization that owns this team. */\n    organization: Organization\n    /** The parent team of the team. */\n    parentTeam?: Maybe<Team>\n    /** The level of privacy the team has. */\n    privacy: TeamPrivacy\n    /** A list of repositories this team has access to. */\n    repositories: TeamRepositoryConnection\n    /** The HTTP path for this team's repositories */\n    repositoriesResourcePath: Scalars['URI']\n    /** The HTTP URL for this team's repositories */\n    repositoriesUrl: Scalars['URI']\n    /** The HTTP path for this team */\n    resourcePath: Scalars['URI']\n    /** What algorithm is used for review assignment for this team */\n    reviewRequestDelegationAlgorithm?: Maybe<TeamReviewAssignmentAlgorithm>\n    /** True if review assignment is enabled for this team */\n    reviewRequestDelegationEnabled: Scalars['Boolean']\n    /** How many team members are required for review assignment for this team */\n    reviewRequestDelegationMemberCount?: Maybe<Scalars['Int']>\n    /** When assigning team members via delegation, whether the entire team should be notified as well. */\n    reviewRequestDelegationNotifyTeam: Scalars['Boolean']\n    /** The slug corresponding to the team. */\n    slug: Scalars['String']\n    /** The HTTP path for this team's teams */\n    teamsResourcePath: Scalars['URI']\n    /** The HTTP URL for this team's teams */\n    teamsUrl: Scalars['URI']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this team */\n    url: Scalars['URI']\n    /** Team is adminable by the viewer. */\n    viewerCanAdminister: Scalars['Boolean']\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars['Boolean']\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>\n  }\n\n/** A team of users in an organization. */\nexport type TeamAncestorsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A team of users in an organization. */\nexport type TeamAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** A team of users in an organization. */\nexport type TeamChildTeamsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  immediateOnly?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<TeamOrder>\n  userLogins?: Maybe<Array<Scalars['String']>>\n}\n\n/** A team of users in an organization. */\nexport type TeamDiscussionArgs = {\n  number: Scalars['Int']\n}\n\n/** A team of users in an organization. */\nexport type TeamDiscussionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  isPinned?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<TeamDiscussionOrder>\n}\n\n/** A team of users in an organization. */\nexport type TeamInvitationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A team of users in an organization. */\nexport type TeamMemberStatusesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<UserStatusOrder>\n}\n\n/** A team of users in an organization. */\nexport type TeamMembersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  membership?: Maybe<TeamMembershipType>\n  orderBy?: Maybe<TeamMemberOrder>\n  query?: Maybe<Scalars['String']>\n  role?: Maybe<TeamMemberRole>\n}\n\n/** A team of users in an organization. */\nexport type TeamRepositoriesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<TeamRepositoryOrder>\n  query?: Maybe<Scalars['String']>\n}\n\n/** Audit log entry for a team.add_member event. */\nexport type TeamAddMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  TeamAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** Whether the team was mapped to an LDAP Group. */\n    isLdapMapped?: Maybe<Scalars['Boolean']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The team associated with the action */\n    team?: Maybe<Team>\n    /** The name of the team */\n    teamName?: Maybe<Scalars['String']>\n    /** The HTTP path for this team */\n    teamResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for this team */\n    teamUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a team.add_repository event. */\nexport type TeamAddRepositoryAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData &\n  TeamAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** Whether the team was mapped to an LDAP Group. */\n    isLdapMapped?: Maybe<Scalars['Boolean']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The team associated with the action */\n    team?: Maybe<Team>\n    /** The name of the team */\n    teamName?: Maybe<Scalars['String']>\n    /** The HTTP path for this team */\n    teamResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for this team */\n    teamUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Metadata for an audit entry with action team.* */\nexport type TeamAuditEntryData = {\n  /** The team associated with the action */\n  team?: Maybe<Team>\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']>\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']>\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']>\n}\n\n/** Audit log entry for a team.change_parent_team event. */\nexport type TeamChangeParentTeamAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  TeamAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** Whether the team was mapped to an LDAP Group. */\n    isLdapMapped?: Maybe<Scalars['Boolean']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The new parent team. */\n    parentTeam?: Maybe<Team>\n    /** The name of the new parent team */\n    parentTeamName?: Maybe<Scalars['String']>\n    /** The name of the former parent team */\n    parentTeamNameWas?: Maybe<Scalars['String']>\n    /** The HTTP path for the parent team */\n    parentTeamResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the parent team */\n    parentTeamUrl?: Maybe<Scalars['URI']>\n    /** The former parent team. */\n    parentTeamWas?: Maybe<Team>\n    /** The HTTP path for the previous parent team */\n    parentTeamWasResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the previous parent team */\n    parentTeamWasUrl?: Maybe<Scalars['URI']>\n    /** The team associated with the action */\n    team?: Maybe<Team>\n    /** The name of the team */\n    teamName?: Maybe<Scalars['String']>\n    /** The HTTP path for this team */\n    teamResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for this team */\n    teamUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The connection type for Team. */\nexport type TeamConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Team>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** A team discussion. */\nexport type TeamDiscussion = Comment &\n  Deletable &\n  Node &\n  Reactable &\n  Subscribable &\n  UniformResourceLocatable &\n  Updatable &\n  UpdatableComment & {\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the discussion's team. */\n    authorAssociation: CommentAuthorAssociation\n    /** The body as Markdown. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The body rendered to text. */\n    bodyText: Scalars['String']\n    /** Identifies the discussion body hash. */\n    bodyVersion: Scalars['String']\n    /** A list of comments on this discussion. */\n    comments: TeamDiscussionCommentConnection\n    /** The HTTP path for discussion comments */\n    commentsResourcePath: Scalars['URI']\n    /** The HTTP URL for discussion comments */\n    commentsUrl: Scalars['URI']\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** Whether or not the discussion is pinned. */\n    isPinned: Scalars['Boolean']\n    /** Whether or not the discussion is only visible to team members and org admins. */\n    isPrivate: Scalars['Boolean']\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** Identifies the discussion within its team. */\n    number: Scalars['Int']\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** The HTTP path for this discussion */\n    resourcePath: Scalars['URI']\n    /** The team that defines the context of this discussion. */\n    team: Team\n    /** The title of the discussion */\n    title: Scalars['String']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this discussion */\n    url: Scalars['URI']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars['Boolean']\n    /** Whether or not the current viewer can pin this discussion. */\n    viewerCanPin: Scalars['Boolean']\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n    /** Check if the viewer is able to change their subscription status for the repository. */\n    viewerCanSubscribe: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n    viewerSubscription?: Maybe<SubscriptionState>\n  }\n\n/** A team discussion. */\nexport type TeamDiscussionCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  fromComment?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<TeamDiscussionCommentOrder>\n}\n\n/** A team discussion. */\nexport type TeamDiscussionReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** A team discussion. */\nexport type TeamDiscussionUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionComment = Comment &\n  Deletable &\n  Node &\n  Reactable &\n  UniformResourceLocatable &\n  Updatable &\n  UpdatableComment & {\n    /** The actor who authored the comment. */\n    author?: Maybe<Actor>\n    /** Author's association with the comment's team. */\n    authorAssociation: CommentAuthorAssociation\n    /** The body as Markdown. */\n    body: Scalars['String']\n    /** The body rendered to HTML. */\n    bodyHTML: Scalars['HTML']\n    /** The body rendered to text. */\n    bodyText: Scalars['String']\n    /** The current version of the body content. */\n    bodyVersion: Scalars['String']\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Check if this comment was created via an email reply. */\n    createdViaEmail: Scalars['Boolean']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The discussion this comment is about. */\n    discussion: TeamDiscussion\n    /** The actor who edited the comment. */\n    editor?: Maybe<Actor>\n    id: Scalars['ID']\n    /** Check if this comment was edited and includes an edit with the creation data */\n    includesCreatedEdit: Scalars['Boolean']\n    /** The moment the editor made the last edit */\n    lastEditedAt?: Maybe<Scalars['DateTime']>\n    /** Identifies the comment number. */\n    number: Scalars['Int']\n    /** Identifies when the comment was published at. */\n    publishedAt?: Maybe<Scalars['DateTime']>\n    /** A list of reactions grouped by content left on the subject. */\n    reactionGroups?: Maybe<Array<ReactionGroup>>\n    /** A list of Reactions left on the Issue. */\n    reactions: ReactionConnection\n    /** The HTTP path for this comment */\n    resourcePath: Scalars['URI']\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this comment */\n    url: Scalars['URI']\n    /** A list of edits to this content. */\n    userContentEdits?: Maybe<UserContentEditConnection>\n    /** Check if the current viewer can delete this object. */\n    viewerCanDelete: Scalars['Boolean']\n    /** Can user react to this subject */\n    viewerCanReact: Scalars['Boolean']\n    /** Check if the current viewer can update this object. */\n    viewerCanUpdate: Scalars['Boolean']\n    /** Reasons why the current viewer can not update this comment. */\n    viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n    /** Did the viewer author this comment. */\n    viewerDidAuthor: Scalars['Boolean']\n  }\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionCommentReactionsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  content?: Maybe<ReactionContent>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ReactionOrder>\n}\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionCommentUserContentEditsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** The connection type for TeamDiscussionComment. */\nexport type TeamDiscussionCommentConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamDiscussionCommentEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<TeamDiscussionComment>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type TeamDiscussionCommentEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<TeamDiscussionComment>\n}\n\n/** Ways in which team discussion comment connections can be ordered. */\nexport type TeamDiscussionCommentOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection\n  /** The field by which to order nodes. */\n  field: TeamDiscussionCommentOrderField\n}\n\n/** Properties by which team discussion comment connections can be ordered. */\nexport enum TeamDiscussionCommentOrderField {\n  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */\n  Number = 'NUMBER',\n}\n\n/** The connection type for TeamDiscussion. */\nexport type TeamDiscussionConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamDiscussionEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<TeamDiscussion>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type TeamDiscussionEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<TeamDiscussion>\n}\n\n/** Ways in which team discussion connections can be ordered. */\nexport type TeamDiscussionOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection\n  /** The field by which to order nodes. */\n  field: TeamDiscussionOrderField\n}\n\n/** Properties by which team discussion connections can be ordered. */\nexport enum TeamDiscussionOrderField {\n  /** Allows chronological ordering of team discussions. */\n  CreatedAt = 'CREATED_AT',\n}\n\n/** An edge in a connection. */\nexport type TeamEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<Team>\n}\n\n/** The connection type for User. */\nexport type TeamMemberConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamMemberEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Represents a user who is a member of a team. */\nexport type TeamMemberEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The HTTP path to the organization's member access page. */\n  memberAccessResourcePath: Scalars['URI']\n  /** The HTTP URL to the organization's member access page. */\n  memberAccessUrl: Scalars['URI']\n  node: User\n  /** The role the member has on the team. */\n  role: TeamMemberRole\n}\n\n/** Ordering options for team member connections */\nexport type TeamMemberOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order team members by. */\n  field: TeamMemberOrderField\n}\n\n/** Properties by which team member connections can be ordered. */\nexport enum TeamMemberOrderField {\n  /** Order team members by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order team members by login */\n  Login = 'LOGIN',\n}\n\n/** The possible team member roles; either 'maintainer' or 'member'. */\nexport enum TeamMemberRole {\n  /** A team maintainer has permission to add and remove team members. */\n  Maintainer = 'MAINTAINER',\n  /** A team member has no administrative permissions on the team. */\n  Member = 'MEMBER',\n}\n\n/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */\nexport enum TeamMembershipType {\n  /** Includes immediate and child team members for the team. */\n  All = 'ALL',\n  /** Includes only child team members for the team. */\n  ChildTeam = 'CHILD_TEAM',\n  /** Includes only immediate members of the team. */\n  Immediate = 'IMMEDIATE',\n}\n\n/** Ways in which team connections can be ordered. */\nexport type TeamOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection\n  /** The field in which to order nodes by. */\n  field: TeamOrderField\n}\n\n/** Properties by which team connections can be ordered. */\nexport enum TeamOrderField {\n  /** Allows ordering a list of teams by name. */\n  Name = 'NAME',\n}\n\n/** The possible team privacy values. */\nexport enum TeamPrivacy {\n  /** A secret team can only be seen by its members. */\n  Secret = 'SECRET',\n  /** A visible team can be seen and @mentioned by every member of the organization. */\n  Visible = 'VISIBLE',\n}\n\n/** Audit log entry for a team.remove_member event. */\nexport type TeamRemoveMemberAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  TeamAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** Whether the team was mapped to an LDAP Group. */\n    isLdapMapped?: Maybe<Scalars['Boolean']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The team associated with the action */\n    team?: Maybe<Team>\n    /** The name of the team */\n    teamName?: Maybe<Scalars['String']>\n    /** The HTTP path for this team */\n    teamResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for this team */\n    teamUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** Audit log entry for a team.remove_repository event. */\nexport type TeamRemoveRepositoryAuditEntry = AuditEntry &\n  Node &\n  OrganizationAuditEntryData &\n  RepositoryAuditEntryData &\n  TeamAuditEntryData & {\n    /** The action name */\n    action: Scalars['String']\n    /** The user who initiated the action */\n    actor?: Maybe<AuditEntryActor>\n    /** The IP address of the actor */\n    actorIp?: Maybe<Scalars['String']>\n    /** A readable representation of the actor's location */\n    actorLocation?: Maybe<ActorLocation>\n    /** The username of the user who initiated the action */\n    actorLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the actor. */\n    actorResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the actor. */\n    actorUrl?: Maybe<Scalars['URI']>\n    /** The time the action was initiated */\n    createdAt: Scalars['PreciseDateTime']\n    id: Scalars['ID']\n    /** Whether the team was mapped to an LDAP Group. */\n    isLdapMapped?: Maybe<Scalars['Boolean']>\n    /** The corresponding operation type for the action */\n    operationType?: Maybe<OperationType>\n    /** The Organization associated with the Audit Entry. */\n    organization?: Maybe<Organization>\n    /** The name of the Organization. */\n    organizationName?: Maybe<Scalars['String']>\n    /** The HTTP path for the organization */\n    organizationResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the organization */\n    organizationUrl?: Maybe<Scalars['URI']>\n    /** The repository associated with the action */\n    repository?: Maybe<Repository>\n    /** The name of the repository */\n    repositoryName?: Maybe<Scalars['String']>\n    /** The HTTP path for the repository */\n    repositoryResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the repository */\n    repositoryUrl?: Maybe<Scalars['URI']>\n    /** The team associated with the action */\n    team?: Maybe<Team>\n    /** The name of the team */\n    teamName?: Maybe<Scalars['String']>\n    /** The HTTP path for this team */\n    teamResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for this team */\n    teamUrl?: Maybe<Scalars['URI']>\n    /** The user affected by the action */\n    user?: Maybe<User>\n    /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n    userLogin?: Maybe<Scalars['String']>\n    /** The HTTP path for the user. */\n    userResourcePath?: Maybe<Scalars['URI']>\n    /** The HTTP URL for the user. */\n    userUrl?: Maybe<Scalars['URI']>\n  }\n\n/** The connection type for Repository. */\nexport type TeamRepositoryConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamRepositoryEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** Represents a team repository. */\nexport type TeamRepositoryEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  node: Repository\n  /** The permission level the team has on the repository */\n  permission: RepositoryPermission\n}\n\n/** Ordering options for team repository connections */\nexport type TeamRepositoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order repositories by. */\n  field: TeamRepositoryOrderField\n}\n\n/** Properties by which team repository connections can be ordered. */\nexport enum TeamRepositoryOrderField {\n  /** Order repositories by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order repositories by name */\n  Name = 'NAME',\n  /** Order repositories by permission */\n  Permission = 'PERMISSION',\n  /** Order repositories by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order repositories by number of stargazers */\n  Stargazers = 'STARGAZERS',\n  /** Order repositories by update time */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** The possible team review assignment algorithms */\nexport enum TeamReviewAssignmentAlgorithm {\n  /** Balance review load across the entire team */\n  LoadBalance = 'LOAD_BALANCE',\n  /** Alternate reviews between each team member */\n  RoundRobin = 'ROUND_ROBIN',\n}\n\n/** The role of a user on a team. */\nexport enum TeamRole {\n  /** User has admin rights on the team. */\n  Admin = 'ADMIN',\n  /** User is a member of the team. */\n  Member = 'MEMBER',\n}\n\n/** A text match within a search result. */\nexport type TextMatch = {\n  /** The specific text fragment within the property matched on. */\n  fragment: Scalars['String']\n  /** Highlights within the matched fragment. */\n  highlights: Array<TextMatchHighlight>\n  /** The property matched on. */\n  property: Scalars['String']\n}\n\n/** Represents a single highlight in a search result match. */\nexport type TextMatchHighlight = {\n  /** The indice in the fragment where the matched text begins. */\n  beginIndice: Scalars['Int']\n  /** The indice in the fragment where the matched text ends. */\n  endIndice: Scalars['Int']\n  /** The text matched. */\n  text: Scalars['String']\n}\n\n/** A topic aggregates entities that are related to a subject. */\nexport type Topic = Node &\n  Starrable & {\n    id: Scalars['ID']\n    /** The topic's name. */\n    name: Scalars['String']\n    /**\n     * A list of related topics, including aliases of this topic, sorted with the most relevant\n     * first. Returns up to 10 Topics.\n     */\n    relatedTopics: Array<Topic>\n    /** A list of repositories. */\n    repositories: RepositoryConnection\n    /** Returns a count of how many stargazers there are on this object */\n    stargazerCount: Scalars['Int']\n    /** A list of users who have starred this starrable. */\n    stargazers: StargazerConnection\n    /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n    viewerHasStarred: Scalars['Boolean']\n  }\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicRelatedTopicsArgs = {\n  first?: Maybe<Scalars['Int']>\n}\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicRepositoriesArgs = {\n  affiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  isLocked?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryOrder>\n  ownerAffiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  privacy?: Maybe<RepositoryPrivacy>\n  sponsorableOnly?: Maybe<Scalars['Boolean']>\n}\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicStargazersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<StarOrder>\n}\n\n/** Metadata for an audit entry with a topic. */\nexport type TopicAuditEntryData = {\n  /** The name of the topic added to the repository */\n  topic?: Maybe<Topic>\n  /** The name of the topic added to the repository */\n  topicName?: Maybe<Scalars['String']>\n}\n\n/** Reason that the suggested topic is declined. */\nexport enum TopicSuggestionDeclineReason {\n  /** The suggested topic is not relevant to the repository. */\n  NotRelevant = 'NOT_RELEVANT',\n  /** The viewer does not like the suggested topic. */\n  PersonalPreference = 'PERSONAL_PREFERENCE',\n  /** The suggested topic is too general for the repository. */\n  TooGeneral = 'TOO_GENERAL',\n  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */\n  TooSpecific = 'TOO_SPECIFIC',\n}\n\n/** Autogenerated input type of TransferIssue */\nexport type TransferIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the issue to be transferred */\n  issueId: Scalars['ID']\n  /** The Node ID of the repository the issue should be transferred to */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of TransferIssue */\nexport type TransferIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The issue that was transferred */\n  issue?: Maybe<Issue>\n}\n\n/** Represents a 'transferred' event on a given issue or pull request. */\nexport type TransferredEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The repository this came from */\n  fromRepository?: Maybe<Repository>\n  id: Scalars['ID']\n  /** Identifies the issue associated with the event. */\n  issue: Issue\n}\n\n/** Represents a Git tree. */\nexport type Tree = GitObject &\n  Node & {\n    /** An abbreviated version of the Git object ID */\n    abbreviatedOid: Scalars['String']\n    /** The HTTP path for this Git object */\n    commitResourcePath: Scalars['URI']\n    /** The HTTP URL for this Git object */\n    commitUrl: Scalars['URI']\n    /** A list of tree entries. */\n    entries?: Maybe<Array<TreeEntry>>\n    id: Scalars['ID']\n    /** The Git object ID */\n    oid: Scalars['GitObjectID']\n    /** The Repository the Git object belongs to */\n    repository: Repository\n  }\n\n/** Represents a Git tree entry. */\nexport type TreeEntry = {\n  /** The extension of the file */\n  extension?: Maybe<Scalars['String']>\n  /** Whether or not this tree entry is generated */\n  isGenerated: Scalars['Boolean']\n  /** Entry file mode. */\n  mode: Scalars['Int']\n  /** Entry file name. */\n  name: Scalars['String']\n  /** Entry file object. */\n  object?: Maybe<GitObject>\n  /** Entry file Git object ID. */\n  oid: Scalars['GitObjectID']\n  /** The full path of the file. */\n  path?: Maybe<Scalars['String']>\n  /** The Repository the tree entry belongs to */\n  repository: Repository\n  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */\n  submodule?: Maybe<Submodule>\n  /** Entry file type. */\n  type: Scalars['String']\n}\n\n/** Autogenerated input type of UnarchiveRepository */\nexport type UnarchiveRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the repository to unarchive. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of UnarchiveRepository */\nexport type UnarchiveRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The repository that was unarchived. */\n  repository?: Maybe<Repository>\n}\n\n/** Represents an 'unassigned' event on any assignable object. */\nexport type UnassignedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the assignable associated with the event. */\n  assignable: Assignable\n  /** Identifies the user or mannequin that was unassigned. */\n  assignee?: Maybe<Assignee>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /**\n   * Identifies the subject (user) who was unassigned.\n   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.\n   */\n  user?: Maybe<User>\n}\n\n/** Autogenerated input type of UnfollowUser */\nexport type UnfollowUserInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the user to unfollow. */\n  userId: Scalars['ID']\n}\n\n/** Autogenerated return type of UnfollowUser */\nexport type UnfollowUserPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The user that was unfollowed. */\n  user?: Maybe<User>\n}\n\n/** Represents a type that can be retrieved by a URL. */\nexport type UniformResourceLocatable = {\n  /** The HTML path to this resource. */\n  resourcePath: Scalars['URI']\n  /** The URL to this resource. */\n  url: Scalars['URI']\n}\n\n/** Represents an unknown signature on a Commit or Tag. */\nexport type UnknownSignature = GitSignature & {\n  /** Email used to sign this object. */\n  email: Scalars['String']\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean']\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String']\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String']\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean']\n}\n\n/** Represents an 'unlabeled' event on a given issue or pull request. */\nexport type UnlabeledEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Identifies the label associated with the 'unlabeled' event. */\n  label: Label\n  /** Identifies the `Labelable` associated with the event. */\n  labelable: Labelable\n}\n\n/** Autogenerated input type of UnlinkRepositoryFromProject */\nexport type UnlinkRepositoryFromProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the Project linked to the Repository. */\n  projectId: Scalars['ID']\n  /** The ID of the Repository linked to the Project. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of UnlinkRepositoryFromProject */\nexport type UnlinkRepositoryFromProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The linked Project. */\n  project?: Maybe<Project>\n  /** The linked Repository. */\n  repository?: Maybe<Repository>\n}\n\n/** Autogenerated input type of UnlockLockable */\nexport type UnlockLockableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the item to be unlocked. */\n  lockableId: Scalars['ID']\n}\n\n/** Autogenerated return type of UnlockLockable */\nexport type UnlockLockablePayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The item that was unlocked. */\n  unlockedRecord?: Maybe<Lockable>\n}\n\n/** Represents an 'unlocked' event on a given issue or pull request. */\nexport type UnlockedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Object that was unlocked. */\n  lockable: Lockable\n}\n\n/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */\nexport type UnmarkDiscussionCommentAsAnswerInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the discussion comment to unmark as an answer. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of UnmarkDiscussionCommentAsAnswer */\nexport type UnmarkDiscussionCommentAsAnswerPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The discussion that includes the comment. */\n  discussion?: Maybe<Discussion>\n}\n\n/** Autogenerated input type of UnmarkFileAsViewed */\nexport type UnmarkFileAsViewedInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The path of the file to mark as unviewed */\n  path: Scalars['String']\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID']\n}\n\n/** Autogenerated return type of UnmarkFileAsViewed */\nexport type UnmarkFileAsViewedPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Autogenerated input type of UnmarkIssueAsDuplicate */\nexport type UnmarkIssueAsDuplicateInput = {\n  /** ID of the issue or pull request currently considered canonical/authoritative/original. */\n  canonicalId: Scalars['ID']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** ID of the issue or pull request currently marked as a duplicate. */\n  duplicateId: Scalars['ID']\n}\n\n/** Autogenerated return type of UnmarkIssueAsDuplicate */\nexport type UnmarkIssueAsDuplicatePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The issue or pull request that was marked as a duplicate. */\n  duplicate?: Maybe<IssueOrPullRequest>\n}\n\n/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\nexport type UnmarkedAsDuplicateEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** The authoritative issue or pull request which has been duplicated by another. */\n  canonical?: Maybe<IssueOrPullRequest>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** The issue or pull request which has been marked as a duplicate of another. */\n  duplicate?: Maybe<IssueOrPullRequest>\n  id: Scalars['ID']\n  /** Canonical and duplicate belong to different repositories. */\n  isCrossRepository: Scalars['Boolean']\n}\n\n/** Autogenerated input type of UnminimizeComment */\nexport type UnminimizeCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID']\n}\n\n/** Autogenerated return type of UnminimizeComment */\nexport type UnminimizeCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The comment that was unminimized. */\n  unminimizedComment?: Maybe<Minimizable>\n}\n\n/** Autogenerated input type of UnpinIssue */\nexport type UnpinIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the issue to be unpinned */\n  issueId: Scalars['ID']\n}\n\n/** Autogenerated return type of UnpinIssue */\nexport type UnpinIssuePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The issue that was unpinned */\n  issue?: Maybe<Issue>\n}\n\n/** Represents an 'unpinned' event on a given issue or pull request. */\nexport type UnpinnedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Identifies the issue associated with the event. */\n  issue: Issue\n}\n\n/** Autogenerated input type of UnresolveReviewThread */\nexport type UnresolveReviewThreadInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the thread to unresolve */\n  threadId: Scalars['ID']\n}\n\n/** Autogenerated return type of UnresolveReviewThread */\nexport type UnresolveReviewThreadPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The thread to resolve. */\n  thread?: Maybe<PullRequestReviewThread>\n}\n\n/** Represents an 'unsubscribed' event on a given `Subscribable`. */\nexport type UnsubscribedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** Object referenced by event. */\n  subscribable: Subscribable\n}\n\n/** Entities that can be updated. */\nexport type Updatable = {\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean']\n}\n\n/** Comments that can be updated. */\nexport type UpdatableComment = {\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>\n}\n\n/** Autogenerated input type of UpdateBranchProtectionRule */\nexport type UpdateBranchProtectionRuleInput = {\n  /** Can this branch be deleted. */\n  allowsDeletions?: Maybe<Scalars['Boolean']>\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes?: Maybe<Scalars['Boolean']>\n  /** The global relay id of the branch protection rule to be updated. */\n  branchProtectionRuleId: Scalars['ID']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews?: Maybe<Scalars['Boolean']>\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced?: Maybe<Scalars['Boolean']>\n  /** The glob-like pattern used to determine matching branches. */\n  pattern?: Maybe<Scalars['String']>\n  /** A list of User, Team or App IDs allowed to push to matching branches. */\n  pushActorIds?: Maybe<Array<Scalars['ID']>>\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars['Int']>\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Scalars['String']>>\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews?: Maybe<Scalars['Boolean']>\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews?: Maybe<Scalars['Boolean']>\n  /** Are commits required to be signed. */\n  requiresCommitSignatures?: Maybe<Scalars['Boolean']>\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution?: Maybe<Scalars['Boolean']>\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory?: Maybe<Scalars['Boolean']>\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks?: Maybe<Scalars['Boolean']>\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks?: Maybe<Scalars['Boolean']>\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes?: Maybe<Scalars['Boolean']>\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals?: Maybe<Scalars['Boolean']>\n  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */\n  reviewDismissalActorIds?: Maybe<Array<Scalars['ID']>>\n}\n\n/** Autogenerated return type of UpdateBranchProtectionRule */\nexport type UpdateBranchProtectionRulePayload = {\n  /** The newly created BranchProtectionRule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateCheckRun */\nexport type UpdateCheckRunInput = {\n  /** Possible further actions the integrator can perform, which a user may trigger. */\n  actions?: Maybe<Array<CheckRunAction>>\n  /** The node of the check. */\n  checkRunId: Scalars['ID']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The time that the check run finished. */\n  completedAt?: Maybe<Scalars['DateTime']>\n  /** The final conclusion of the check. */\n  conclusion?: Maybe<CheckConclusionState>\n  /** The URL of the integrator's site that has the full details of the check. */\n  detailsUrl?: Maybe<Scalars['URI']>\n  /** A reference for the run on the integrator's system. */\n  externalId?: Maybe<Scalars['String']>\n  /** The name of the check. */\n  name?: Maybe<Scalars['String']>\n  /** Descriptive details about the run. */\n  output?: Maybe<CheckRunOutput>\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID']\n  /** The time that the check run began. */\n  startedAt?: Maybe<Scalars['DateTime']>\n  /** The current status. */\n  status?: Maybe<RequestableCheckStatusState>\n}\n\n/** Autogenerated return type of UpdateCheckRun */\nexport type UpdateCheckRunPayload = {\n  /** The updated check run. */\n  checkRun?: Maybe<CheckRun>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateCheckSuitePreferences */\nexport type UpdateCheckSuitePreferencesInput = {\n  /** The check suite preferences to modify. */\n  autoTriggerPreferences: Array<CheckSuiteAutoTriggerPreference>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdateCheckSuitePreferences */\nexport type UpdateCheckSuitePreferencesPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated repository. */\n  repository?: Maybe<Repository>\n}\n\n/** Autogenerated input type of UpdateDiscussionComment */\nexport type UpdateDiscussionCommentInput = {\n  /** The new contents of the comment body. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the discussion comment to update. */\n  commentId: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdateDiscussionComment */\nexport type UpdateDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The modified discussion comment. */\n  comment?: Maybe<DiscussionComment>\n}\n\n/** Autogenerated input type of UpdateDiscussion */\nexport type UpdateDiscussionInput = {\n  /** The new contents of the discussion body. */\n  body?: Maybe<Scalars['String']>\n  /** The Node ID of a discussion category within the same repository to change this discussion to. */\n  categoryId?: Maybe<Scalars['ID']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the discussion to update. */\n  discussionId: Scalars['ID']\n  /** The new discussion title. */\n  title?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of UpdateDiscussion */\nexport type UpdateDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The modified discussion. */\n  discussion?: Maybe<Discussion>\n}\n\n/** Autogenerated input type of UpdateEnterpriseAdministratorRole */\nexport type UpdateEnterpriseAdministratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID']\n  /** The login of a administrator whose role is being changed. */\n  login: Scalars['String']\n  /** The new role for the Enterprise administrator. */\n  role: EnterpriseAdministratorRole\n}\n\n/** Autogenerated return type of UpdateEnterpriseAdministratorRole */\nexport type UpdateEnterpriseAdministratorRolePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A message confirming the result of changing the administrator's role. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */\nexport type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the allow private repository forking setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the allow private repository forking setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */\nexport type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated allow private repository forking setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the allow private repository forking setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */\nexport type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the base repository permission setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the base repository permission setting on the enterprise. */\n  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */\nexport type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated base repository permission setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the base repository permission setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */\nexport type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the members can change repository visibility setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the members can change repository visibility setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */\nexport type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated members can change repository visibility setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the members can change repository visibility setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the members can create repositories setting. */\n  enterpriseId: Scalars['ID']\n  /** Allow members to create internal repositories. Defaults to current value. */\n  membersCanCreateInternalRepositories?: Maybe<Scalars['Boolean']>\n  /** Allow members to create private repositories. Defaults to current value. */\n  membersCanCreatePrivateRepositories?: Maybe<Scalars['Boolean']>\n  /** Allow members to create public repositories. Defaults to current value. */\n  membersCanCreatePublicRepositories?: Maybe<Scalars['Boolean']>\n  /** When false, allow member organizations to set their own repository creation member privileges. */\n  membersCanCreateRepositoriesPolicyEnabled?: Maybe<Scalars['Boolean']>\n  /**\n   * Value for the members can create repositories setting on the enterprise. This\n   * or the granular public/private/internal allowed fields (but not both) must be provided.\n   */\n  settingValue?: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>\n}\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated members can create repositories setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the members can create repositories setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */\nexport type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the members can delete issues setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the members can delete issues setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */\nexport type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated members can delete issues setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the members can delete issues setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the members can delete repositories setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the members can delete repositories setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated members can delete repositories setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the members can delete repositories setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */\nexport type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the members can invite collaborators setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the members can invite collaborators setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */\nexport type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated members can invite collaborators setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the members can invite collaborators setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */\nexport type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the members can make purchases setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the members can make purchases setting on the enterprise. */\n  settingValue: EnterpriseMembersCanMakePurchasesSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */\nexport type UpdateEnterpriseMembersCanMakePurchasesSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated members can make purchases setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the members can make purchases setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */\nexport type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the members can update protected branches setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the members can update protected branches setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */\nexport type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated members can update protected branches setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the members can update protected branches setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */\nexport type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the members can view dependency insights setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the members can view dependency insights setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */\nexport type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated members can view dependency insights setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the members can view dependency insights setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */\nexport type UpdateEnterpriseOrganizationProjectsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the organization projects setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the organization projects setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */\nexport type UpdateEnterpriseOrganizationProjectsSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated organization projects setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the organization projects setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseProfile */\nexport type UpdateEnterpriseProfileInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The description of the enterprise. */\n  description?: Maybe<Scalars['String']>\n  /** The Enterprise ID to update. */\n  enterpriseId: Scalars['ID']\n  /** The location of the enterprise. */\n  location?: Maybe<Scalars['String']>\n  /** The name of the enterprise. */\n  name?: Maybe<Scalars['String']>\n  /** The URL of the enterprise's website. */\n  websiteUrl?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of UpdateEnterpriseProfile */\nexport type UpdateEnterpriseProfilePayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>\n}\n\n/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */\nexport type UpdateEnterpriseRepositoryProjectsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the repository projects setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the repository projects setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */\nexport type UpdateEnterpriseRepositoryProjectsSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated repository projects setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the repository projects setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */\nexport type UpdateEnterpriseTeamDiscussionsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the team discussions setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the team discussions setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */\nexport type UpdateEnterpriseTeamDiscussionsSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated team discussions setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the team discussions setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */\nexport type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the enterprise on which to set the two factor authentication required setting. */\n  enterpriseId: Scalars['ID']\n  /** The value for the two factor authentication required setting on the enterprise. */\n  settingValue: EnterpriseEnabledSettingValue\n}\n\n/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */\nexport type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The enterprise with the updated two factor authentication required setting. */\n  enterprise?: Maybe<Enterprise>\n  /** A message confirming the result of updating the two factor authentication required setting. */\n  message?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateEnvironment */\nexport type UpdateEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The node ID of the environment. */\n  environmentId: Scalars['ID']\n  /** The ids of users or teams that can approve deployments to this environment */\n  reviewers?: Maybe<Array<Scalars['ID']>>\n  /** The wait timer in minutes. */\n  waitTimer?: Maybe<Scalars['Int']>\n}\n\n/** Autogenerated return type of UpdateEnvironment */\nexport type UpdateEnvironmentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated environment. */\n  environment?: Maybe<Environment>\n}\n\n/** Autogenerated input type of UpdateIpAllowListEnabledSetting */\nexport type UpdateIpAllowListEnabledSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the owner on which to set the IP allow list enabled setting. */\n  ownerId: Scalars['ID']\n  /** The value for the IP allow list enabled setting. */\n  settingValue: IpAllowListEnabledSettingValue\n}\n\n/** Autogenerated return type of UpdateIpAllowListEnabledSetting */\nexport type UpdateIpAllowListEnabledSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The IP allow list owner on which the setting was updated. */\n  owner?: Maybe<IpAllowListOwner>\n}\n\n/** Autogenerated input type of UpdateIpAllowListEntry */\nexport type UpdateIpAllowListEntryInput = {\n  /** An IP address or range of addresses in CIDR notation. */\n  allowListValue: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the IP allow list entry to update. */\n  ipAllowListEntryId: Scalars['ID']\n  /** Whether the IP allow list entry is active when an IP allow list is enabled. */\n  isActive: Scalars['Boolean']\n  /** An optional name for the IP allow list entry. */\n  name?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of UpdateIpAllowListEntry */\nexport type UpdateIpAllowListEntryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The IP allow list entry that was updated. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>\n}\n\n/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */\nexport type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the owner. */\n  ownerId: Scalars['ID']\n  /** The value for the IP allow list configuration for installed GitHub Apps setting. */\n  settingValue: IpAllowListForInstalledAppsEnabledSettingValue\n}\n\n/** Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting */\nexport type UpdateIpAllowListForInstalledAppsEnabledSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The IP allow list owner on which the setting was updated. */\n  owner?: Maybe<IpAllowListOwner>\n}\n\n/** Autogenerated input type of UpdateIssueComment */\nexport type UpdateIssueCommentInput = {\n  /** The updated text of the comment. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the IssueComment to modify. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdateIssueComment */\nexport type UpdateIssueCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated comment. */\n  issueComment?: Maybe<IssueComment>\n}\n\n/** Autogenerated input type of UpdateIssue */\nexport type UpdateIssueInput = {\n  /** An array of Node IDs of users for this issue. */\n  assigneeIds?: Maybe<Array<Scalars['ID']>>\n  /** The body for the issue description. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the Issue to modify. */\n  id: Scalars['ID']\n  /** An array of Node IDs of labels for this issue. */\n  labelIds?: Maybe<Array<Scalars['ID']>>\n  /** The Node ID of the milestone for this issue. */\n  milestoneId?: Maybe<Scalars['ID']>\n  /** An array of Node IDs for projects associated with this issue. */\n  projectIds?: Maybe<Array<Scalars['ID']>>\n  /** The desired issue state. */\n  state?: Maybe<IssueState>\n  /** The title for the issue. */\n  title?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of UpdateIssue */\nexport type UpdateIssuePayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The issue. */\n  issue?: Maybe<Issue>\n}\n\n/** Autogenerated input type of UpdateLabel */\nexport type UpdateLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */\n  color?: Maybe<Scalars['String']>\n  /** A brief description of the label, such as its purpose. */\n  description?: Maybe<Scalars['String']>\n  /** The Node ID of the label to be updated. */\n  id: Scalars['ID']\n  /** The updated name of the label. */\n  name?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of UpdateLabel */\nexport type UpdateLabelPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated label. */\n  label?: Maybe<Label>\n}\n\n/** Autogenerated input type of UpdateNotificationRestrictionSetting */\nexport type UpdateNotificationRestrictionSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the owner on which to set the restrict notifications setting. */\n  ownerId: Scalars['ID']\n  /** The value for the restrict notifications setting. */\n  settingValue: NotificationRestrictionSettingValue\n}\n\n/** Autogenerated return type of UpdateNotificationRestrictionSetting */\nexport type UpdateNotificationRestrictionSettingPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The owner on which the setting was updated. */\n  owner?: Maybe<VerifiableDomainOwner>\n}\n\n/** Autogenerated input type of UpdateProjectCard */\nexport type UpdateProjectCardInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Whether or not the ProjectCard should be archived */\n  isArchived?: Maybe<Scalars['Boolean']>\n  /** The note of ProjectCard. */\n  note?: Maybe<Scalars['String']>\n  /** The ProjectCard ID to update. */\n  projectCardId: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdateProjectCard */\nexport type UpdateProjectCardPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated ProjectCard. */\n  projectCard?: Maybe<ProjectCard>\n}\n\n/** Autogenerated input type of UpdateProjectColumn */\nexport type UpdateProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The name of project column. */\n  name: Scalars['String']\n  /** The ProjectColumn ID to update. */\n  projectColumnId: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdateProjectColumn */\nexport type UpdateProjectColumnPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated project column. */\n  projectColumn?: Maybe<ProjectColumn>\n}\n\n/** Autogenerated input type of UpdateProject */\nexport type UpdateProjectInput = {\n  /** The description of project. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The name of project. */\n  name?: Maybe<Scalars['String']>\n  /** The Project ID to update. */\n  projectId: Scalars['ID']\n  /** Whether the project is public or not. */\n  public?: Maybe<Scalars['Boolean']>\n  /** Whether the project is open or closed. */\n  state?: Maybe<ProjectState>\n}\n\n/** Autogenerated input type of UpdateProjectNextItemField */\nexport type UpdateProjectNextItemFieldInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The id of the field to be updated. Only supports custom fields and status for now. */\n  fieldId: Scalars['ID']\n  /** The id of the item to be updated. */\n  itemId: Scalars['ID']\n  /** The ID of the Project. */\n  projectId: Scalars['ID']\n  /** The value which will be set on the field. */\n  value: Scalars['String']\n}\n\n/** Autogenerated return type of UpdateProjectNextItemField */\nexport type UpdateProjectNextItemFieldPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated item. */\n  projectNextItem?: Maybe<ProjectNextItem>\n}\n\n/** Autogenerated return type of UpdateProject */\nexport type UpdateProjectPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated project. */\n  project?: Maybe<Project>\n}\n\n/** Autogenerated input type of UpdatePullRequest */\nexport type UpdatePullRequestInput = {\n  /** An array of Node IDs of users for this pull request. */\n  assigneeIds?: Maybe<Array<Scalars['ID']>>\n  /**\n   * The name of the branch you want your changes pulled into. This should be an existing branch\n   * on the current repository.\n   */\n  baseRefName?: Maybe<Scalars['String']>\n  /** The contents of the pull request. */\n  body?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** An array of Node IDs of labels for this pull request. */\n  labelIds?: Maybe<Array<Scalars['ID']>>\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify?: Maybe<Scalars['Boolean']>\n  /** The Node ID of the milestone for this pull request. */\n  milestoneId?: Maybe<Scalars['ID']>\n  /** An array of Node IDs for projects associated with this pull request. */\n  projectIds?: Maybe<Array<Scalars['ID']>>\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID']\n  /** The target state of the pull request. */\n  state?: Maybe<PullRequestUpdateState>\n  /** The title of the pull request. */\n  title?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of UpdatePullRequest */\nexport type UpdatePullRequestPayload = {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>\n}\n\n/** Autogenerated input type of UpdatePullRequestReviewComment */\nexport type UpdatePullRequestReviewCommentInput = {\n  /** The text of the comment. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the comment to modify. */\n  pullRequestReviewCommentId: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdatePullRequestReviewComment */\nexport type UpdatePullRequestReviewCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated comment. */\n  pullRequestReviewComment?: Maybe<PullRequestReviewComment>\n}\n\n/** Autogenerated input type of UpdatePullRequestReview */\nexport type UpdatePullRequestReviewInput = {\n  /** The contents of the pull request review body. */\n  body: Scalars['String']\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the pull request review to modify. */\n  pullRequestReviewId: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdatePullRequestReview */\nexport type UpdatePullRequestReviewPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>\n}\n\n/** Autogenerated input type of UpdateRef */\nexport type UpdateRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Permit updates of branch Refs that are not fast-forwards? */\n  force?: Maybe<Scalars['Boolean']>\n  /** The GitObjectID that the Ref shall be updated to target. */\n  oid: Scalars['GitObjectID']\n  /** The Node ID of the Ref to be updated. */\n  refId: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdateRef */\nexport type UpdateRefPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated Ref. */\n  ref?: Maybe<Ref>\n}\n\n/** Autogenerated input type of UpdateRefs */\nexport type UpdateRefsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A list of ref updates. */\n  refUpdates: Array<RefUpdate>\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdateRefs */\nexport type UpdateRefsPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated input type of UpdateRepository */\nexport type UpdateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** A new description for the repository. Pass an empty string to erase the existing description. */\n  description?: Maybe<Scalars['String']>\n  /** Indicates if the repository should have the issues feature enabled. */\n  hasIssuesEnabled?: Maybe<Scalars['Boolean']>\n  /** Indicates if the repository should have the project boards feature enabled. */\n  hasProjectsEnabled?: Maybe<Scalars['Boolean']>\n  /** Indicates if the repository should have the wiki feature enabled. */\n  hasWikiEnabled?: Maybe<Scalars['Boolean']>\n  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */\n  homepageUrl?: Maybe<Scalars['URI']>\n  /** The new name of the repository. */\n  name?: Maybe<Scalars['String']>\n  /** The ID of the repository to update. */\n  repositoryId: Scalars['ID']\n  /**\n   * Whether this repository should be marked as a template such that anyone who\n   * can access it can create new repositories with the same files and directory structure.\n   */\n  template?: Maybe<Scalars['Boolean']>\n}\n\n/** Autogenerated return type of UpdateRepository */\nexport type UpdateRepositoryPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated repository. */\n  repository?: Maybe<Repository>\n}\n\n/** Autogenerated input type of UpdateSponsorshipPreferences */\nexport type UpdateSponsorshipPreferencesInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorable. Public visibility still does not reveal which tier is used.\n   */\n  privacyLevel?: Maybe<SponsorshipPrivacy>\n  /** Whether the sponsor should receive email updates from the sponsorable. */\n  receiveEmails?: Maybe<Scalars['Boolean']>\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: Maybe<Scalars['ID']>\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: Maybe<Scalars['String']>\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: Maybe<Scalars['ID']>\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of UpdateSponsorshipPreferences */\nexport type UpdateSponsorshipPreferencesPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The sponsorship that was updated. */\n  sponsorship?: Maybe<Sponsorship>\n}\n\n/** Autogenerated input type of UpdateSubscription */\nexport type UpdateSubscriptionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The new state of the subscription. */\n  state: SubscriptionState\n  /** The Node ID of the subscribable object to modify. */\n  subscribableId: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdateSubscription */\nexport type UpdateSubscriptionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The input subscribable entity. */\n  subscribable?: Maybe<Subscribable>\n}\n\n/** Autogenerated input type of UpdateTeamDiscussionComment */\nexport type UpdateTeamDiscussionCommentInput = {\n  /** The updated text of the comment. */\n  body: Scalars['String']\n  /** The current version of the body content. */\n  bodyVersion?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the comment to modify. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of UpdateTeamDiscussionComment */\nexport type UpdateTeamDiscussionCommentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated comment. */\n  teamDiscussionComment?: Maybe<TeamDiscussionComment>\n}\n\n/** Autogenerated input type of UpdateTeamDiscussion */\nexport type UpdateTeamDiscussionInput = {\n  /** The updated text of the discussion. */\n  body?: Maybe<Scalars['String']>\n  /**\n   * The current version of the body content. If provided, this update operation\n   * will be rejected if the given version does not match the latest version on the server.\n   */\n  bodyVersion?: Maybe<Scalars['String']>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the discussion to modify. */\n  id: Scalars['ID']\n  /** If provided, sets the pinned state of the updated discussion. */\n  pinned?: Maybe<Scalars['Boolean']>\n  /** The updated title of the discussion. */\n  title?: Maybe<Scalars['String']>\n}\n\n/** Autogenerated return type of UpdateTeamDiscussion */\nexport type UpdateTeamDiscussionPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The updated discussion. */\n  teamDiscussion?: Maybe<TeamDiscussion>\n}\n\n/** Autogenerated input type of UpdateTeamReviewAssignment */\nexport type UpdateTeamReviewAssignmentInput = {\n  /** The algorithm to use for review assignment */\n  algorithm?: Maybe<TeamReviewAssignmentAlgorithm>\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Turn on or off review assignment */\n  enabled: Scalars['Boolean']\n  /** An array of team member IDs to exclude */\n  excludedTeamMemberIds?: Maybe<Array<Scalars['ID']>>\n  /** The Node ID of the team to update review assignments of */\n  id: Scalars['ID']\n  /** Notify the entire team of the PR if it is delegated */\n  notifyTeam?: Maybe<Scalars['Boolean']>\n  /** The number of team members to assign */\n  teamMemberCount?: Maybe<Scalars['Int']>\n}\n\n/** Autogenerated return type of UpdateTeamReviewAssignment */\nexport type UpdateTeamReviewAssignmentPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The team that was modified */\n  team?: Maybe<Team>\n}\n\n/** Autogenerated input type of UpdateTopics */\nexport type UpdateTopicsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID']\n  /** An array of topic names. */\n  topicNames: Array<Scalars['String']>\n}\n\n/** Autogenerated return type of UpdateTopics */\nexport type UpdateTopicsPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** Names of the provided topics that are not valid. */\n  invalidTopicNames?: Maybe<Array<Scalars['String']>>\n  /** The updated repository. */\n  repository?: Maybe<Repository>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type User = Actor &\n  Node &\n  PackageOwner &\n  ProfileOwner &\n  ProjectNextOwner &\n  ProjectOwner &\n  RepositoryDiscussionAuthor &\n  RepositoryDiscussionCommentAuthor &\n  RepositoryOwner &\n  Sponsorable &\n  UniformResourceLocatable & {\n    /** Determine if this repository owner has any items that can be pinned to their profile. */\n    anyPinnableItems: Scalars['Boolean']\n    /** A URL pointing to the user's public avatar. */\n    avatarUrl: Scalars['URI']\n    /** The user's public profile bio. */\n    bio?: Maybe<Scalars['String']>\n    /** The user's public profile bio as HTML. */\n    bioHTML: Scalars['HTML']\n    /** Could this user receive email notifications, if the organization had notification restrictions enabled? */\n    canReceiveOrganizationEmailsWhenNotificationsRestricted: Scalars['Boolean']\n    /** A list of commit comments made by this user. */\n    commitComments: CommitCommentConnection\n    /** The user's public profile company. */\n    company?: Maybe<Scalars['String']>\n    /** The user's public profile company as HTML. */\n    companyHTML: Scalars['HTML']\n    /** The collection of contributions this user has made to different repositories. */\n    contributionsCollection: ContributionsCollection\n    /** Identifies the date and time when the object was created. */\n    createdAt: Scalars['DateTime']\n    /** Identifies the primary key from the database. */\n    databaseId?: Maybe<Scalars['Int']>\n    /** The user's publicly visible profile email. */\n    email: Scalars['String']\n    /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n    estimatedNextSponsorsPayoutInCents: Scalars['Int']\n    /** A list of users the given user is followed by. */\n    followers: FollowerConnection\n    /** A list of users the given user is following. */\n    following: FollowingConnection\n    /** Find gist by repo name. */\n    gist?: Maybe<Gist>\n    /** A list of gist comments made by this user. */\n    gistComments: GistCommentConnection\n    /** A list of the Gists the user has created. */\n    gists: GistConnection\n    /** True if this user/organization has a GitHub Sponsors listing. */\n    hasSponsorsListing: Scalars['Boolean']\n    /** The hovercard information for this user in a given context */\n    hovercard: Hovercard\n    id: Scalars['ID']\n    /** The interaction ability settings for this user. */\n    interactionAbility?: Maybe<RepositoryInteractionAbility>\n    /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */\n    isBountyHunter: Scalars['Boolean']\n    /** Whether or not this user is a participant in the GitHub Campus Experts Program. */\n    isCampusExpert: Scalars['Boolean']\n    /** Whether or not this user is a GitHub Developer Program member. */\n    isDeveloperProgramMember: Scalars['Boolean']\n    /** Whether or not this user is a GitHub employee. */\n    isEmployee: Scalars['Boolean']\n    /** Whether or not this user is following the viewer. Inverse of viewer_is_following */\n    isFollowingViewer: Scalars['Boolean']\n    /** Whether or not this user is a member of the GitHub Stars Program. */\n    isGitHubStar: Scalars['Boolean']\n    /** Whether or not the user has marked themselves as for hire. */\n    isHireable: Scalars['Boolean']\n    /** Whether or not this user is a site administrator. */\n    isSiteAdmin: Scalars['Boolean']\n    /** Check if the given account is sponsoring this user/organization. */\n    isSponsoredBy: Scalars['Boolean']\n    /** True if the viewer is sponsored by this user/organization. */\n    isSponsoringViewer: Scalars['Boolean']\n    /** Whether or not this user is the viewing user. */\n    isViewer: Scalars['Boolean']\n    /** A list of issue comments made by this user. */\n    issueComments: IssueCommentConnection\n    /** A list of issues associated with this user. */\n    issues: IssueConnection\n    /**\n     * Showcases a selection of repositories and gists that the profile owner has\n     * either curated or that have been selected automatically based on popularity.\n     */\n    itemShowcase: ProfileItemShowcase\n    /** The user's public profile location. */\n    location?: Maybe<Scalars['String']>\n    /** The username used to login. */\n    login: Scalars['String']\n    /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n    monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']\n    /** The user's public profile name. */\n    name?: Maybe<Scalars['String']>\n    /** Find an organization by its login that the user belongs to. */\n    organization?: Maybe<Organization>\n    /** Verified email addresses that match verified domains for a specified organization the user is a member of. */\n    organizationVerifiedDomainEmails: Array<Scalars['String']>\n    /** A list of organizations the user belongs to. */\n    organizations: OrganizationConnection\n    /** A list of packages under the owner. */\n    packages: PackageConnection\n    /** A list of repositories and gists this profile owner can pin to their profile. */\n    pinnableItems: PinnableItemConnection\n    /** A list of repositories and gists this profile owner has pinned to their profile */\n    pinnedItems: PinnableItemConnection\n    /** Returns how many more items this profile owner can pin to their profile. */\n    pinnedItemsRemaining: Scalars['Int']\n    /** Find project by number. */\n    project?: Maybe<Project>\n    /** Find project by project next number. */\n    projectNext?: Maybe<ProjectNext>\n    /** A list of projects under the owner. */\n    projects: ProjectConnection\n    /** A list of project next items under the owner. */\n    projectsNext: ProjectNextConnection\n    /** The HTTP path listing user's projects */\n    projectsResourcePath: Scalars['URI']\n    /** The HTTP URL listing user's projects */\n    projectsUrl: Scalars['URI']\n    /** A list of public keys associated with this user. */\n    publicKeys: PublicKeyConnection\n    /** A list of pull requests associated with this user. */\n    pullRequests: PullRequestConnection\n    /** A list of repositories that the user owns. */\n    repositories: RepositoryConnection\n    /** A list of repositories that the user recently contributed to. */\n    repositoriesContributedTo: RepositoryConnection\n    /** Find Repository. */\n    repository?: Maybe<Repository>\n    /** Discussion comments this user has authored. */\n    repositoryDiscussionComments: DiscussionCommentConnection\n    /** Discussions this user has started. */\n    repositoryDiscussions: DiscussionConnection\n    /** The HTTP path for this user */\n    resourcePath: Scalars['URI']\n    /** Replies this user has saved */\n    savedReplies?: Maybe<SavedReplyConnection>\n    /** List of users and organizations this entity is sponsoring. */\n    sponsoring: SponsorConnection\n    /** List of sponsors for this user or organization. */\n    sponsors: SponsorConnection\n    /** Events involving this sponsorable, such as new sponsorships. */\n    sponsorsActivities: SponsorsActivityConnection\n    /** The GitHub Sponsors listing for this user or organization. */\n    sponsorsListing?: Maybe<SponsorsListing>\n    /**\n     * The sponsorship from the viewer to this user/organization; that is, the\n     * sponsorship where you're the sponsor. Only returns a sponsorship if it is active.\n     */\n    sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>\n    /**\n     * The sponsorship from this user/organization to the viewer; that is, the\n     * sponsorship you're receiving. Only returns a sponsorship if it is active.\n     */\n    sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>\n    /** List of sponsorship updates sent from this sponsorable to sponsors. */\n    sponsorshipNewsletters: SponsorshipNewsletterConnection\n    /** This object's sponsorships as the maintainer. */\n    sponsorshipsAsMaintainer: SponsorshipConnection\n    /** This object's sponsorships as the sponsor. */\n    sponsorshipsAsSponsor: SponsorshipConnection\n    /** Repositories the user has starred. */\n    starredRepositories: StarredRepositoryConnection\n    /** The user's description of what they're currently doing. */\n    status?: Maybe<UserStatus>\n    /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */\n    topRepositories: RepositoryConnection\n    /** The user's Twitter username. */\n    twitterUsername?: Maybe<Scalars['String']>\n    /** Identifies the date and time when the object was last updated. */\n    updatedAt: Scalars['DateTime']\n    /** The HTTP URL for this user */\n    url: Scalars['URI']\n    /** Can the viewer pin repositories and gists to the profile? */\n    viewerCanChangePinnedItems: Scalars['Boolean']\n    /** Can the current viewer create new projects on this owner. */\n    viewerCanCreateProjects: Scalars['Boolean']\n    /** Whether or not the viewer is able to follow the user. */\n    viewerCanFollow: Scalars['Boolean']\n    /** Whether or not the viewer is able to sponsor this user/organization. */\n    viewerCanSponsor: Scalars['Boolean']\n    /** Whether or not this user is followed by the viewer. Inverse of is_following_viewer. */\n    viewerIsFollowing: Scalars['Boolean']\n    /** True if the viewer is sponsoring this user/organization. */\n    viewerIsSponsoring: Scalars['Boolean']\n    /** A list of repositories the given user is watching. */\n    watching: RepositoryConnection\n    /** A URL pointing to the user's public website/blog. */\n    websiteUrl?: Maybe<Scalars['URI']>\n  }\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserAnyPinnableItemsArgs = {\n  type?: Maybe<PinnableItemType>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserAvatarUrlArgs = {\n  size?: Maybe<Scalars['Int']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserCanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs = {\n  login: Scalars['String']\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserCommitCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserContributionsCollectionArgs = {\n  from?: Maybe<Scalars['DateTime']>\n  organizationID?: Maybe<Scalars['ID']>\n  to?: Maybe<Scalars['DateTime']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserFollowersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserFollowingArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistArgs = {\n  name: Scalars['String']\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<GistOrder>\n  privacy?: Maybe<GistPrivacy>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserHovercardArgs = {\n  primarySubjectId?: Maybe<Scalars['ID']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIsSponsoredByArgs = {\n  accountLogin: Scalars['String']\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIssueCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueCommentOrder>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIssuesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  filterBy?: Maybe<IssueFilters>\n  first?: Maybe<Scalars['Int']>\n  labels?: Maybe<Array<Scalars['String']>>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n  states?: Maybe<Array<IssueState>>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationArgs = {\n  login: Scalars['String']\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationVerifiedDomainEmailsArgs = {\n  login: Scalars['String']\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPackagesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  names?: Maybe<Array<Maybe<Scalars['String']>>>\n  orderBy?: Maybe<PackageOrder>\n  packageType?: Maybe<PackageType>\n  repositoryId?: Maybe<Scalars['ID']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPinnableItemsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  types?: Maybe<Array<PinnableItemType>>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPinnedItemsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  types?: Maybe<Array<PinnableItemType>>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectArgs = {\n  number: Scalars['Int']\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectNextArgs = {\n  number: Scalars['Int']\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<ProjectOrder>\n  search?: Maybe<Scalars['String']>\n  states?: Maybe<Array<ProjectState>>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectsNextArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPublicKeysArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPullRequestsArgs = {\n  after?: Maybe<Scalars['String']>\n  baseRefName?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  headRefName?: Maybe<Scalars['String']>\n  labels?: Maybe<Array<Scalars['String']>>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<IssueOrder>\n  states?: Maybe<Array<PullRequestState>>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoriesArgs = {\n  affiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  isFork?: Maybe<Scalars['Boolean']>\n  isLocked?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryOrder>\n  ownerAffiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  privacy?: Maybe<RepositoryPrivacy>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoriesContributedToArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  contributionTypes?: Maybe<Array<Maybe<RepositoryContributionType>>>\n  first?: Maybe<Scalars['Int']>\n  includeUserRepositories?: Maybe<Scalars['Boolean']>\n  isLocked?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryOrder>\n  privacy?: Maybe<RepositoryPrivacy>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryArgs = {\n  name: Scalars['String']\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryDiscussionCommentsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  onlyAnswers?: Maybe<Scalars['Boolean']>\n  repositoryId?: Maybe<Scalars['ID']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryDiscussionsArgs = {\n  after?: Maybe<Scalars['String']>\n  answered?: Maybe<Scalars['Boolean']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<DiscussionOrder>\n  repositoryId?: Maybe<Scalars['ID']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSavedRepliesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SavedReplyOrder>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsoringArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorOrder>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorOrder>\n  tierId?: Maybe<Scalars['ID']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorsActivitiesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorsActivityOrder>\n  period?: Maybe<SponsorsActivityPeriod>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipNewslettersArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorshipNewsletterOrder>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipsAsMaintainerArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  includePrivate?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorshipOrder>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipsAsSponsorArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<SponsorshipOrder>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserStarredRepositoriesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<StarOrder>\n  ownedByViewer?: Maybe<Scalars['Boolean']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserTopRepositoriesArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n  orderBy: RepositoryOrder\n  since?: Maybe<Scalars['DateTime']>\n}\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserWatchingArgs = {\n  affiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  isLocked?: Maybe<Scalars['Boolean']>\n  last?: Maybe<Scalars['Int']>\n  orderBy?: Maybe<RepositoryOrder>\n  ownerAffiliations?: Maybe<Array<Maybe<RepositoryAffiliation>>>\n  privacy?: Maybe<RepositoryPrivacy>\n}\n\n/** The possible durations that a user can be blocked for. */\nexport enum UserBlockDuration {\n  /** The user was blocked for 1 day */\n  OneDay = 'ONE_DAY',\n  /** The user was blocked for 30 days */\n  OneMonth = 'ONE_MONTH',\n  /** The user was blocked for 7 days */\n  OneWeek = 'ONE_WEEK',\n  /** The user was blocked permanently */\n  Permanent = 'PERMANENT',\n  /** The user was blocked for 3 days */\n  ThreeDays = 'THREE_DAYS',\n}\n\n/** Represents a 'user_blocked' event on a given user. */\nexport type UserBlockedEvent = Node & {\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>\n  /** Number of days that the user was blocked for. */\n  blockDuration: UserBlockDuration\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  id: Scalars['ID']\n  /** The user who was blocked. */\n  subject?: Maybe<User>\n}\n\n/** The connection type for User. */\nexport type UserConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edit on user content */\nexport type UserContentEdit = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the date and time when the object was deleted. */\n  deletedAt?: Maybe<Scalars['DateTime']>\n  /** The actor who deleted this content */\n  deletedBy?: Maybe<Actor>\n  /** A summary of the changes for this edit */\n  diff?: Maybe<Scalars['String']>\n  /** When this content was edited */\n  editedAt: Scalars['DateTime']\n  /** The actor who edited this content */\n  editor?: Maybe<Actor>\n  id: Scalars['ID']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** A list of edits to content. */\nexport type UserContentEditConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserContentEditEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<UserContentEdit>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type UserContentEditEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<UserContentEdit>\n}\n\n/** Represents a user. */\nexport type UserEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<User>\n}\n\n/** Email attributes from External Identity */\nexport type UserEmailMetadata = {\n  /** Boolean to identify primary emails */\n  primary?: Maybe<Scalars['Boolean']>\n  /** Type of email */\n  type?: Maybe<Scalars['String']>\n  /** Email id */\n  value: Scalars['String']\n}\n\n/** The user's description of what they're currently doing. */\nexport type UserStatus = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** An emoji summarizing the user's status. */\n  emoji?: Maybe<Scalars['String']>\n  /** The status emoji as HTML. */\n  emojiHTML?: Maybe<Scalars['HTML']>\n  /** If set, the status will not be shown after this date. */\n  expiresAt?: Maybe<Scalars['DateTime']>\n  id: Scalars['ID']\n  /** Whether this status indicates the user is not fully available on GitHub. */\n  indicatesLimitedAvailability: Scalars['Boolean']\n  /** A brief message describing what the user is doing. */\n  message?: Maybe<Scalars['String']>\n  /** The organization whose members can see this status. If null, this status is publicly visible. */\n  organization?: Maybe<Organization>\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The user who has this status. */\n  user: User\n}\n\n/** The connection type for UserStatus. */\nexport type UserStatusConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserStatusEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<UserStatus>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type UserStatusEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<UserStatus>\n}\n\n/** Ordering options for user status connections. */\nexport type UserStatusOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order user statuses by. */\n  field: UserStatusOrderField\n}\n\n/** Properties by which user status connections can be ordered. */\nexport enum UserStatusOrderField {\n  /** Order user statuses by when they were updated. */\n  UpdatedAt = 'UPDATED_AT',\n}\n\n/** A domain that can be verified or approved for an organization or an enterprise. */\nexport type VerifiableDomain = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** The DNS host name that should be used for verification. */\n  dnsHostName?: Maybe<Scalars['URI']>\n  /** The unicode encoded domain. */\n  domain: Scalars['URI']\n  /** Whether a TXT record for verification with the expected host name was found. */\n  hasFoundHostName: Scalars['Boolean']\n  /** Whether a TXT record for verification with the expected verification token was found. */\n  hasFoundVerificationToken: Scalars['Boolean']\n  id: Scalars['ID']\n  /** Whether or not the domain is approved. */\n  isApproved: Scalars['Boolean']\n  /** Whether this domain is required to exist for an organization or enterprise policy to be enforced. */\n  isRequiredForPolicyEnforcement: Scalars['Boolean']\n  /** Whether or not the domain is verified. */\n  isVerified: Scalars['Boolean']\n  /** The owner of the domain. */\n  owner: VerifiableDomainOwner\n  /** The punycode encoded domain. */\n  punycodeEncodedDomain: Scalars['URI']\n  /** The time that the current verification token will expire. */\n  tokenExpirationTime?: Maybe<Scalars['DateTime']>\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The current verification token for the domain. */\n  verificationToken?: Maybe<Scalars['String']>\n}\n\n/** The connection type for VerifiableDomain. */\nexport type VerifiableDomainConnection = {\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<VerifiableDomainEdge>>>\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<VerifiableDomain>>>\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int']\n}\n\n/** An edge in a connection. */\nexport type VerifiableDomainEdge = {\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String']\n  /** The item at the end of the edge. */\n  node?: Maybe<VerifiableDomain>\n}\n\n/** Ordering options for verifiable domain connections. */\nexport type VerifiableDomainOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection\n  /** The field to order verifiable domains by. */\n  field: VerifiableDomainOrderField\n}\n\n/** Properties by which verifiable domain connections can be ordered. */\nexport enum VerifiableDomainOrderField {\n  /** Order verifiable domains by their creation date. */\n  CreatedAt = 'CREATED_AT',\n  /** Order verifiable domains by the domain name. */\n  Domain = 'DOMAIN',\n}\n\n/** Types that can own a verifiable domain. */\nexport type VerifiableDomainOwner = Enterprise | Organization\n\n/** Autogenerated input type of VerifyVerifiableDomain */\nexport type VerifyVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The ID of the verifiable domain to verify. */\n  id: Scalars['ID']\n}\n\n/** Autogenerated return type of VerifyVerifiableDomain */\nexport type VerifyVerifiableDomainPayload = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>\n  /** The verifiable domain that was verified. */\n  domain?: Maybe<VerifiableDomain>\n}\n\n/** A hovercard context with a message describing how the viewer is related. */\nexport type ViewerHovercardContext = HovercardContext & {\n  /** A string describing this context */\n  message: Scalars['String']\n  /** An octicon to accompany this context */\n  octicon: Scalars['String']\n  /** Identifies the user who is related to this context. */\n  viewer: User\n}\n\n/** A subject that may be upvoted. */\nexport type Votable = {\n  /** Number of upvotes that this subject has received. */\n  upvoteCount: Scalars['Int']\n  /** Whether or not the current user can add or remove an upvote on this subject. */\n  viewerCanUpvote: Scalars['Boolean']\n  /** Whether or not the current user has already upvoted this subject. */\n  viewerHasUpvoted: Scalars['Boolean']\n}\n\n/** A workflow contains meta information about an Actions workflow file. */\nexport type Workflow = Node & {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  id: Scalars['ID']\n  /** The name of the workflow. */\n  name: Scalars['String']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n}\n\n/** A workflow run. */\nexport type WorkflowRun = Node & {\n  /** The check suite this workflow run belongs to. */\n  checkSuite: CheckSuite\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime']\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>\n  /** The log of deployment reviews */\n  deploymentReviews: DeploymentReviewConnection\n  id: Scalars['ID']\n  /** The pending deployment requests of all check runs in this workflow run */\n  pendingDeploymentRequests: DeploymentRequestConnection\n  /** The HTTP path for this workflow run */\n  resourcePath: Scalars['URI']\n  /** A number that uniquely identifies this workflow run in its parent workflow. */\n  runNumber: Scalars['Int']\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime']\n  /** The HTTP URL for this workflow run */\n  url: Scalars['URI']\n  /** The workflow executed in this workflow run. */\n  workflow: Workflow\n}\n\n/** A workflow run. */\nexport type WorkflowRunDeploymentReviewsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\n/** A workflow run. */\nexport type WorkflowRunPendingDeploymentRequestsArgs = {\n  after?: Maybe<Scalars['String']>\n  before?: Maybe<Scalars['String']>\n  first?: Maybe<Scalars['Int']>\n  last?: Maybe<Scalars['Int']>\n}\n\nexport type GetReposQueryVariables = Exact<{\n  search_term: Scalars['String']\n}>\n\nexport type GetReposQuery = {\n  search: {\n    repositoryCount: number\n    edges?:\n      | Array<\n          | {\n              node?:\n                | {\n                    name: string\n                    url: any\n                    description?: string | null | undefined\n                    owner:\n                      | { login: string; url: any; avatarUrl: any }\n                      | { login: string; url: any; avatarUrl: any }\n                    stargazers: { totalCount: number }\n                    primaryLanguage?: { name: string } | null | undefined\n                  }\n                | {}\n                | null\n                | undefined\n            }\n          | null\n          | undefined\n        >\n      | null\n      | undefined\n  }\n}\n\nexport const GetReposDocument = `\n    query GetRepos($search_term: String!) {\n  search(query: $search_term, type: REPOSITORY, first: 20) {\n    repositoryCount\n    edges {\n      node {\n        ... on Repository {\n          name\n          owner {\n            login\n            url\n            avatarUrl\n          }\n          stargazers {\n            totalCount\n          }\n          url\n          description\n          primaryLanguage {\n            name\n          }\n        }\n      }\n    }\n  }\n}\n    `\nexport const useGetReposQuery = <TData = GetReposQuery, TError = unknown>(\n  variables: GetReposQueryVariables,\n  options?: UseQueryOptions<GetReposQuery, TError, TData>\n) =>\n  useQuery<GetReposQuery, TError, TData>(\n    ['GetRepos', variables],\n    fetcher<GetReposQuery, GetReposQueryVariables>(GetReposDocument, variables),\n    options\n  )\n","import { makeTheme, makeColorsScale } from './type-utils'\n\nconst borderWidths = {\n  px: '1px',\n  '0': '0',\n  '2': '2px',\n  '4': '4px',\n  '8': '8px',\n}\n\nconst breakpoints = ['640px', '768px', '1024px', '1280px']\n\nconst baseColors = makeColorsScale({\n  transparent: 'transparent',\n  black: '#000',\n  white: '#fff',\n  gray: [\n    '',\n    '#f7fafc',\n    '#edf2f7',\n    '#e2e8f0',\n    '#cbd5e0',\n    '#a0aec0',\n    '#718096',\n    '#4a5568',\n    '#2d3748',\n    '#1a202c',\n  ],\n  red: [\n    '',\n    '#fff5f5',\n    '#fed7d7',\n    '#feb2b2',\n    '#fc8181',\n    '#f56565',\n    '#e53e3e',\n    '#c53030',\n    '#9b2c2c',\n    '#742a2a',\n  ],\n  orange: [\n    '',\n    '#fffaf0',\n    '#feebc8',\n    '#fbd38d',\n    '#f6ad55',\n    '#ed8936',\n    '#dd6b20',\n    '#c05621',\n    '#9c4221',\n    '#7b341e',\n  ],\n  yellow: [\n    '',\n    '#fffff0',\n    '#fefcbf',\n    '#faf089',\n    '#f6e05e',\n    '#ecc94b',\n    '#d69e2e',\n    '#b7791f',\n    '#975a16',\n    '#744210',\n  ],\n  green: [\n    '',\n    '#f0fff4',\n    '#c6f6d5',\n    '#9ae6b4',\n    '#68d391',\n    '#48bb78',\n    '#38a169',\n    '#2f855a',\n    '#276749',\n    '#22543d',\n  ],\n  teal: [\n    '',\n    '#e6fffa',\n    '#b2f5ea',\n    '#81e6d9',\n    '#4fd1c5',\n    '#38b2ac',\n    '#319795',\n    '#2c7a7b',\n    '#285e61',\n    '#234e52',\n  ],\n  blue: [\n    '',\n    '#ebf8ff',\n    '#bee3f8',\n    '#90cdf4',\n    '#63b3ed',\n    '#4299e1',\n    '#3182ce',\n    '#2b6cb0',\n    '#2c5282',\n    '#2a4365',\n  ],\n  indigo: [\n    '',\n    '#ebf4ff',\n    '#c3dafe',\n    '#a3bffa',\n    '#7f9cf5',\n    '#667eea',\n    '#5a67d8',\n    '#4c51bf',\n    '#434190',\n    '#3c366b',\n  ],\n  purple: [\n    '',\n    '#faf5ff',\n    '#e9d8fd',\n    '#d6bcfa',\n    '#b794f4',\n    '#9f7aea',\n    '#805ad5',\n    '#6b46c1',\n    '#553c9a',\n    '#44337a',\n  ],\n  pink: [\n    '',\n    '#fff5f7',\n    '#fed7e2',\n    '#fbb6ce',\n    '#f687b3',\n    '#ed64a6',\n    '#d53f8c',\n    '#b83280',\n    '#97266d',\n    '#702459',\n  ],\n})\n\nconst commonButtonStyles = {\n  py: 2,\n  px: 3,\n  cursor: `pointer`,\n  fontSize: `100%`,\n  lineHeight: `inherit`,\n}\n\nconst buttons = {\n  simple: {\n    ...commonButtonStyles,\n    backgroundColor: `primary`,\n    border: `none`,\n    color: `white`,\n    fontWeight: `bold`,\n    borderRadius: `default`,\n    '&:hover': {\n      backgroundColor: `primaryHover`,\n    },\n  },\n  pill: {\n    ...commonButtonStyles,\n    backgroundColor: `primary`,\n    border: `none`,\n    color: `white`,\n    fontWeight: `bold`,\n    borderRadius: `full`,\n    '&:hover': {\n      backgroundColor: `primaryHover`,\n    },\n  },\n  outline: {\n    ...commonButtonStyles,\n    backgroundColor: `transparent`,\n    borderWidth: `1px`,\n    borderStyle: `solid`,\n    borderColor: `primary`,\n    color: `primary`,\n    fontWeight: `semibold`,\n    borderRadius: `default`,\n    '&:hover': {\n      backgroundColor: `primary`,\n      color: `white`,\n      borderColor: `transparent`,\n    },\n  },\n  bordered: {\n    ...commonButtonStyles,\n    backgroundColor: `primary`,\n    borderWidth: `1px`,\n    borderStyle: `solid`,\n    borderColor: `primaryHover`,\n    color: `white`,\n    fontWeight: `bold`,\n    borderRadius: `default`,\n    '&:hover': {\n      backgroundColor: `primaryHover`,\n    },\n  },\n  disabled: {\n    ...commonButtonStyles,\n    backgroundColor: `primary`,\n    border: `none`,\n    opacity: 0.5,\n    cursor: `not-allowed`,\n    color: `white`,\n    fontWeight: `bold`,\n    borderRadius: `default`,\n  },\n  '3D': {\n    ...commonButtonStyles,\n    backgroundColor: `primary`,\n    border: `none`,\n    borderBottomWidth: `4px`,\n    borderBottomStyle: `solid`,\n    borderBottomColor: `primaryHover`,\n    color: `white`,\n    fontWeight: `bold`,\n    borderRadius: `default`,\n    transition: `transform 0.3s ease-in-out`,\n    '&:hover': {\n      transform: `translateY(-1px)`,\n    },\n  },\n  elevated: {\n    ...commonButtonStyles,\n    backgroundColor: `white`,\n    borderWidth: `1px`,\n    borderStyle: `solid`,\n    borderColor: `gray.4`,\n    color: `text`,\n    fontWeight: `bold`,\n    borderRadius: `default`,\n    boxShadow: `default`,\n    '&:hover': {\n      backgroundColor: `gray.1`,\n    },\n  },\n}\n\nconst colors = makeColorsScale({\n  ...baseColors,\n  grayDark: baseColors.gray[8],\n  text: baseColors.gray[8],\n  background: baseColors.white,\n  primary: baseColors.blue[7],\n  primaryHover: baseColors.blue[8],\n  secondary: baseColors.gray[6],\n  muted: baseColors.gray[3],\n  success: baseColors.green[3],\n  info: baseColors.blue[4],\n  warning: baseColors.yellow[3],\n  danger: baseColors.red[3],\n  light: baseColors.gray[1],\n  dark: baseColors.gray[8],\n  textMuted: baseColors.gray[6],\n})\n\nconst baseFonts = {\n  sans: 'system-ui,-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,\"Noto Sans\",sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\"',\n  serif: 'Georgia,Cambria,\"Times New Roman\",Times,serif',\n  mono: 'Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace',\n}\n\nconst fonts = {\n  ...baseFonts,\n  body: baseFonts.sans,\n  heading: 'inherit',\n  monospace: baseFonts.mono,\n}\n\nconst fontSizes = [\n  '0.875rem',\n  '1rem',\n  '1.25rem',\n  '1.5rem',\n  '1.875rem',\n  '2.25rem',\n  '3rem',\n  '4rem',\n  '4.5rem',\n]\n\nconst baseFontWeights = {\n  hairline: 100,\n  thin: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  bold: 700,\n  extrabold: 800,\n  black: 900,\n}\n\nconst fontWeights = {\n  ...baseFontWeights,\n  body: baseFontWeights.normal,\n  heading: baseFontWeights.bold,\n  label: baseFontWeights.thin,\n}\n\nconst commonInputStyles = {\n  py: 2,\n  px: 3,\n  fontSize: `100%`,\n  borderRadius: `default`,\n  appearance: `none`,\n  lineHeight: `tight`,\n}\n\nconst inputs = {\n  shadow: {\n    ...commonInputStyles,\n    border: `none`,\n    color: `gray.7`,\n    boxShadow: `default`,\n    '&:focus': {\n      outline: `none`,\n      boxShadow: `outline`,\n    },\n  },\n  inline: {\n    ...commonInputStyles,\n    backgroundColor: `gray.2`,\n    borderWidth: `2px`,\n    borderStyle: `solid`,\n    borderColor: `gray.2`,\n    color: `gray.7`,\n    '&:focus': {\n      outline: `none`,\n      borderColor: `primary`,\n      backgroundColor: `white`,\n    },\n  },\n  underline: {\n    ...commonInputStyles,\n    backgroundColor: `transparent`,\n    border: `none`,\n    borderBottomWidth: `2px`,\n    borderBottomStyle: `solid`,\n    borderBottomColor: `primary`,\n    borderRadius: `0px`,\n    color: `gray.7`,\n    '&:focus': {\n      outline: `none`,\n      borderColor: `primary`,\n      backgroundColor: `white`,\n    },\n  },\n}\n\nconst forms = {\n  label: {\n    fontSize: 1,\n    fontWeight: 300,\n  },\n}\nconst letterSpacings = {\n  tighter: '-0.05em',\n  tight: '-0.025em',\n  normal: '0',\n  wide: '0.025em',\n  wider: '0.05em',\n  widest: '0.1em',\n}\n\nconst baseLineHeights = {\n  none: '1',\n  tight: '1.25',\n  snug: '1.375',\n  normal: '1.5',\n  relaxed: '1.625',\n  loose: '2',\n}\n\nconst lineHeights = {\n  ...baseLineHeights,\n  body: baseLineHeights.relaxed,\n  heading: baseLineHeights.tight,\n}\n\nconst radii = {\n  none: '0',\n  sm: '0.125rem',\n  default: '0.25rem',\n  md: '0.375rem',\n  lg: '0.5rem',\n  full: '9999px',\n}\n\nconst tailwindSpacing = {\n  px: '1px',\n  '0': '0',\n  '1': '0.25rem',\n  '2': '0.5rem',\n  '3': '0.75rem',\n  '4': '1rem',\n  '5': '1.25rem',\n  '6': '1.5rem',\n  '8': '2rem',\n  '10': '2.5rem',\n  '12': '3rem',\n  '16': '4rem',\n  '20': '5rem',\n  '24': '6rem',\n  '32': '8rem',\n  '40': '10rem',\n  '48': '12rem',\n  '56': '14rem',\n  '64': '16rem',\n}\n\nconst tailwindMaxWidth = {\n  xs: '20rem',\n  sm: '24rem',\n  md: '28rem',\n  lg: '32rem',\n  xl: '36rem',\n  '2xl': '42rem',\n  '3xl': '48rem',\n  '4xl': '56rem',\n  '5xl': '64rem',\n  '6xl': '72rem',\n}\n\nconst tailwindWidth = {\n  '1/2': '50%',\n  '1/3': '33.333333%',\n  '2/3': '66.666667%',\n  '1/4': '25%',\n  '2/4': '50%',\n  '3/4': '75%',\n  '1/5': '20%',\n  '2/5': '40%',\n  '3/5': '60%',\n  '4/5': '80%',\n  '1/6': '16.666667%',\n  '2/6': '33.333333%',\n  '3/6': '50%',\n  '4/6': '66.666667%',\n  '5/6': '83.333333%',\n  '1/12': '8.333333%',\n  '2/12': '16.666667%',\n  '3/12': '25%',\n  '4/12': '33.333333%',\n  '5/12': '41.666667%',\n  '6/12': '50%',\n  '7/12': '58.333333%',\n  '8/12': '66.666667%',\n  '9/12': '75%',\n  '10/12': '83.333333%',\n  '11/12': '91.666667%',\n}\n\nconst sizes = {\n  ...tailwindSpacing,\n  ...tailwindMaxWidth,\n  ...tailwindWidth,\n  full: '100%',\n  screenHeight: '100vh',\n  screenWidth: '100vw',\n}\n\nconst shadows = {\n  xs: '0 0 0 1px rgba(0, 0, 0, 0.05)',\n  sm: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',\n  default: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',\n  md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',\n  lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',\n  xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',\n  '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',\n  inner: 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)',\n  outline: '0 0 0 3px rgba(66, 153, 225, 0.5)',\n  none: 'none',\n}\n\nconst space = ['0', '0.25rem', '0.5rem', '1rem', '2rem', '4rem', '8rem', '16rem', '32rem']\n\nconst zIndices = {\n  auto: 'auto',\n  '0': 0,\n  '10': 10,\n  '20': 20,\n  '30': 30,\n  '40': 40,\n  '50': 50,\n} as const\n\nconst heading = {\n  fontFamily: 'heading',\n  fontWeight: 'heading',\n  lineHeight: 'heading',\n  m: 0,\n  mb: 1,\n}\n\nconst cards = {\n  primary: {\n    padding: 2,\n    borderRadius: 4,\n    boxShadow: '0 0 8px rgba(0, 0, 0, 0.125)',\n  },\n  compact: {\n    padding: 1,\n    borderRadius: 2,\n    border: '1px solid',\n    borderColor: 'muted',\n  },\n}\n\nconst styles = {\n  root: {\n    fontFamily: 'body',\n    lineHeight: 'body',\n    fontWeight: 'body',\n  },\n  a: {\n    color: 'primary',\n    textDecoration: 'none',\n    ':hover': {\n      textDecoration: 'underline',\n    },\n  },\n  h1: {\n    ...heading,\n    fontSize: 6,\n    mt: 2,\n  },\n  h2: {\n    ...heading,\n    fontSize: 5,\n    mt: 2,\n  },\n  h3: {\n    ...heading,\n    fontSize: 4,\n    mt: 3,\n  },\n  h4: {\n    ...heading,\n    fontSize: 3,\n  },\n  h5: {\n    ...heading,\n    fontSize: 2,\n  },\n  h6: {\n    ...heading,\n    fontSize: 1,\n    mb: 2,\n  },\n  code: {},\n  pre: {},\n  hr: {\n    bg: 'muted',\n    border: 0,\n    height: '1px',\n    m: 3,\n  },\n}\n\nconst transforms = {\n  transformOrigin: {\n    center: 'center',\n    top: 'top',\n    'top-right': 'top right',\n    right: 'right',\n    'bottom-right': 'bottom right',\n    bottom: 'bottom',\n    'bottom-left': 'bottom left',\n    left: 'left',\n    'top-left': 'top left',\n  },\n  translate: {\n    ...tailwindSpacing,\n    '-full': '-100%',\n    '-1/2': '-50%',\n    '1/2': '50%',\n    full: '100%',\n  },\n  scale: {\n    '0': '0',\n    '50': '.5',\n    '75': '.75',\n    '90': '.9',\n    '95': '.95',\n    '100': '1',\n    '105': '1.05',\n    '110': '1.1',\n    '125': '1.25',\n    '150': '1.5',\n  },\n  rotate: {\n    '-180': '-180deg',\n    '-90': '-90deg',\n    '-45': '-45deg',\n    '0': '0',\n    '45': '45deg',\n    '90': '90deg',\n    '180': '180deg',\n  },\n  skew: {\n    '-12': '-12deg',\n    '-6': '-6deg',\n    '-3': '-3deg',\n    '0': '0',\n    '3': '3deg',\n    '6': '6deg',\n    '12': '12deg',\n  },\n}\n\nconst transitions = {\n  property: {\n    none: 'none',\n    all: 'all',\n    default: 'background-color, border-color, color, fill, stroke, opacity, box-shadow, transform',\n    colors: 'background-color, border-color, color, fill, stroke',\n    opacity: 'opacity',\n    shadow: 'box-shadow',\n    transform: 'transform',\n  },\n  timingFunction: {\n    linear: 'linear',\n    in: 'cubic-bezier(0.4, 0, 1, 1)',\n    out: 'cubic-bezier(0, 0, 0.2, 1)',\n    'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',\n  },\n  duration: {\n    '75': '75ms',\n    '100': '100ms',\n    '150': '150ms',\n    '200': '200ms',\n    '300': '300ms',\n    '500': '500ms',\n    '700': '700ms',\n    '1000': '1000ms',\n  },\n}\n\nexport const theme = makeTheme({\n  borderWidths,\n  breakpoints,\n  colors,\n  fonts,\n  fontSizes,\n  fontWeights,\n  letterSpacings,\n  lineHeights,\n  sizes,\n  shadows,\n  space,\n  radii,\n  zIndices,\n  styles,\n  buttons,\n  inputs,\n  cards,\n  forms,\n  transforms,\n  transitions,\n})\n","import { useEffect, useLayoutEffect, useState } from 'react'\nimport { BehaviorSubject, Subject, Observable } from 'rxjs'\n\n/**\n * @description CreateUseObservable factory for useObservable functions\n */\ntype CreateUseObservable = <EffectVariant extends typeof useEffect | typeof useLayoutEffect>(\n  effectVariant: EffectVariant\n) => {\n  <T>(observable: BehaviorSubject<T>): T\n  <T>(observable: Observable<T>, initialValue: T): T\n  <T>(observable: Subject<T>, initialValue: T): T\n}\n\nconst createUseObservable: CreateUseObservable =\n  effectVariant =>\n  (\n    observable,\n    // @ts-expect-error -- assigning value for behavior subject case\n    initialValue = observable.value\n  ) => {\n    const [val, setValue] = useState(initialValue)\n    effectVariant(() => {\n      const subscription = observable.subscribe(setValue)\n      return subscription.unsubscribe.bind(subscription)\n    }, [observable])\n    return val\n  }\n\nexport const useObservable = createUseObservable(useEffect)\nexport const useLayoutObservable = createUseObservable(useLayoutEffect)\n","/**\n * @file Observables - contains all observables used in the application\n *  to manage pieces of state accross the component tree.\n */\nimport { BehaviorSubject } from 'rxjs'\n\n// the generated type does not extract the node into its own type\n// TODO: get codegen to properly type these; many strings are any; unnecessary unions\nexport type RepoNode = {\n  name: string\n  url: string\n  description?: string | null | undefined\n  owner: { login: string; url: string; avatarUrl: string }\n  stargazers: { totalCount: number }\n  primaryLanguage?: { name: string } | null | undefined\n}\n\n// observables for routing and data between Search and Detail pages\nexport const repo$ = new BehaviorSubject<RepoNode | undefined>(undefined)\nexport const toRepo = repo$.next.bind(repo$)\nexport const page$ = new BehaviorSubject<'search' | 'detail'>('search')\nexport const toPage = page$.next.bind(page$)\n\n// observables for Search and SearchField\nexport const input$ = new BehaviorSubject('')\nexport const toInput = input$.next.bind(input$)\nexport const sort$ = new BehaviorSubject<'stars' | 'default'>('default')\nexport const toSort = input$.next.bind(sort$)\n","/** @jsxImportSource theme-ui */\nimport { useEffect, useRef, ChangeEvent } from 'react'\nimport { Flex, Input, Label, Radio, Text } from 'theme-ui'\nimport { useObservable } from '../hooks/useObservable'\nimport { input$, sort$, toInput, toSort } from '../observables'\n\nconst onInputChange = (event: ChangeEvent<HTMLInputElement>) => toInput(event.target.value)\n\nconst onRadioChange = (event: ChangeEvent<HTMLInputElement>) => toSort(event.currentTarget.value)\n\nexport const SearchField = () => {\n  const input = useObservable(input$)\n  const sort = useObservable(sort$)\n\n  const inputRef = useRef<HTMLInputElement | null>(null)\n\n  // Focus search input on init render\n  useEffect(() => {\n    inputRef?.current?.focus()\n  }, [])\n\n  return (\n    <Flex sx={{ flexDirection: 'column', mb: 2 }}>\n      {/* TODO: make label font variant for this repeated style */}\n      <Label htmlFor=\"search\" sx={{ fontSize: 1, fontWeight: 'thin' }}>\n        Search\n      </Label>\n      <Input\n        id=\"search\"\n        name=\"search\"\n        variant=\"shadow\"\n        value={input}\n        onChange={onInputChange}\n        ref={inputRef}\n        mb={2}\n      />\n      {/* TODO: Add toast message when error */}\n      <Flex sx={{ px: 3, flexDirection: 'row', justifyContent: 'end' }}>\n        <Text pr={2}>Sort By:</Text>\n        <Flex>\n          <Label htmlFor=\"sort-default\" sx={{ fontSize: 1, fontWeight: 'thin', mx: 2 }}>\n            <Radio\n              id=\"sort-default\"\n              name=\"default\"\n              value=\"default\"\n              sx={{ color: 'primary' }}\n              checked={sort === 'default'}\n              onChange={onRadioChange}\n            />\n            Default\n          </Label>\n          <Label htmlFor=\"sort-stars\" sx={{ fontSize: 1, fontWeight: 'thin', mx: 2 }}>\n            <Radio\n              id=\"sort-stars\"\n              name=\"stars\"\n              value=\"stars\"\n              sx={{ color: 'primary' }}\n              checked={sort === 'stars'}\n              onChange={onRadioChange}\n            />\n            Stars\n          </Label>\n        </Flex>\n      </Flex>\n    </Flex>\n  )\n}\n","/** @jsxImportSource theme-ui */\nimport { Card, Flex, Text } from 'theme-ui'\n\nexport type Repo = {\n  name: string\n  ownerName: string\n  starCount: number\n  onClick: () => void\n}\n\n/**\n * @description SearchResult component - displays individual search results\n *  with minimal information, and can be clicked to bring user to the Details page.\n */\nexport const SearchResult = ({ name = '', ownerName = '', starCount, onClick }: Repo) => (\n  <Card\n    key={`${name}-${ownerName}`}\n    sx={{\n      mb: 2,\n      p: 2,\n      display: 'flex',\n      flexDirection: 'row',\n      borderRadius: 4,\n      boxShadow: '0 0 3px rgba(0, 0, 0, 0.125)',\n      ':hover': { cursor: 'pointer' },\n    }}\n    onClick={onClick}\n  >\n    <Flex sx={{ flex: '0.3', flexDirection: 'column' }}>\n      <Text sx={{ fontWeight: 'bold' }}>{name}</Text>\n      <Text>{ownerName}</Text>\n    </Flex>\n    <Flex sx={{ flex: '0.7', justifyContent: 'end' }}>Stars: {starCount}</Flex>\n  </Card>\n)\n","/** @jsxImportSource theme-ui */\nimport { isEmpty, isNil } from 'ramda'\nimport { Divider, Flex, Spinner, Text } from 'theme-ui'\nimport { useGetReposQuery } from '../__generated__/graphql'\nimport { useDebounce, useObservable } from '../hooks'\nimport { SearchField } from '../components/SearchField'\nimport { SearchResult } from '../components/SearchResult'\nimport { RepoNode, input$, sort$, toRepo, toPage } from '../observables'\n\nexport const getSearchInput = (sort: 'stars' | 'default', input: string) =>\n  sort === 'stars' ? `sort:stars ${input}` : input\n\nexport const onPageNavigate = (page: 'detail' | 'search', repo?: RepoNode) => {\n  toRepo(repo)\n  toPage(page)\n}\n\nexport const Search = () => {\n  const input = useObservable(input$)\n  const sort = useObservable(sort$)\n  const debouncedInput = useDebounce(input, 400)\n  const { data, isLoading } = useGetReposQuery({\n    search_term: getSearchInput(sort, debouncedInput),\n  })\n\n  return (\n    <>\n      <SearchField />\n      <Divider />\n      {isLoading ? (\n        <Flex sx={{ justifyContent: 'center', alignContent: 'center' }}>\n          <Flex />\n          <Spinner />\n          <Flex />\n        </Flex>\n      ) : (\n        <Flex sx={{ flexDirection: 'column' }}>\n          <Text pb={3}>\n            Matching Repos:{' '}\n            <Text sx={{ fontWeight: 'semibold', fontStyle: 'italic' }}>\n              {data?.search.repositoryCount}\n            </Text>\n          </Text>\n          {data &&\n            data.search &&\n            data.search.edges?.map(\n              result =>\n                // prettier-ignore\n                !isEmpty(result?.node)\n                // @ts-expect-error -- we are checking that result is not empty or nil, and there are default params for SearhResult\n                && !isNil(result?.node) && <SearchResult onClick={() => onPageNavigate('detail', result?.node)} key={`${result.node.name}-${result.node.owner?.login}`} name={result.node.name} ownerName={result.node.owner?.login || ''} starCount={result.node.stargazers?.totalCount} />\n            )}\n        </Flex>\n      )}\n    </>\n  )\n}\n","import { useEffect, useState } from 'react'\n\nexport const useDebounce = <T>(value: T, delay: number) => {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value)\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value)\n    }, delay)\n\n    return () => {\n      clearTimeout(handler)\n    }\n  }, [value, delay])\n\n  return debouncedValue\n}\n","/** @jsxImportSource theme-ui */\nimport { Avatar, Container, Flex, Text } from 'theme-ui'\nimport { onPageNavigate } from '../pages/Search'\n\nexport const LayoutHeader = () => (\n  <Container sx={{ p: 2 }}>\n    <Flex>\n      <Avatar\n        width={60}\n        height={60}\n        src=\"octocat.png\"\n        onClick={() => onPageNavigate('search')}\n        sx={{ ':hover': { cursor: 'pointer' } }}\n      />\n      <Text\n        sx={{\n          font: 'heading',\n          fontWeight: 'heading',\n          fontSize: 4,\n          pl: 2,\n          ':hover': { cursor: 'pointer' },\n        }}\n        onClick={() => onPageNavigate('search')}\n      >\n        RepoSearch\n      </Text>\n    </Flex>\n  </Container>\n)\n","import { ReactNode } from 'react'\nimport { Container } from 'theme-ui'\nimport { LayoutHeader } from './LayoutHeader'\n\ntype LayoutProps = {\n  children: ReactNode\n}\n\nexport const Layout = ({ children }: LayoutProps) => (\n  <Container sx={{ height: 'screenHeight' }}>\n    <LayoutHeader />\n    <Container sx={{ px: 3 }}>{children}</Container>\n  </Container>\n)\n","/** @jsxImportSource theme-ui */\nimport { ReactNode } from 'react'\nimport { Avatar, Container, Divider, Flex, Link, Paragraph, Text } from 'theme-ui'\nimport { useObservable } from '../hooks'\nimport { repo$ } from '../observables'\n\ntype DetailFieldProps = {\n  title: string\n  children: ReactNode\n}\nconst DetailField = ({ children, title }: DetailFieldProps) => (\n  <Flex>\n    <Text sx={{ fontWeight: 'light', mr: 2 }}>{title}</Text>\n    <Text sx={{ fontWeight: 'semibold', fontStyle: 'italic' }}>{children}</Text>\n  </Flex>\n)\n\nexport const Detail = () => {\n  const repo = useObservable(repo$)\n  return (\n    <Container>\n      <Flex sx={{ flexDirection: 'row', justifyContent: 'center' }}>\n        <Flex sx={{ flexDirection: 'column', justifyContent: 'center', width: ['100%', '50%'] }}>\n          <Flex sx={{ flexDirection: 'row', justifyContent: 'center' }}>\n            <Text sx={{ fontSize: 5 }}>Repo Details</Text>\n          </Flex>\n          <Divider />\n          <Flex\n            sx={{\n              flexDirection: 'row',\n              justifyContent: 'space-between',\n              mb: 3,\n            }}\n          >\n            <Link sx={{ fontSize: 4, color: 'dark' }} href={repo?.url}>\n              {repo?.name}\n            </Link>\n            <a href={repo?.owner.url}>\n              <Avatar src={repo?.owner.avatarUrl} />\n            </a>\n          </Flex>\n          <Flex sx={{ flexDirection: 'column', justifyContent: 'center', mb: 2 }}>\n            <DetailField title=\"Owner: \">\n              {<Link href={repo?.owner.url}>repo?.owner.login</Link>}\n            </DetailField>\n            <DetailField title=\"Primary Language:\">{repo?.primaryLanguage?.name}</DetailField>\n            <DetailField title=\"Stars: \">{repo?.stargazers.totalCount}</DetailField>\n          </Flex>\n          <Flex>\n            <Paragraph>{repo?.description}</Paragraph>\n          </Flex>\n        </Flex>\n      </Flex>\n    </Container>\n  )\n}\n","import { QueryCache, QueryClient, QueryClientProvider } from 'react-query'\nimport { ReactQueryDevtools } from 'react-query/devtools'\nimport toast from 'react-hot-toast'\nimport { ThemeProvider } from 'theme-ui'\nimport { theme } from './theme/theme-default'\nimport { Search } from './pages/Search'\nimport { Layout } from './components/Layout'\nimport { useObservable } from './hooks'\nimport { Detail } from './pages/Detail'\nimport { page$ } from './observables'\n\nconst queryClient = new QueryClient({\n  queryCache: new QueryCache({\n    onError: (error, query) => {\n      if (query.state.data !== undefined) {\n        toast.error(`Oops! Something went wrong: ${error}`)\n      }\n    },\n  }),\n})\n\nexport const App = () => {\n  const page = useObservable(page$)\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ThemeProvider theme={theme}>\n        <Layout>{page === 'search' ? <Search /> : <Detail />}</Layout>\n      </ThemeProvider>\n      <ReactQueryDevtools initialIsOpen />\n    </QueryClientProvider>\n  )\n}\n","import { ReportHandler } from 'web-vitals'\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry)\n      getFID(onPerfEntry)\n      getFCP(onPerfEntry)\n      getLCP(onPerfEntry)\n      getTTFB(onPerfEntry)\n    })\n  }\n}\n\nexport default reportWebVitals\n","import { StrictMode } from 'react'\nimport ReactDOM from 'react-dom'\nimport { App } from './App'\nimport reportWebVitals from './reportWebVitals'\n\nif (process.env.NODE_ENV === 'test') {\n  const { worker } = require('./test-utils/setupWorker')\n  worker.start()\n}\n\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}